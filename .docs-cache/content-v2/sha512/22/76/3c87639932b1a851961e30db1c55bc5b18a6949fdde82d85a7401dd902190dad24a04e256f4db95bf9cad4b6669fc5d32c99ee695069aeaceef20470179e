{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 A library and CLI app for rendering project templates. Works with local paths and Git URLs . Your project can include any file and Copier can dynamically replace values in any kind of text file. It generates a beautiful output and takes care of not overwriting existing files unless instructed to do so. Installation \u00b6 Install Python 3.7 or newer (3.8 or newer if you're on Windows). Install Git 2.27 or newer. To use as a CLI app: pipx install copier To use as a library: pip install copier or conda install -c conda-forge copier Quick start \u00b6 To create a template: \ud83d\udcc1 my_copier_template ------------------------ # your template project \u251c\u2500\u2500 \ud83d\udcc4 copier.yml ---------------------------- # your template configuration \u251c\u2500\u2500 \ud83d\udcc1 .git ---------------------------------- # your template is a Git repository \u251c\u2500\u2500 \ud83d\udcc1 {{ project_name }} ---------------------- # a folder with a templated name \u2502 \u2514\u2500\u2500 \ud83d\udcc4 {{ module_name }} .py.jinja ---------- # a file with a templated name \u2514\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja --- # answers are recorded here copier.yml # questions project_name : type : str help : What is your project name? module_name : type : str help : What is your Python module name? {{project_name}}/{{module_name}}.py.jinja print(\"Hello from {{module_name}}!\") {{_copier_conf.answers_file}}.jinja # Changes here will be overwritten by Copier {{ _copier_answers | to_nice_yaml }} To generate a project from the template: On the command-line: copier path/to/project/template path/to/destination Or in Python code, programmatically: from copier import run_auto # Create a project from a local path run_auto ( \"path/to/project/template\" , \"path/to/destination\" ) # Or from a Git URL. run_auto ( \"https://github.com/copier-org/copier.git\" , \"path/to/destination\" ) # You can also use \"gh:\" as a shortcut of \"https://github.com/\" run_auto ( \"gh:copier-org/copier.git\" , \"path/to/destination\" ) # Or \"gl:\" as a shortcut of \"https://gitlab.com/\" run_auto ( \"gl:copier-org/copier.git\" , \"path/to/destination\" ) Basic concepts \u00b6 Copier is composed of these main concepts: Templates . They lay out how to generate the subproject. Questionaries . They are configured in the template. Answers are used to generate projects. Projects . This is where your real program lives. But it is usually generated and/or updated from a template. Copier targets these main human audiences: Template creators . Programmers that repeat code too much and prefer a tool to do it for them. Tip Copier doesn't replace the DRY principle... but sometimes you simply can't be DRY and you need a DRYing machine... Template consumers . Programmers that want to start a new project quickly, or that want to evolve it comfortably. Non-humans should be happy also by using Copier's CLI or API, as long as their expectations are the same as for those humans... and as long as they have feelings. Templates have these goals: Code scaffolding . Help consumers have a working source code tree as quickly as possible. All templates allow scaffolding. Code lifecycle management . When the template evolves, let consumers update their projects. Not all templates allow updating. Copier tries to have a smooth learning curve that lets you create simple templates that can evolve into complex ones as needed. Browse or tag public templates \u00b6 You can browse public Copier templates on GitHub using the copier-template topic . Use them as inspiration! If you want your template to appear in that list, just add the topic to it! \ud83c\udff7 Credits \u00b6 Special thanks go to jpsca for originally creating Copier . This project would not be a thing without him. Many thanks to pykong who took over maintainership on the project, promoted it, and laid out the bases of what the project is today. Big thanks also go to Yajo for his relentless zest for improving Copier even further. Thanks a lot, pawamoy for polishing very important rough edges and improving the documentation and UX a lot.","title":"Overview"},{"location":"#_1","text":"A library and CLI app for rendering project templates. Works with local paths and Git URLs . Your project can include any file and Copier can dynamically replace values in any kind of text file. It generates a beautiful output and takes care of not overwriting existing files unless instructed to do so.","title":""},{"location":"#installation","text":"Install Python 3.7 or newer (3.8 or newer if you're on Windows). Install Git 2.27 or newer. To use as a CLI app: pipx install copier To use as a library: pip install copier or conda install -c conda-forge copier","title":"Installation"},{"location":"#quick-start","text":"To create a template: \ud83d\udcc1 my_copier_template ------------------------ # your template project \u251c\u2500\u2500 \ud83d\udcc4 copier.yml ---------------------------- # your template configuration \u251c\u2500\u2500 \ud83d\udcc1 .git ---------------------------------- # your template is a Git repository \u251c\u2500\u2500 \ud83d\udcc1 {{ project_name }} ---------------------- # a folder with a templated name \u2502 \u2514\u2500\u2500 \ud83d\udcc4 {{ module_name }} .py.jinja ---------- # a file with a templated name \u2514\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja --- # answers are recorded here copier.yml # questions project_name : type : str help : What is your project name? module_name : type : str help : What is your Python module name? {{project_name}}/{{module_name}}.py.jinja print(\"Hello from {{module_name}}!\") {{_copier_conf.answers_file}}.jinja # Changes here will be overwritten by Copier {{ _copier_answers | to_nice_yaml }} To generate a project from the template: On the command-line: copier path/to/project/template path/to/destination Or in Python code, programmatically: from copier import run_auto # Create a project from a local path run_auto ( \"path/to/project/template\" , \"path/to/destination\" ) # Or from a Git URL. run_auto ( \"https://github.com/copier-org/copier.git\" , \"path/to/destination\" ) # You can also use \"gh:\" as a shortcut of \"https://github.com/\" run_auto ( \"gh:copier-org/copier.git\" , \"path/to/destination\" ) # Or \"gl:\" as a shortcut of \"https://gitlab.com/\" run_auto ( \"gl:copier-org/copier.git\" , \"path/to/destination\" )","title":"Quick start"},{"location":"#basic-concepts","text":"Copier is composed of these main concepts: Templates . They lay out how to generate the subproject. Questionaries . They are configured in the template. Answers are used to generate projects. Projects . This is where your real program lives. But it is usually generated and/or updated from a template. Copier targets these main human audiences: Template creators . Programmers that repeat code too much and prefer a tool to do it for them. Tip Copier doesn't replace the DRY principle... but sometimes you simply can't be DRY and you need a DRYing machine... Template consumers . Programmers that want to start a new project quickly, or that want to evolve it comfortably. Non-humans should be happy also by using Copier's CLI or API, as long as their expectations are the same as for those humans... and as long as they have feelings. Templates have these goals: Code scaffolding . Help consumers have a working source code tree as quickly as possible. All templates allow scaffolding. Code lifecycle management . When the template evolves, let consumers update their projects. Not all templates allow updating. Copier tries to have a smooth learning curve that lets you create simple templates that can evolve into complex ones as needed.","title":"Basic concepts"},{"location":"#browse-or-tag-public-templates","text":"You can browse public Copier templates on GitHub using the copier-template topic . Use them as inspiration! If you want your template to appear in that list, just add the topic to it! \ud83c\udff7","title":"Browse or tag public templates"},{"location":"#credits","text":"Special thanks go to jpsca for originally creating Copier . This project would not be a thing without him. Many thanks to pykong who took over maintainership on the project, promoted it, and laid out the bases of what the project is today. Big thanks also go to Yajo for his relentless zest for improving Copier even further. Thanks a lot, pawamoy for polishing very important rough edges and improving the documentation and UX a lot.","title":"Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. This project adheres to PEP 440 versioning schema, and the changelog itself conforms to Keep A Changelog . v7.0.1 (2022-10-14) \u00b6 Fix \u00b6 remove deprecated code scheduled for removal in Copier v7 (#843) v7.0.0 (2022-10-12) \u00b6 Feat \u00b6 expand tilde in template source path (#835) Fix \u00b6 delete temporary clones after execution automatically (#802) typing : remove invalid migration task stage \"task\" Refactor \u00b6 typing : use abstract container types where possible (#832) use dict constructor as default factory typing : remove unused types remove unreachable code (#826) model a task to execute using a dataclass reduce module imports v6.2.0 (2022-09-18) \u00b6 Feat \u00b6 add validator field to Question (#719) support passing github or gitlab urls without the .git suffix (#677) Fix \u00b6 compatibility with pydantic 1.10 git bundle support breaks with relative paths prevent name collision for question var name \"value\" Refactor \u00b6 add \"flake8-simplify\" plugin and simplify code v6.1.0 (2022-06-13) \u00b6 Feat \u00b6 support getting template commit hash with {{ _copier_conf.vcs_ref_hash }} simplify the format of the question prompt (#689) Fix \u00b6 ignore non-PEP-440-compliant tags (#676) [6.0.0] - 2022-05-15 \u00b6 All changes here . Summary: Added \u00b6 Allow using additional Jinja 2 extensions. Major version mismatch warning. If your Copier version is too new, you'll be warned. Specific exceptions, which will help on error detection for API usages. Multiline questions. Conditional questions. Placeholders. Interactive TUI for questionaries. Prompts are way cooler now. \ud83d\ude0e Python 3.9 support. Python 3.10 support. Support empty templates suffix, telling Copier to render every file. Added --defaults flag to use default answers to questions, which might be null if not specified. Added --overwrite flag to overwrite files that already exist, without asking. In migration scripts, we have the new environment variables $VERSION_PEP440_FROM , $VERSION_PEP440_CURRENT and $VERSION_PEP440_TO , which will always get a valid PEP440 version identifier, without the v prefix, allowing your migration scripts to have a valid standard where to base their logic. Raise a CopierAnswersInterrupt instead of a bare KeyboardInterrupt to provide callers with additional context - such as the partially completed AnswersMap. Support for user_defaults , which take precedence over template defaults. Copy dirty changes from a Git-tracked template to the project by default, to make testing easier. Advertise clearly which version is being copied or updated in the CLI. Add jinja variable _copier_python to provide Python sys.executable . Changed \u00b6 Fully refactored core. Running copier copy on a preexisting project now recopies the project instead of updating it. That means that it respects old answers, but ignores history diff. We use Jinja 2 defaults now. {{ }} instead of [[ ]] and similar. We keep trailing newlines by default for Jinja 2 templates. Copier will never ask for overwriting the answers file. Multi-typed choices follow the same type-casting logic as any other question, so it's easier to reason about them. However, if you were using this feature, you might be surprised about its side effects if you don't specify the type explicitly. Just add type: yaml to make it behave mostly as before. Or just don't use that, it's complicated anyway (warn added to docs). Changed --force to be the same as --defaults --overwrite . Copied files will reflect permissions on the same files in the template. Copier now uses git clone --filter=blob:none when cloning, to be faster. Removing files from templates will remove them too from the subprojects when they get updated. Deprecated \u00b6 Deprecated now and make_secret functions. If your template used those, Copier will emit warnings leading you on how to upgrade it. Templates marked with _min_copier_version below 6 will still default to use bracket-based Jinja defaults, but that will disappear soon. If you want your template to work on Copier 5 and 6, make sure to declare _envops explicitly in your copier.yaml . copier.copy() is confusing, now that actually copying and updating are 2 completely different actions (before, you were actually always updating if possible). Its direct equivalent is now copier.run_auto() , and copier.copy() will disappear in the future. Removed \u00b6 Minimal supported Python version is now 3.7 (dropped Python 3.6 support). Removed the json method on _copier_conf . Where you would previously use _copier_conf.json() in your templates, please now use _copier_conf|to_json instead. --subdirectory flag, which was confusing... and probably useless. Lots of dead code. Fixed \u00b6 A directory that gets an empty name works as expected: not copied (nor its contents). When comparing versions to update, PEP 440 is always used now. This way, we avoid fake ordering when Git commit descriptions happen to be ordered in a non-predictable way. Answers file will only remember answers to questions specified in the questionary. [5.1.0] - 2020-08-17 \u00b6 All changes here . Summary: Forbid downgrades. Print all logs to STDERR. [5.0.0] - 2020-08-13 \u00b6 All changes here . Summary: Add --prerelease flag, which will be False by default. This is a behavioral change and that's basically why I'm doing a new major release. All other changes are minor here. Better docs. [4.1.0] - 2020-08-10 \u00b6 All changes here . Summary: Make Copier work fine with Git 2.28. We have docs ! Polish docs a little bit. We now run tests on macOS and Windows! [4.0.2] - 2020-07-21 \u00b6 All changes here . Summary: Fix wrong templated default answers classification, which produced some questions being ignored. [4.0.1] - 2020-06-23 \u00b6 All changes here . Summary: Fix wrong prompt regression when updating. Remove redundant dst fixture in tests. [4.0.0] - 2020-06 \u00b6 All changes here . Summary: Remove semver to avoid having 2 different versioning systems. We stick to PEP 440 now. Remember where an answer comes from. Do not re-ask to the user if already answer via --data . Support pre-migration scripts that modify the answers file. [3.2.0] - 2020-06 \u00b6 All changes here . Summary: Templates can now use a subdirectory instead of always the template root. [3.1.0] - 2020-05 \u00b6 All changes here . Summary: Assert minimum Copier version. Prettier prompts. Prompt self-templating. Better README. [3.0.0] - 2020-03 \u00b6 This is a big release with many new features added and improved. The code base also received a lot of love and hardening. Features \u00b6 Minimal supported Python version is now 3.6. Dropped support for deprecated voodoo.json . Introduced gitignore-style patterns for exclude und skip-if-exists . Dropped support for include option. Added support for extending content of config files via content of other files via pyaml-include . Customizable template extension. Ability to remember last answers. Ability to choose where to remember them. Template upgrades support, (based on the previous points) with migration tasks specification. Extended questions format, supporting help, format, choices and secrets. More beautiful prompts. New CLI experience. Other \u00b6 Moved to poetry for package management. Type annotated entire code base. Increased test coverage. Ditched ruamel.yaml for PyYaml . Ditched Travis CI for GitHub Actions. Added pre-commit for enforced linting. Added prettier , black and isort for code formatting. Added pytest for running tests. Use plumbum as CLI and subprocess engine. [2.5.0] - 2019-06-16 \u00b6 Expanduser on all paths (so \"~/foo/bar\" is expanded to \" /foo/bar\"). Improve the output when running tasks. Remove the destination folder if the copy process or one of the tasks fail. Add a cleanup_on_error flag to optionally disable the cleanup feature. Add the skip_if_exists option to skip files, without asking, if they already exists in the destination folder. [2.4.2] - 2019-06-09 \u00b6 Fix MAJOR bug that was preventing the _exclude , _include and _tasks keys from copier.yml (or alternatives) to be used at all. It also interpreted _tasks as a user-provided variable. [2.4.0] - 2019-06-08 \u00b6 Empty folders are now copied. The folders are also displayed in the console output instead of just the files. prompt_bool can now have an undefined default (and answer is mandatory in that case). Reactivates the copier.yml and copier.yaml as configuration files. The new extra_paths argument specifies additional paths to find templates to inherit from. [2.3.0] - 2019-04-17 \u00b6 Back to using a setup.py instead of a pyproject.toml. The recommended configuration file is now copier.toml . [2.2.3] - 2019-04-13 \u00b6 The copier command-line script now accepts \"help\" and \"version\" as commands. [2.1.0] - 2019-02-08 \u00b6 Task runner \ud83c\udf89. Use _exclude , _include , and _tasks keys in copier.yml as the default values for the .copy() arguments exclude , include , and tasks . [2.0.0] - 2019-02-07 \u00b6 Rebranded from Voodoo to Copier ! Dropped support for Python 2.x, the minimal version is now Python 3.5. Cleanup and 100% test coverage. The recommended configuration file is now copier.yaml , but a copier.json can be used as well. The old voodoo.json is also supported for now but is deprecated and will be removed in version 2.2. Python package format updated to the latest standard (no setup.py \ud83d\ude35). Renamed the render_skeleton() function to copy() . The function signature remains almost the same, the only changes are: filter_this parameter is now called exclude . ignore_this parameter is now called just ignore . Dropped the idea of storing the templates in a hidden $HOME folder.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. This project adheres to PEP 440 versioning schema, and the changelog itself conforms to Keep A Changelog .","title":"Changelog"},{"location":"changelog/#v701-2022-10-14","text":"","title":"v7.0.1 (2022-10-14)"},{"location":"changelog/#fix","text":"remove deprecated code scheduled for removal in Copier v7 (#843)","title":"Fix"},{"location":"changelog/#v700-2022-10-12","text":"","title":"v7.0.0 (2022-10-12)"},{"location":"changelog/#feat","text":"expand tilde in template source path (#835)","title":"Feat"},{"location":"changelog/#fix_1","text":"delete temporary clones after execution automatically (#802) typing : remove invalid migration task stage \"task\"","title":"Fix"},{"location":"changelog/#refactor","text":"typing : use abstract container types where possible (#832) use dict constructor as default factory typing : remove unused types remove unreachable code (#826) model a task to execute using a dataclass reduce module imports","title":"Refactor"},{"location":"changelog/#v620-2022-09-18","text":"","title":"v6.2.0 (2022-09-18)"},{"location":"changelog/#feat_1","text":"add validator field to Question (#719) support passing github or gitlab urls without the .git suffix (#677)","title":"Feat"},{"location":"changelog/#fix_2","text":"compatibility with pydantic 1.10 git bundle support breaks with relative paths prevent name collision for question var name \"value\"","title":"Fix"},{"location":"changelog/#refactor_1","text":"add \"flake8-simplify\" plugin and simplify code","title":"Refactor"},{"location":"changelog/#v610-2022-06-13","text":"","title":"v6.1.0 (2022-06-13)"},{"location":"changelog/#feat_2","text":"support getting template commit hash with {{ _copier_conf.vcs_ref_hash }} simplify the format of the question prompt (#689)","title":"Feat"},{"location":"changelog/#fix_3","text":"ignore non-PEP-440-compliant tags (#676)","title":"Fix"},{"location":"changelog/#600-2022-05-15","text":"All changes here . Summary:","title":"[6.0.0] - 2022-05-15"},{"location":"changelog/#added","text":"Allow using additional Jinja 2 extensions. Major version mismatch warning. If your Copier version is too new, you'll be warned. Specific exceptions, which will help on error detection for API usages. Multiline questions. Conditional questions. Placeholders. Interactive TUI for questionaries. Prompts are way cooler now. \ud83d\ude0e Python 3.9 support. Python 3.10 support. Support empty templates suffix, telling Copier to render every file. Added --defaults flag to use default answers to questions, which might be null if not specified. Added --overwrite flag to overwrite files that already exist, without asking. In migration scripts, we have the new environment variables $VERSION_PEP440_FROM , $VERSION_PEP440_CURRENT and $VERSION_PEP440_TO , which will always get a valid PEP440 version identifier, without the v prefix, allowing your migration scripts to have a valid standard where to base their logic. Raise a CopierAnswersInterrupt instead of a bare KeyboardInterrupt to provide callers with additional context - such as the partially completed AnswersMap. Support for user_defaults , which take precedence over template defaults. Copy dirty changes from a Git-tracked template to the project by default, to make testing easier. Advertise clearly which version is being copied or updated in the CLI. Add jinja variable _copier_python to provide Python sys.executable .","title":"Added"},{"location":"changelog/#changed","text":"Fully refactored core. Running copier copy on a preexisting project now recopies the project instead of updating it. That means that it respects old answers, but ignores history diff. We use Jinja 2 defaults now. {{ }} instead of [[ ]] and similar. We keep trailing newlines by default for Jinja 2 templates. Copier will never ask for overwriting the answers file. Multi-typed choices follow the same type-casting logic as any other question, so it's easier to reason about them. However, if you were using this feature, you might be surprised about its side effects if you don't specify the type explicitly. Just add type: yaml to make it behave mostly as before. Or just don't use that, it's complicated anyway (warn added to docs). Changed --force to be the same as --defaults --overwrite . Copied files will reflect permissions on the same files in the template. Copier now uses git clone --filter=blob:none when cloning, to be faster. Removing files from templates will remove them too from the subprojects when they get updated.","title":"Changed"},{"location":"changelog/#deprecated","text":"Deprecated now and make_secret functions. If your template used those, Copier will emit warnings leading you on how to upgrade it. Templates marked with _min_copier_version below 6 will still default to use bracket-based Jinja defaults, but that will disappear soon. If you want your template to work on Copier 5 and 6, make sure to declare _envops explicitly in your copier.yaml . copier.copy() is confusing, now that actually copying and updating are 2 completely different actions (before, you were actually always updating if possible). Its direct equivalent is now copier.run_auto() , and copier.copy() will disappear in the future.","title":"Deprecated"},{"location":"changelog/#removed","text":"Minimal supported Python version is now 3.7 (dropped Python 3.6 support). Removed the json method on _copier_conf . Where you would previously use _copier_conf.json() in your templates, please now use _copier_conf|to_json instead. --subdirectory flag, which was confusing... and probably useless. Lots of dead code.","title":"Removed"},{"location":"changelog/#fixed","text":"A directory that gets an empty name works as expected: not copied (nor its contents). When comparing versions to update, PEP 440 is always used now. This way, we avoid fake ordering when Git commit descriptions happen to be ordered in a non-predictable way. Answers file will only remember answers to questions specified in the questionary.","title":"Fixed"},{"location":"changelog/#510-2020-08-17","text":"All changes here . Summary: Forbid downgrades. Print all logs to STDERR.","title":"[5.1.0] - 2020-08-17"},{"location":"changelog/#500-2020-08-13","text":"All changes here . Summary: Add --prerelease flag, which will be False by default. This is a behavioral change and that's basically why I'm doing a new major release. All other changes are minor here. Better docs.","title":"[5.0.0] - 2020-08-13"},{"location":"changelog/#410-2020-08-10","text":"All changes here . Summary: Make Copier work fine with Git 2.28. We have docs ! Polish docs a little bit. We now run tests on macOS and Windows!","title":"[4.1.0] - 2020-08-10"},{"location":"changelog/#402-2020-07-21","text":"All changes here . Summary: Fix wrong templated default answers classification, which produced some questions being ignored.","title":"[4.0.2] - 2020-07-21"},{"location":"changelog/#401-2020-06-23","text":"All changes here . Summary: Fix wrong prompt regression when updating. Remove redundant dst fixture in tests.","title":"[4.0.1] - 2020-06-23"},{"location":"changelog/#400-2020-06","text":"All changes here . Summary: Remove semver to avoid having 2 different versioning systems. We stick to PEP 440 now. Remember where an answer comes from. Do not re-ask to the user if already answer via --data . Support pre-migration scripts that modify the answers file.","title":"[4.0.0] - 2020-06"},{"location":"changelog/#320-2020-06","text":"All changes here . Summary: Templates can now use a subdirectory instead of always the template root.","title":"[3.2.0] - 2020-06"},{"location":"changelog/#310-2020-05","text":"All changes here . Summary: Assert minimum Copier version. Prettier prompts. Prompt self-templating. Better README.","title":"[3.1.0] - 2020-05"},{"location":"changelog/#300-2020-03","text":"This is a big release with many new features added and improved. The code base also received a lot of love and hardening.","title":"[3.0.0] - 2020-03"},{"location":"changelog/#features","text":"Minimal supported Python version is now 3.6. Dropped support for deprecated voodoo.json . Introduced gitignore-style patterns for exclude und skip-if-exists . Dropped support for include option. Added support for extending content of config files via content of other files via pyaml-include . Customizable template extension. Ability to remember last answers. Ability to choose where to remember them. Template upgrades support, (based on the previous points) with migration tasks specification. Extended questions format, supporting help, format, choices and secrets. More beautiful prompts. New CLI experience.","title":"Features"},{"location":"changelog/#other","text":"Moved to poetry for package management. Type annotated entire code base. Increased test coverage. Ditched ruamel.yaml for PyYaml . Ditched Travis CI for GitHub Actions. Added pre-commit for enforced linting. Added prettier , black and isort for code formatting. Added pytest for running tests. Use plumbum as CLI and subprocess engine.","title":"Other"},{"location":"changelog/#250-2019-06-16","text":"Expanduser on all paths (so \"~/foo/bar\" is expanded to \" /foo/bar\"). Improve the output when running tasks. Remove the destination folder if the copy process or one of the tasks fail. Add a cleanup_on_error flag to optionally disable the cleanup feature. Add the skip_if_exists option to skip files, without asking, if they already exists in the destination folder.","title":"[2.5.0] - 2019-06-16"},{"location":"changelog/#242-2019-06-09","text":"Fix MAJOR bug that was preventing the _exclude , _include and _tasks keys from copier.yml (or alternatives) to be used at all. It also interpreted _tasks as a user-provided variable.","title":"[2.4.2] - 2019-06-09"},{"location":"changelog/#240-2019-06-08","text":"Empty folders are now copied. The folders are also displayed in the console output instead of just the files. prompt_bool can now have an undefined default (and answer is mandatory in that case). Reactivates the copier.yml and copier.yaml as configuration files. The new extra_paths argument specifies additional paths to find templates to inherit from.","title":"[2.4.0] - 2019-06-08"},{"location":"changelog/#230-2019-04-17","text":"Back to using a setup.py instead of a pyproject.toml. The recommended configuration file is now copier.toml .","title":"[2.3.0] - 2019-04-17"},{"location":"changelog/#223-2019-04-13","text":"The copier command-line script now accepts \"help\" and \"version\" as commands.","title":"[2.2.3] - 2019-04-13"},{"location":"changelog/#210-2019-02-08","text":"Task runner \ud83c\udf89. Use _exclude , _include , and _tasks keys in copier.yml as the default values for the .copy() arguments exclude , include , and tasks .","title":"[2.1.0] - 2019-02-08"},{"location":"changelog/#200-2019-02-07","text":"Rebranded from Voodoo to Copier ! Dropped support for Python 2.x, the minimal version is now Python 3.5. Cleanup and 100% test coverage. The recommended configuration file is now copier.yaml , but a copier.json can be used as well. The old voodoo.json is also supported for now but is deprecated and will be removed in version 2.2. Python package format updated to the latest standard (no setup.py \ud83d\ude35). Renamed the render_skeleton() function to copy() . The function signature remains almost the same, the only changes are: filter_this parameter is now called exclude . ignore_this parameter is now called just ignore . Dropped the idea of storing the templates in a hidden $HOME folder.","title":"[2.0.0] - 2019-02-07"},{"location":"comparisons/","text":"Comparing Copier to other project generators \u00b6 The subject of code scaffolding has been around for some time, and there are long established good projects. Here's a simple comparison. If you find something wrong, please open a PR and fix these docs! We don't want to be biased, but it's easy that we tend to be: Important Although Copier was born as a code scaffolding tool, it is today a code lifecycle management tool. This makes it somehow unique. Most tools below are only scaffolders and the comparison is not complete due to that. Feature Copier Cookiecutter Yeoman Can template file names Yes Yes Yes Configuration Single YAML file 1 Single JSON file JS module Migrations Yes No No Programmed in Python Python NodeJS Requires handwriting JSON No Yes Yes Requires installing templates separately No No Yes Requires programming No No Yes, JS Requires templates to have a suffix Yes by default, configurable 3 No, not configurable You choose Task hooks Yes Yes Yes Context hooks Yes 5 Yes ? Template in a subfolder Not required, but you choose Yes, required Yes, required Template package format Git repo 2 , Git bundle, folder Git or Mercurial repo, Zip file NPM package Template updates Yes 4 No No Templating engine Jinja Jinja EJS The file itself can include other YAML files . \u21a9 Git repo is recommended to be able to use advanced features such as template tagging and smart updates. \u21a9 A suffix is required by default. Defaults to .jinja , but can be configured to use a different suffix, or to use none. \u21a9 Only for Git templates, because Copier uses Git tags to obtain available versions and extract smart diffs between them. \u21a9 Context hooks are provided through the ContextHook extension . \u21a9","title":"Comparisons"},{"location":"comparisons/#comparing-copier-to-other-project-generators","text":"The subject of code scaffolding has been around for some time, and there are long established good projects. Here's a simple comparison. If you find something wrong, please open a PR and fix these docs! We don't want to be biased, but it's easy that we tend to be: Important Although Copier was born as a code scaffolding tool, it is today a code lifecycle management tool. This makes it somehow unique. Most tools below are only scaffolders and the comparison is not complete due to that. Feature Copier Cookiecutter Yeoman Can template file names Yes Yes Yes Configuration Single YAML file 1 Single JSON file JS module Migrations Yes No No Programmed in Python Python NodeJS Requires handwriting JSON No Yes Yes Requires installing templates separately No No Yes Requires programming No No Yes, JS Requires templates to have a suffix Yes by default, configurable 3 No, not configurable You choose Task hooks Yes Yes Yes Context hooks Yes 5 Yes ? Template in a subfolder Not required, but you choose Yes, required Yes, required Template package format Git repo 2 , Git bundle, folder Git or Mercurial repo, Zip file NPM package Template updates Yes 4 No No Templating engine Jinja Jinja EJS The file itself can include other YAML files . \u21a9 Git repo is recommended to be able to use advanced features such as template tagging and smart updates. \u21a9 A suffix is required by default. Defaults to .jinja , but can be configured to use a different suffix, or to use none. \u21a9 Only for Git templates, because Copier uses Git tags to obtain available versions and extract smart diffs between them. \u21a9 Context hooks are provided through the ContextHook extension . \u21a9","title":"Comparing Copier to other project generators"},{"location":"configuring/","text":"Configuring a template \u00b6 Configuration sources \u00b6 It is important that you understand how Copier works. It has 2 kinds of configurations: Settings for Copier itself. This includes things as minimal Copier version required, which subdirectory to render, tasks to run, etc. Answers . This is customized per template. The user answers template questions, and those answers are stored as variables available for the template at rendering time. Copier reads settings from these sources, in this order of priority: Command line or API arguments. The copier.yml file . Settings here always start with an underscore (e.g. _min_copier_version ). Info Some settings are only available as CLI arguments, and some others only as template configurations. Some behave differently depending on where they are defined. Check the docs for each specific setting . Copier obtains answers from these sources, in this order of priority: Command line or API arguments. Asking the user. Notice that Copier will not ask any questions answered in the previous source. Answer from last execution . Default values defined in the copier.yml file . The copier.yml file \u00b6 The copier.yml (or copier.yaml ) file is found in the root of the template, and it is the main entrypoint for managing your template configuration. It will be read and used for two purposes: Prompting the user for information . Applying template settings (excluding files, setting arguments defaults, etc.). Questions \u00b6 For each key found, Copier will prompt the user to fill or confirm the values before they become available to the project template. Example This copier.yml file: name_of_the_project : My awesome project number_of_eels : 1234 your_email : \"\" Will result in a questionary similar to: \ud83c\udfa4 name_of_the_project My awesome project \ud83c\udfa4 number_of_eels (int) 1234 \ud83c\udfa4 your_email Advanced prompt formatting \u00b6 Apart from the simplified format, as seen above, Copier supports a more advanced format to ask users for data. To use it, the value must be a dict. Supported keys: type : User input must match this type. Options are: bool , float , int , json , str , yaml (default). help : Additional text to help the user know what's this question for. choices : To restrict possible values. Tip A choice value of null makes it become the same as its key. Warning You are able to use different types for each choice value, but it is not recommended because you can get to some weird scenarios. For example, try to understand this \ud83e\udd74 copier.yml pick_one : type : yaml # If you are mixing types, better be explicit choices : Nothing, thanks : \"null\" # Will be YAML-parsed and converted to null Value is key : null # Value will be converted to \"Value is key\" One and a half : 1.5 \"Yes\" : true Nope : no Some array : \"[yaml, converts, this]\" It's better to stick with a simple type and reason about it later in template code: copier.yml pick_one : type : str choices : Nothing, thanks : \"\" Value is key : null # Becomes \"Value is key\", which is a str One and a half : \"1.5\" \"Yes\" : \"true\" Nope : \"no\" Some array : \"[str, keeps, this, as, a, str]\" default : Leave empty to force the user to answer. Provide a default to save them from typing it if it's quite common. When using choices , the default must be the choice value , not its key , and it must match its type . If values are quite long, you can use YAML anchors . secret : When true , it hides the prompt displaying asterisks ( ***** ) and doesn't save the answer in the answers file placeholder : To provide a visual example for what would be a good value. It is only shown while the answer is empty, so maybe it doesn't make much sense to provide both default and placeholder . Warning Multiline placeholders are not supported currently, due to this upstream bug . multiline : When set to true , it allows multiline input. This is especially useful when type is json or yaml . validator : Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render nothing if the value is valid, and an error message to show to the user otherwise. when : Condition that, if false , skips the question. If it is a boolean, it is used directly, but it's a bit absurd in that case. If it is a string, it is converted to boolean using a parser similar to YAML, but only for boolean values. This is most useful when templated . If a question is skipped, its answer will be: The default value, if you're generating the project for the 1st time. The last answer recorded, if you're updating the project. Example copier.yaml project_creator : type : str project_license : type : str choices : - GPLv3 - Public domain copyright_holder : type : str default : |- {% if project_license == 'Public domain' -%} {#- Nobody owns public projects -#} nobody {%- else -%} {#- By default, project creator is the owner -#} {{ project_creator }} {%- endif %} # Only ask for copyright if project is not in the public domain when : \"{{ project_license != 'Public domain' }}\" Example copier.yml love_copier : type : bool # This makes Copier ask for y/n help : Do you love Copier? default : yes # Without a default, you force the user to answer project_name : type : str # Any value will be treated raw as a string help : An awesome project needs an awesome name. Tell me yours. default : paradox-specifier rocket_launch_password : type : str secret : true # This value will not be logged into .copier-answers.yml placeholder : my top secret password # I'll avoid default and help here, but you can use them too age : type : int validator : \"{% if age <= 0 %}Must be positive{% endif %}\" height : type : float any_json : help : Tell me anything, but format it as a one-line JSON string type : json multiline : true any_yaml : help : Tell me anything, but format it as a one-line YAML string type : yaml # This is the default type, also for short syntax questions multiline : true your_favorite_book : # User will choose one of these and your template will get the value choices : - The Bible - The Hitchhiker's Guide to the Galaxy project_license : # User will see only the dict key and choose one, but you will # get the dict value in your template choices : MIT : &mit_text | Here I can write the full text of the MIT license. This will be a long text, shortened here for example purposes. Apache2 : | Full text of Apache2 license. # When using choices, the default value is the value, **not** the key; # that's why I'm using the YAML anchor declared above to avoid retyping the # whole license default : *mit_text # You can still define the type, to make sure answers that come from --data # CLI argument match the type that your template expects type : str close_to_work : help : Do you live close to your work? # This format works just like the dict one choices : - [ at home , I work at home ] - [ less than 10km , quite close ] - [ more than 10km , not so close ] - [ more than 100km , quite far away ] Prompt templating \u00b6 Most of those options can be templated using Jinja. Keep in mind that the configuration is loaded as YAML , so the contents must be valid YAML and respect Copier's structure . That is why we explicitly wrap some strings in double-quotes in the following examples. Answers provided through interactive prompting will not be rendered with Jinja, so you cannot use Jinja templating in your answers. Example copier.yml # default username : type : str organization : type : str email : type : str # Notice that both `username` and `organization` have been already asked default : \"{{ username }}@{{ organization }}.com\" # help copyright_holder : type : str when : \"{% if organization != 'Public domain' %}true{% endif %}\" help : The person or entity within {{ organization }} that holds copyrights. # type target : type : str choices : - humans - machines user_config : type : \"{% if target == 'humans' %}yaml{% else %}json{% endif %}\" # choices title : type : str help : Your title within {{ organization }} contact : choices : Copyright holder : \"{{ copyright_holder }}\" CEO : Alice Bob CTO : Carl Dave \"{{ title }}\" : \"{{ username }}\" Warning Keep in mind that: You can only template inside the value... ... which must be a string to be templated. Also you won't be able to use variables that aren't yet declared. copier.yml your_age : type : int # Valid double_it : type : int default : \"{{ your_age * 2}}\" # Invalid, the templating occurs outside of the parameter value did_you_ask : type : str { % if your_age % } default : \"yes\" { % else % } placeholder : \"nope\" { % endif % } # Invalid, `a_random_word` wasn't answered yet other_random_word : type : str placeholder : \"Something different to {{ a_random_word }}\" # Invalid, YAML interprets curly braces a_random_word : type : str default : {{ 'hello' }} Include other YAML files \u00b6 The copier.yml file supports multiple documents. When found, they are merged ( not deeply merged; just merged) and the latest one defined has priority. It also supports using the !include tag to include other configurations from elsewhere. These two features, combined, allow you to reuse common partial sections from your templates. Hint You can use Git submodules to sanely include shared code into templates. Example This would be a valid copier.yml file: --- # Copier will load all these files !include shared-conf/common.*.yml # These 3 lines split the several YAML documents --- # These two documents include common questions for these kind of projects !include common-questions/web_app.yml --- !include common-questions/python-project.yml --- # Here you can specify any settings or questions specific for your template, _skip_if_exists : - .password.txt custom_question : default answer Conditional files and directories \u00b6 You can take advantage of the ability to template file and directory names to make them \"conditional\", i.e. to only generate them based on the answers given by a user. For example, you can ask users if they want to use pre-commit : copier.yml use_precommit : type : bool default : false help : Do you want to use pre-commit? And then, you can generate a .pre-commit-config.yaml file only if they answered \"yes\": \ud83d\udcc1 your_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yml \u2514\u2500\u2500 \ud83d\udcc4 { % if use_precommit % } .pre-commit-config.yaml { % endif % } .jinja Important Note that the chosen template suffix must appear outside of the Jinja condition, otherwise the whole file won't be considered a template and will be copied as such in generated projects. You can even use the answers of questions with choices : copier.yml ci : type : str help : What Continuous Integration service do you want to use? choices : GitHub CI : github GitLab CI : gitlab default : github \ud83d\udcc1 your_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yml \u251c\u2500\u2500 \ud83d\udcc1 { % if ci == 'github' % } .github { % endif % } \u2502 \u2514\u2500\u2500 \ud83d\udcc1 workflows \u2502 \u2514\u2500\u2500 \ud83d\udcc4 ci.yml \u2514\u2500\u2500 \ud83d\udcc4 { % if ci == 'gitlab' % } .gitlab-ci.yml { % endif % } .jinja Important Contrary to files, directories must not end with the template suffix . Warning On Windows, double-quotes are not valid characters in file and directory paths. This is why we used single-quotes in the example above. Available settings \u00b6 Template settings alter how the template is rendered. They come from several sources . Remember that the key must be prefixed with an underscore if you use it in the copier.yml file . answers_file \u00b6 Format: str CLI flags: -a , --answers-file Default value: .copier-answers.yml Path to a file where answers will be recorded by default. The path must be relative to the project root. Tip Remember to add that file to your Git template if you want to support updates . Don't forget to read the docs about the answers file . Example copier.yml _answers_file : .my-custom-answers.yml cleanup_on_error \u00b6 Format: bool CLI flags: -C , --no-cleanup (used to disable this setting; only available in copier copy subcommand) Default value: True When Copier creates the destination path, if there's any failure when rendering the template (either in the rendering process or when running the tasks ), Copier will delete that folder. Copier will never delete the folder if it didn't create it. For this reason, when running copier update , this setting has no effect. Info Not supported in copier.yml . data \u00b6 Format: dict|List[str=str] CLI flags: -d , --data Default value: N/A Give answers to questions through CLI/API. This cannot be defined in copier.yml , where its equivalent would be just normal questions with default answers. Example Example CLI usage to take all default answers from template, except the user name, which is overridden, and don't ask user anything else: copier -fd 'user_name=Manuel Calavera' copy template destination envops \u00b6 Format: dict CLI flags: N/A Default value: {\"keep_trailing_newline\": true} Configurations for the Jinja environment. Copier uses the Jinja defaults whenever possible. The only exception at the moment is that Copier keeps trailing newlines at the end of a template file. If you want to remove those, either remove them from the template or set keep_trailing_newline to false . See upstream docs to know available options. Warning Copier 5 and older had different, bracket-based defaults. If your template was created for Copier 5, you need to add this configuration to your copier.yaml to keep it working just like before: _envops : autoescape : false block_end_string : \"%]\" block_start_string : \"[%\" comment_end_string : \"#]\" comment_start_string : \"[#\" keep_trailing_newline : true variable_end_string : \"]]\" variable_start_string : \"[[\" By specifying this, your template will be compatible with both Copier 5 and 6. Copier 6 will apply these older defaults if your min_copier_version is lower than 6, but that will be removed in the future. exclude \u00b6 Format: List[str] CLI flags: -x , --exclude Default value: [\"copier.yaml\", \"copier.yml\", \"~*\", \"*.py[co]\", \"__pycache__\", \".git\", \".DS_Store\", \".svn\"] Patterns for files/folders that must not be copied. The CLI option can be passed several times to add several patterns. Info When you define this parameter in copier.yml , it will replace the default value. In this example, for instance, \"copier.yml\" will not be excluded: Example _exclude : - \"*.bar\" - \".git\" Info When you add this parameter from CLI or API, it will not replace the values defined in copier.yml (or the defaults, if missing). Instead, CLI/API definitions will extend those from copier.yml . Example CLI usage to copy only a single file from the template copier --exclude '*' --exclude '!file-i-want' copy ./template ./destination force \u00b6 Format: bool CLI flags: -f , --force Default value: False Overwrite files that already exist, without asking. Also don't ask questions to the user; just use default values obtained from other sources . Info Not supported in copier.yml . defaults \u00b6 Format: bool CLI flags: --defaults Default value: False Use default answers to questions, which might be null if not specified. Info Not supported in copier.yml . overwrite \u00b6 Format: bool CLI flags: --overwrite Default value: False Overwrite files that already exist, without asking. obtained from other sources . Info Not supported in copier.yml . jinja_extensions \u00b6 Format: List[str] CLI flags: N/A Default value: [] Additional Jinja2 extensions to load in the Jinja2 environment. Extensions can add filters, global variables and functions, or tags to the environment. The following extensions are always loaded: jinja2_ansible_filters.AnsibleCoreFiltersExtension : this extension adds most of the Ansible filters to the environment. You don't need to tell your template users to install these extensions: Copier depends on them, so they are always installed when Copier is installed. Warning Including an extension allows Copier to execute uncontrolled code, thus making the template potentially more dangerous. Be careful about what extensions you install. Note to template writers You must inform your users that they need to install the extensions alongside Copier, i.e. in the same virtualenv where Copier is installed. For example, if your template uses jinja2_time.TimeExtension , your users must install the jinja2-time Python package. # with pip, in the same virtualenv where Copier is installed pip install jinja2-time # if Copier was installed with pipx pipx inject copier jinja2-time Example copier.yml _jinja_extensions : - jinja_markdown.MarkdownExtension - jinja2_slug.SlugExtension - jinja2_time.TimeExtension Hint Examples of extensions you can use: Native Jinja2 extensions : expression statement , which can be used to alter the Jinja context (answers, filters, etc.) or execute other operations, without outputting anything. loop controls , which adds the break and continue keywords for Jinja loops. debug extension , which can dump the current context thanks to the added {% debug %} tag. From cookiecutter : cookiecutter.extensions.JsonifyExtension : provides a jsonify filter, to format a dictionary as JSON. Note that Copier natively provides a to_nice_json filter that can achieve the same thing. cookiecutter.extensions.RandomStringExtension : provides a random_ascii_string(length, punctuation=False) global function. Note that Copier natively provides the ans_random and hash filters that can be used to achieve the same thing: Example {{ 999999999999999999999999999999999 | ans_random | hash ( 'sha512' ) }} cookiecutter.extensions.SlugifyExtension : provides a slugify filter using python-slugify . copier_templates_extensions.TemplateExtensionLoader : enhances the extension loading mechanism to allow templates writers to put their extensions directly in their templates. It also allows to modify the rendering context (the Jinja variables that you can use in your templates) before rendering templates, see using a context hook . jinja_markdown.MarkdownExtension : provides a markdown tag that will render Markdown to HTML using PyMdown extensions . jinja2_slug.SlugExtension : provides a slug filter using unicode-slugify . jinja2_time.TimeExtension : adds a now tag that provides convenient access to the arrow.now() API. Search for more extensions on GitHub using the jinja2-extension topic , or other Jinja2 topics , or on PyPI using the jinja + extension keywords . migrations \u00b6 Format: List[dict] CLI flags: N/A Default value: [] Migrations are like tasks , but each item in the list is a dict with these keys: version : Indicates the version that the template update has to go through to trigger this migration. It is evaluated using PEP 440 . before (optional): Commands to execute before performing the update. The answers file is reloaded after running migrations in this stage, to let you migrate answer values. after (optional): Commands to execute after performing the update. Migrations will run in the same order as declared here (so you could even run a migration for a higher version before running a migration for a lower version if the higher one is declared before and the update passes through both). They will only run when new version >= declared version > old version . And only when updating (not when copying for the 1st time). If the migrations definition contains Jinja code, it will be rendered with the same context as the rest of the template. Migration processes will receive these environment variables: $STAGE : Either before or after . $VERSION_FROM : Git commit description of the template as it was before updating. $VERSION_TO : Git commit description of the template as it will be after updating. $VERSION_CURRENT : The version detector as you indicated it when describing migration tasks. $VERSION_PEP440_FROM , $VERSION_PEP440_TO , $VERSION_PEP440_CURRENT : Same as the above, but normalized into a standard PEP 440 version string indicator. If your scripts use these environment variables to perform migrations, you probably will prefer to use these variables. Example copier.yml _migrations : - version : v1.0.0 before : - rm ./old-folder after : # {{ _copier_conf.src_path }} points to the path where the template was # cloned, so it can be helpful to run migration scripts stored there. - invoke -r {{ _copier_conf.src_path }} -c migrations migrate $VERSION_CURRENT min_copier_version \u00b6 Format: str CLI flags: N/A Default value: N/A Specifies the minimum required version of Copier to generate a project from this template. The version must be follow the PEP 440 syntax. Upon generating or updating a project, if the installed version of Copier is less than the required one, the generation will be aborted and an error will be shown to the user. Info If Copier detects that there is a major version difference, it will warn you about possible incompatibilities. Remember that a new major release means that some features can be dropped or changed, so it's probably a good idea to ask the template maintainer to update it. Example copier.yml _min_copier_version : \"4.1.0\" pretend \u00b6 Format: bool CLI flags: -n , --pretend Default value: False Run but do not make any changes. Info Not supported in copier.yml . quiet \u00b6 Format: bool CLI flags: -q , --quiet Default value: False Suppress status output. Info Not supported in copier.yml . secret_questions \u00b6 Format: List[str] CLI flags: N/A Default value: [] Question variables to mark as secret questions. This is especially useful when questions are provided in the simplified prompt format . It's equivalent to configuring secret: true in the advanced prompt format . Example copier.yml _secret_questions : - password user : johndoe password : s3cr3t skip_if_exists \u00b6 Format: List[str] CLI flags: -s , --skip Default value: [] Patterns for files/folders that must be skipped if they already exist. Example For example, it can be used if your project generates a password the 1st time and you don't want to override it next times: copier.yml _skip_if_exists : - .secret_password.yml .secret_password.yml.jinja {{ 999999999999999999999999999999999|ans_random|hash('sha512') }} subdirectory \u00b6 Format: str CLI flags: N/A Default value: N/A Subdirectory to use as the template root when generating a project. If not specified, the root of the template is used. This allows you to keep separate the template metadata and the template code. Tip If your template is meant to be applied to other templates (a.k.a. recursive templates), use this option to be able to use updates . Example copier.yml _subdirectory : template Can I have multiple templates in a single repo using this option? The Copier recommendation is: 1 template = 1 Git repository . Why? Unlike almost all other templating engines, Copier supports smart project updates . For that, Copier needs to know in which version it was copied last time, and to which version you are evolving. Copier gets that information from Git tags. Git tags are shared across the whole Git repository. Using a repository to host multiple templates would lead to many corner case situations that we don't want to support. So, in Copier, the subdirectory option is just there to let template owners separate templates metadata from template source code. This way, for example, you can have different dotfiles for you template and for the projects it generates. Example project with different .gitignore files Project layout \ud83d\udcc1 my_copier_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yml # (1) \u251c\u2500\u2500 \ud83d\udcc4 .gitignore # (2) \u2514\u2500\u2500 \ud83d\udcc1 template # (3) \u2514\u2500\u2500 \ud83d\udcc4 .gitignore # (4) Same contents as the example above. Ignore instructions for the template repo. The configured template subdirectory. Ignore instructions for projects generated with the template. However, it is true that the value of this option can itself be templated. This would let you have different templates that all use the same questionary, and the used template would be saved as an answer. It would let the user update safely and change that option in the future. Example With this questions file and this directory structure, the user will be prompted which Python engine to use, and the project will be generated using the subdirectory whose name matches the answer from the user: copier.yaml _subdirectory : \"{{ python_engine }}\" python_engine : type : str choices : - poetry - pipenv Project layout \ud83d\udcc1 my_copier_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yaml # (1) \u251c\u2500\u2500 \ud83d\udcc1 poetry \u2502 \u251c\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja # (2) \u2502 \u2514\u2500\u2500 \ud83d\udcc4 pyproject.toml.jinja \u2514\u2500\u2500 \ud83d\udcc1 pipenv \u2502 \u251c\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja \u2514\u2500\u2500 \ud83d\udcc4 Pipfile.jinja The configuration from the previous example snippet. See the answers file docs to understand. tasks \u00b6 Format: List[str|List[str]] CLI flags: N/A Default value: [] Commands to execute after generating or updating a project from your template. They run ordered, and with the $STAGE=task variable in their environment. Example copier.yml : _tasks : # Strings get executed under system's default shell - \"git init\" - \"rm {{ name_of_the_project }}/README.md\" # Arrays are executed without shell, saving you the work of escaping arguments - [ invoke , \"--search-root={{ _copier_conf.src_path }}\" , after-copy ] # You are able to output the full conf to JSON, to be parsed by your script - [ invoke , end-process , \"--full-conf={{ _copier_conf|to_json }}\" ] # Your script can be run by the same Python environment used to run Copier - [ \"{{ _copier_python }}\" , task.py ] templates_suffix \u00b6 Format: str CLI flags: N/A Default value: .jinja Suffix that instructs which files are to be processed by Jinja as templates. Example copier.yml _templates_suffix : .my-custom-suffix An empty suffix is also valid, and will instruct Copier to copy and render every file , except those that are excluded by default . If an error happens while trying to read a file as a template, it will fallback to a simple copy (it will typically happen for binary files like images). At the contrary, if such an error happens and the templates suffix is not empty, Copier will abort and print an error message. Example copier.yml _templates_suffix : \"\" Warning Copier 5 and older had a different default value: .tmpl . If you wish to keep it, add it to your copier.yml to keep it future-proof. Copier 6 will apply that old default if your min_copier_version is lower than 6, but that will be removed in the future. use_prereleases \u00b6 Format: bool CLI flags: g , --prereleases Default value: False Imagine that the template supports updates and contains these 2 Git tags: v1.0.0 and v2.0.0a1 . Copier will copy by default v1.0.0 unless you add --prereleases . Also, if you run copier update , Copier would ignore the v2.0.0a1 tag unless this flag is enabled. Warning This behavior is new from Copier 5.0.0. Before that release, prereleases were never ignored. Info Not supported in copier.yml . vcs_ref \u00b6 Format: str CLI flags: -r , -vcs-ref Default value: N/A (use latest release) When copying or updating from a Git-versioned template, indicate which template version to copy. This is stored automatically in the answers file, like this: _commit : v1.0.0 Info Not supported in copier.yml . By default, Copier will copy from the last release found in template Git tags, sorted as PEP 440 . Patterns syntax \u00b6 Copier supports matching names against patterns in a gitignore style fashion. This works for the options exclude and skip . This means you can write patterns as you would for any .gitignore file. The full range of the gitignore syntax is supported via pathspec . For example, with the following settings in your copier.yml file would exclude all files ending with txt from being copied to the destination folder, except the file a.txt . _exclude : # match all text files... - \"*.txt\" # .. but not this one: - \"!a.txt\" The .copier-answers.yml file \u00b6 If the destination path exists and a .copier-answers.yml file is present there, it will be used to load the last user's answers to the questions made in the copier.yml file . This makes projects easier to update because when the user is asked, the default answers will be the last ones they used. The file must be called exactly {{ _copier_conf.answers_file }}.jinja (or ended with your chosen suffix ) in your template's root folder) to allow applying multiple templates to the same subproject . The default name will be .copier-answers.yml , but you can define a different default path for this file . The file must have this content: # Changes here will be overwritten by Copier; NEVER EDIT MANUALLY {{ _copier_answers|to_nice_yaml }} Important Did you notice that NEVER EDIT MANUALLY part? It is important . The builtin _copier_answers variable includes all data needed to smooth future updates of this project. This includes (but is not limited to) all JSON-serializable values declared as user questions in the copier.yml file . As you can see, you also have the power to customize what will be logged here. Keys that start with an underscore ( _ ) are specific to Copier. Other keys should match questions in copier.yml . The path to the answers file must be expressed relative to the project root, because: Its value must be available at render time. It is used to update projects, and for that a project must be git-tracked. So, the file must be in the repo anyway. Applying multiple templates to the same subproject \u00b6 Imagine this scenario: You use one framework that has a public template to generate a project. It's available at https://github.com/example-framework/framework-template.git . You have a generic template that you apply to all your projects to use the same pre-commit configuration (formatters, linters, static type checkers...). You have published that in https://gitlab.com/my-stuff/pre-commit-template.git . You have a private template that configures your subproject to run in your internal CI. It's found in git@gitlab.example.com:my-company/ci-template.git . All 3 templates are completely independent: Anybody can generate a project for the specific framework, no matter if they want to use pre-commit or not. You want to share the same pre-commit configurations, no matter if the subproject is for one or another framework. You want to have a centralized CI configuration for all your company projects, no matter their pre-commit configuration or the framework they rely on. Well, don't worry. Copier has you covered. You just need to use a different answers file for each one. All of them contain a {{ _copier_conf.answers_file }}.jinja file as specified above . Then you apply all the templates to the same project: mkdir my-project cd my-project git init # Apply framework template copier -a .copier-answers.main.yml copy https://github.com/example-framework/framework-template.git . git add . git commit -m 'Start project based on framework template' # Apply pre-commit template copier -a .copier-answers.pre-commit.yml copy https://gitlab.com/my-stuff/pre-commit-template.git . git add . pre-commit run -a # Just in case \ud83d\ude09 git commit -am 'Apply pre-commit template' # Apply internal CI template copier -a .copier-answers.ci.yml copy git@gitlab.example.com:my-company/ci-template.git . git add . git commit -m 'Apply internal CI template' Done! After a while, when templates get new releases, updates are handled separately for each template: copier -a .copier-answers.main.yml update copier -a .copier-answers.pre-commit.yml update copier -a .copier-answers.ci.yml update","title":"Configuring a template"},{"location":"configuring/#configuring-a-template","text":"","title":"Configuring a template"},{"location":"configuring/#configuration-sources","text":"It is important that you understand how Copier works. It has 2 kinds of configurations: Settings for Copier itself. This includes things as minimal Copier version required, which subdirectory to render, tasks to run, etc. Answers . This is customized per template. The user answers template questions, and those answers are stored as variables available for the template at rendering time. Copier reads settings from these sources, in this order of priority: Command line or API arguments. The copier.yml file . Settings here always start with an underscore (e.g. _min_copier_version ). Info Some settings are only available as CLI arguments, and some others only as template configurations. Some behave differently depending on where they are defined. Check the docs for each specific setting . Copier obtains answers from these sources, in this order of priority: Command line or API arguments. Asking the user. Notice that Copier will not ask any questions answered in the previous source. Answer from last execution . Default values defined in the copier.yml file .","title":"Configuration sources"},{"location":"configuring/#the-copieryml-file","text":"The copier.yml (or copier.yaml ) file is found in the root of the template, and it is the main entrypoint for managing your template configuration. It will be read and used for two purposes: Prompting the user for information . Applying template settings (excluding files, setting arguments defaults, etc.).","title":"The copier.yml file"},{"location":"configuring/#questions","text":"For each key found, Copier will prompt the user to fill or confirm the values before they become available to the project template. Example This copier.yml file: name_of_the_project : My awesome project number_of_eels : 1234 your_email : \"\" Will result in a questionary similar to: \ud83c\udfa4 name_of_the_project My awesome project \ud83c\udfa4 number_of_eels (int) 1234 \ud83c\udfa4 your_email","title":"Questions"},{"location":"configuring/#advanced-prompt-formatting","text":"Apart from the simplified format, as seen above, Copier supports a more advanced format to ask users for data. To use it, the value must be a dict. Supported keys: type : User input must match this type. Options are: bool , float , int , json , str , yaml (default). help : Additional text to help the user know what's this question for. choices : To restrict possible values. Tip A choice value of null makes it become the same as its key. Warning You are able to use different types for each choice value, but it is not recommended because you can get to some weird scenarios. For example, try to understand this \ud83e\udd74 copier.yml pick_one : type : yaml # If you are mixing types, better be explicit choices : Nothing, thanks : \"null\" # Will be YAML-parsed and converted to null Value is key : null # Value will be converted to \"Value is key\" One and a half : 1.5 \"Yes\" : true Nope : no Some array : \"[yaml, converts, this]\" It's better to stick with a simple type and reason about it later in template code: copier.yml pick_one : type : str choices : Nothing, thanks : \"\" Value is key : null # Becomes \"Value is key\", which is a str One and a half : \"1.5\" \"Yes\" : \"true\" Nope : \"no\" Some array : \"[str, keeps, this, as, a, str]\" default : Leave empty to force the user to answer. Provide a default to save them from typing it if it's quite common. When using choices , the default must be the choice value , not its key , and it must match its type . If values are quite long, you can use YAML anchors . secret : When true , it hides the prompt displaying asterisks ( ***** ) and doesn't save the answer in the answers file placeholder : To provide a visual example for what would be a good value. It is only shown while the answer is empty, so maybe it doesn't make much sense to provide both default and placeholder . Warning Multiline placeholders are not supported currently, due to this upstream bug . multiline : When set to true , it allows multiline input. This is especially useful when type is json or yaml . validator : Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render nothing if the value is valid, and an error message to show to the user otherwise. when : Condition that, if false , skips the question. If it is a boolean, it is used directly, but it's a bit absurd in that case. If it is a string, it is converted to boolean using a parser similar to YAML, but only for boolean values. This is most useful when templated . If a question is skipped, its answer will be: The default value, if you're generating the project for the 1st time. The last answer recorded, if you're updating the project. Example copier.yaml project_creator : type : str project_license : type : str choices : - GPLv3 - Public domain copyright_holder : type : str default : |- {% if project_license == 'Public domain' -%} {#- Nobody owns public projects -#} nobody {%- else -%} {#- By default, project creator is the owner -#} {{ project_creator }} {%- endif %} # Only ask for copyright if project is not in the public domain when : \"{{ project_license != 'Public domain' }}\" Example copier.yml love_copier : type : bool # This makes Copier ask for y/n help : Do you love Copier? default : yes # Without a default, you force the user to answer project_name : type : str # Any value will be treated raw as a string help : An awesome project needs an awesome name. Tell me yours. default : paradox-specifier rocket_launch_password : type : str secret : true # This value will not be logged into .copier-answers.yml placeholder : my top secret password # I'll avoid default and help here, but you can use them too age : type : int validator : \"{% if age <= 0 %}Must be positive{% endif %}\" height : type : float any_json : help : Tell me anything, but format it as a one-line JSON string type : json multiline : true any_yaml : help : Tell me anything, but format it as a one-line YAML string type : yaml # This is the default type, also for short syntax questions multiline : true your_favorite_book : # User will choose one of these and your template will get the value choices : - The Bible - The Hitchhiker's Guide to the Galaxy project_license : # User will see only the dict key and choose one, but you will # get the dict value in your template choices : MIT : &mit_text | Here I can write the full text of the MIT license. This will be a long text, shortened here for example purposes. Apache2 : | Full text of Apache2 license. # When using choices, the default value is the value, **not** the key; # that's why I'm using the YAML anchor declared above to avoid retyping the # whole license default : *mit_text # You can still define the type, to make sure answers that come from --data # CLI argument match the type that your template expects type : str close_to_work : help : Do you live close to your work? # This format works just like the dict one choices : - [ at home , I work at home ] - [ less than 10km , quite close ] - [ more than 10km , not so close ] - [ more than 100km , quite far away ]","title":"Advanced prompt formatting"},{"location":"configuring/#prompt-templating","text":"Most of those options can be templated using Jinja. Keep in mind that the configuration is loaded as YAML , so the contents must be valid YAML and respect Copier's structure . That is why we explicitly wrap some strings in double-quotes in the following examples. Answers provided through interactive prompting will not be rendered with Jinja, so you cannot use Jinja templating in your answers. Example copier.yml # default username : type : str organization : type : str email : type : str # Notice that both `username` and `organization` have been already asked default : \"{{ username }}@{{ organization }}.com\" # help copyright_holder : type : str when : \"{% if organization != 'Public domain' %}true{% endif %}\" help : The person or entity within {{ organization }} that holds copyrights. # type target : type : str choices : - humans - machines user_config : type : \"{% if target == 'humans' %}yaml{% else %}json{% endif %}\" # choices title : type : str help : Your title within {{ organization }} contact : choices : Copyright holder : \"{{ copyright_holder }}\" CEO : Alice Bob CTO : Carl Dave \"{{ title }}\" : \"{{ username }}\" Warning Keep in mind that: You can only template inside the value... ... which must be a string to be templated. Also you won't be able to use variables that aren't yet declared. copier.yml your_age : type : int # Valid double_it : type : int default : \"{{ your_age * 2}}\" # Invalid, the templating occurs outside of the parameter value did_you_ask : type : str { % if your_age % } default : \"yes\" { % else % } placeholder : \"nope\" { % endif % } # Invalid, `a_random_word` wasn't answered yet other_random_word : type : str placeholder : \"Something different to {{ a_random_word }}\" # Invalid, YAML interprets curly braces a_random_word : type : str default : {{ 'hello' }}","title":"Prompt templating"},{"location":"configuring/#include-other-yaml-files","text":"The copier.yml file supports multiple documents. When found, they are merged ( not deeply merged; just merged) and the latest one defined has priority. It also supports using the !include tag to include other configurations from elsewhere. These two features, combined, allow you to reuse common partial sections from your templates. Hint You can use Git submodules to sanely include shared code into templates. Example This would be a valid copier.yml file: --- # Copier will load all these files !include shared-conf/common.*.yml # These 3 lines split the several YAML documents --- # These two documents include common questions for these kind of projects !include common-questions/web_app.yml --- !include common-questions/python-project.yml --- # Here you can specify any settings or questions specific for your template, _skip_if_exists : - .password.txt custom_question : default answer","title":"Include other YAML files"},{"location":"configuring/#conditional-files-and-directories","text":"You can take advantage of the ability to template file and directory names to make them \"conditional\", i.e. to only generate them based on the answers given by a user. For example, you can ask users if they want to use pre-commit : copier.yml use_precommit : type : bool default : false help : Do you want to use pre-commit? And then, you can generate a .pre-commit-config.yaml file only if they answered \"yes\": \ud83d\udcc1 your_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yml \u2514\u2500\u2500 \ud83d\udcc4 { % if use_precommit % } .pre-commit-config.yaml { % endif % } .jinja Important Note that the chosen template suffix must appear outside of the Jinja condition, otherwise the whole file won't be considered a template and will be copied as such in generated projects. You can even use the answers of questions with choices : copier.yml ci : type : str help : What Continuous Integration service do you want to use? choices : GitHub CI : github GitLab CI : gitlab default : github \ud83d\udcc1 your_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yml \u251c\u2500\u2500 \ud83d\udcc1 { % if ci == 'github' % } .github { % endif % } \u2502 \u2514\u2500\u2500 \ud83d\udcc1 workflows \u2502 \u2514\u2500\u2500 \ud83d\udcc4 ci.yml \u2514\u2500\u2500 \ud83d\udcc4 { % if ci == 'gitlab' % } .gitlab-ci.yml { % endif % } .jinja Important Contrary to files, directories must not end with the template suffix . Warning On Windows, double-quotes are not valid characters in file and directory paths. This is why we used single-quotes in the example above.","title":"Conditional files and directories"},{"location":"configuring/#available-settings","text":"Template settings alter how the template is rendered. They come from several sources . Remember that the key must be prefixed with an underscore if you use it in the copier.yml file .","title":"Available settings"},{"location":"configuring/#answers_file","text":"Format: str CLI flags: -a , --answers-file Default value: .copier-answers.yml Path to a file where answers will be recorded by default. The path must be relative to the project root. Tip Remember to add that file to your Git template if you want to support updates . Don't forget to read the docs about the answers file . Example copier.yml _answers_file : .my-custom-answers.yml","title":"answers_file"},{"location":"configuring/#cleanup_on_error","text":"Format: bool CLI flags: -C , --no-cleanup (used to disable this setting; only available in copier copy subcommand) Default value: True When Copier creates the destination path, if there's any failure when rendering the template (either in the rendering process or when running the tasks ), Copier will delete that folder. Copier will never delete the folder if it didn't create it. For this reason, when running copier update , this setting has no effect. Info Not supported in copier.yml .","title":"cleanup_on_error"},{"location":"configuring/#data","text":"Format: dict|List[str=str] CLI flags: -d , --data Default value: N/A Give answers to questions through CLI/API. This cannot be defined in copier.yml , where its equivalent would be just normal questions with default answers. Example Example CLI usage to take all default answers from template, except the user name, which is overridden, and don't ask user anything else: copier -fd 'user_name=Manuel Calavera' copy template destination","title":"data"},{"location":"configuring/#envops","text":"Format: dict CLI flags: N/A Default value: {\"keep_trailing_newline\": true} Configurations for the Jinja environment. Copier uses the Jinja defaults whenever possible. The only exception at the moment is that Copier keeps trailing newlines at the end of a template file. If you want to remove those, either remove them from the template or set keep_trailing_newline to false . See upstream docs to know available options. Warning Copier 5 and older had different, bracket-based defaults. If your template was created for Copier 5, you need to add this configuration to your copier.yaml to keep it working just like before: _envops : autoescape : false block_end_string : \"%]\" block_start_string : \"[%\" comment_end_string : \"#]\" comment_start_string : \"[#\" keep_trailing_newline : true variable_end_string : \"]]\" variable_start_string : \"[[\" By specifying this, your template will be compatible with both Copier 5 and 6. Copier 6 will apply these older defaults if your min_copier_version is lower than 6, but that will be removed in the future.","title":"envops"},{"location":"configuring/#exclude","text":"Format: List[str] CLI flags: -x , --exclude Default value: [\"copier.yaml\", \"copier.yml\", \"~*\", \"*.py[co]\", \"__pycache__\", \".git\", \".DS_Store\", \".svn\"] Patterns for files/folders that must not be copied. The CLI option can be passed several times to add several patterns. Info When you define this parameter in copier.yml , it will replace the default value. In this example, for instance, \"copier.yml\" will not be excluded: Example _exclude : - \"*.bar\" - \".git\" Info When you add this parameter from CLI or API, it will not replace the values defined in copier.yml (or the defaults, if missing). Instead, CLI/API definitions will extend those from copier.yml . Example CLI usage to copy only a single file from the template copier --exclude '*' --exclude '!file-i-want' copy ./template ./destination","title":"exclude"},{"location":"configuring/#force","text":"Format: bool CLI flags: -f , --force Default value: False Overwrite files that already exist, without asking. Also don't ask questions to the user; just use default values obtained from other sources . Info Not supported in copier.yml .","title":"force"},{"location":"configuring/#defaults","text":"Format: bool CLI flags: --defaults Default value: False Use default answers to questions, which might be null if not specified. Info Not supported in copier.yml .","title":"defaults"},{"location":"configuring/#overwrite","text":"Format: bool CLI flags: --overwrite Default value: False Overwrite files that already exist, without asking. obtained from other sources . Info Not supported in copier.yml .","title":"overwrite"},{"location":"configuring/#jinja_extensions","text":"Format: List[str] CLI flags: N/A Default value: [] Additional Jinja2 extensions to load in the Jinja2 environment. Extensions can add filters, global variables and functions, or tags to the environment. The following extensions are always loaded: jinja2_ansible_filters.AnsibleCoreFiltersExtension : this extension adds most of the Ansible filters to the environment. You don't need to tell your template users to install these extensions: Copier depends on them, so they are always installed when Copier is installed. Warning Including an extension allows Copier to execute uncontrolled code, thus making the template potentially more dangerous. Be careful about what extensions you install. Note to template writers You must inform your users that they need to install the extensions alongside Copier, i.e. in the same virtualenv where Copier is installed. For example, if your template uses jinja2_time.TimeExtension , your users must install the jinja2-time Python package. # with pip, in the same virtualenv where Copier is installed pip install jinja2-time # if Copier was installed with pipx pipx inject copier jinja2-time Example copier.yml _jinja_extensions : - jinja_markdown.MarkdownExtension - jinja2_slug.SlugExtension - jinja2_time.TimeExtension Hint Examples of extensions you can use: Native Jinja2 extensions : expression statement , which can be used to alter the Jinja context (answers, filters, etc.) or execute other operations, without outputting anything. loop controls , which adds the break and continue keywords for Jinja loops. debug extension , which can dump the current context thanks to the added {% debug %} tag. From cookiecutter : cookiecutter.extensions.JsonifyExtension : provides a jsonify filter, to format a dictionary as JSON. Note that Copier natively provides a to_nice_json filter that can achieve the same thing. cookiecutter.extensions.RandomStringExtension : provides a random_ascii_string(length, punctuation=False) global function. Note that Copier natively provides the ans_random and hash filters that can be used to achieve the same thing: Example {{ 999999999999999999999999999999999 | ans_random | hash ( 'sha512' ) }} cookiecutter.extensions.SlugifyExtension : provides a slugify filter using python-slugify . copier_templates_extensions.TemplateExtensionLoader : enhances the extension loading mechanism to allow templates writers to put their extensions directly in their templates. It also allows to modify the rendering context (the Jinja variables that you can use in your templates) before rendering templates, see using a context hook . jinja_markdown.MarkdownExtension : provides a markdown tag that will render Markdown to HTML using PyMdown extensions . jinja2_slug.SlugExtension : provides a slug filter using unicode-slugify . jinja2_time.TimeExtension : adds a now tag that provides convenient access to the arrow.now() API. Search for more extensions on GitHub using the jinja2-extension topic , or other Jinja2 topics , or on PyPI using the jinja + extension keywords .","title":"jinja_extensions"},{"location":"configuring/#migrations","text":"Format: List[dict] CLI flags: N/A Default value: [] Migrations are like tasks , but each item in the list is a dict with these keys: version : Indicates the version that the template update has to go through to trigger this migration. It is evaluated using PEP 440 . before (optional): Commands to execute before performing the update. The answers file is reloaded after running migrations in this stage, to let you migrate answer values. after (optional): Commands to execute after performing the update. Migrations will run in the same order as declared here (so you could even run a migration for a higher version before running a migration for a lower version if the higher one is declared before and the update passes through both). They will only run when new version >= declared version > old version . And only when updating (not when copying for the 1st time). If the migrations definition contains Jinja code, it will be rendered with the same context as the rest of the template. Migration processes will receive these environment variables: $STAGE : Either before or after . $VERSION_FROM : Git commit description of the template as it was before updating. $VERSION_TO : Git commit description of the template as it will be after updating. $VERSION_CURRENT : The version detector as you indicated it when describing migration tasks. $VERSION_PEP440_FROM , $VERSION_PEP440_TO , $VERSION_PEP440_CURRENT : Same as the above, but normalized into a standard PEP 440 version string indicator. If your scripts use these environment variables to perform migrations, you probably will prefer to use these variables. Example copier.yml _migrations : - version : v1.0.0 before : - rm ./old-folder after : # {{ _copier_conf.src_path }} points to the path where the template was # cloned, so it can be helpful to run migration scripts stored there. - invoke -r {{ _copier_conf.src_path }} -c migrations migrate $VERSION_CURRENT","title":"migrations"},{"location":"configuring/#min_copier_version","text":"Format: str CLI flags: N/A Default value: N/A Specifies the minimum required version of Copier to generate a project from this template. The version must be follow the PEP 440 syntax. Upon generating or updating a project, if the installed version of Copier is less than the required one, the generation will be aborted and an error will be shown to the user. Info If Copier detects that there is a major version difference, it will warn you about possible incompatibilities. Remember that a new major release means that some features can be dropped or changed, so it's probably a good idea to ask the template maintainer to update it. Example copier.yml _min_copier_version : \"4.1.0\"","title":"min_copier_version"},{"location":"configuring/#pretend","text":"Format: bool CLI flags: -n , --pretend Default value: False Run but do not make any changes. Info Not supported in copier.yml .","title":"pretend"},{"location":"configuring/#quiet","text":"Format: bool CLI flags: -q , --quiet Default value: False Suppress status output. Info Not supported in copier.yml .","title":"quiet"},{"location":"configuring/#secret_questions","text":"Format: List[str] CLI flags: N/A Default value: [] Question variables to mark as secret questions. This is especially useful when questions are provided in the simplified prompt format . It's equivalent to configuring secret: true in the advanced prompt format . Example copier.yml _secret_questions : - password user : johndoe password : s3cr3t","title":"secret_questions"},{"location":"configuring/#skip_if_exists","text":"Format: List[str] CLI flags: -s , --skip Default value: [] Patterns for files/folders that must be skipped if they already exist. Example For example, it can be used if your project generates a password the 1st time and you don't want to override it next times: copier.yml _skip_if_exists : - .secret_password.yml .secret_password.yml.jinja {{ 999999999999999999999999999999999|ans_random|hash('sha512') }}","title":"skip_if_exists"},{"location":"configuring/#subdirectory","text":"Format: str CLI flags: N/A Default value: N/A Subdirectory to use as the template root when generating a project. If not specified, the root of the template is used. This allows you to keep separate the template metadata and the template code. Tip If your template is meant to be applied to other templates (a.k.a. recursive templates), use this option to be able to use updates . Example copier.yml _subdirectory : template Can I have multiple templates in a single repo using this option? The Copier recommendation is: 1 template = 1 Git repository . Why? Unlike almost all other templating engines, Copier supports smart project updates . For that, Copier needs to know in which version it was copied last time, and to which version you are evolving. Copier gets that information from Git tags. Git tags are shared across the whole Git repository. Using a repository to host multiple templates would lead to many corner case situations that we don't want to support. So, in Copier, the subdirectory option is just there to let template owners separate templates metadata from template source code. This way, for example, you can have different dotfiles for you template and for the projects it generates. Example project with different .gitignore files Project layout \ud83d\udcc1 my_copier_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yml # (1) \u251c\u2500\u2500 \ud83d\udcc4 .gitignore # (2) \u2514\u2500\u2500 \ud83d\udcc1 template # (3) \u2514\u2500\u2500 \ud83d\udcc4 .gitignore # (4) Same contents as the example above. Ignore instructions for the template repo. The configured template subdirectory. Ignore instructions for projects generated with the template. However, it is true that the value of this option can itself be templated. This would let you have different templates that all use the same questionary, and the used template would be saved as an answer. It would let the user update safely and change that option in the future. Example With this questions file and this directory structure, the user will be prompted which Python engine to use, and the project will be generated using the subdirectory whose name matches the answer from the user: copier.yaml _subdirectory : \"{{ python_engine }}\" python_engine : type : str choices : - poetry - pipenv Project layout \ud83d\udcc1 my_copier_template \u251c\u2500\u2500 \ud83d\udcc4 copier.yaml # (1) \u251c\u2500\u2500 \ud83d\udcc1 poetry \u2502 \u251c\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja # (2) \u2502 \u2514\u2500\u2500 \ud83d\udcc4 pyproject.toml.jinja \u2514\u2500\u2500 \ud83d\udcc1 pipenv \u2502 \u251c\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja \u2514\u2500\u2500 \ud83d\udcc4 Pipfile.jinja The configuration from the previous example snippet. See the answers file docs to understand.","title":"subdirectory"},{"location":"configuring/#tasks","text":"Format: List[str|List[str]] CLI flags: N/A Default value: [] Commands to execute after generating or updating a project from your template. They run ordered, and with the $STAGE=task variable in their environment. Example copier.yml : _tasks : # Strings get executed under system's default shell - \"git init\" - \"rm {{ name_of_the_project }}/README.md\" # Arrays are executed without shell, saving you the work of escaping arguments - [ invoke , \"--search-root={{ _copier_conf.src_path }}\" , after-copy ] # You are able to output the full conf to JSON, to be parsed by your script - [ invoke , end-process , \"--full-conf={{ _copier_conf|to_json }}\" ] # Your script can be run by the same Python environment used to run Copier - [ \"{{ _copier_python }}\" , task.py ]","title":"tasks"},{"location":"configuring/#templates_suffix","text":"Format: str CLI flags: N/A Default value: .jinja Suffix that instructs which files are to be processed by Jinja as templates. Example copier.yml _templates_suffix : .my-custom-suffix An empty suffix is also valid, and will instruct Copier to copy and render every file , except those that are excluded by default . If an error happens while trying to read a file as a template, it will fallback to a simple copy (it will typically happen for binary files like images). At the contrary, if such an error happens and the templates suffix is not empty, Copier will abort and print an error message. Example copier.yml _templates_suffix : \"\" Warning Copier 5 and older had a different default value: .tmpl . If you wish to keep it, add it to your copier.yml to keep it future-proof. Copier 6 will apply that old default if your min_copier_version is lower than 6, but that will be removed in the future.","title":"templates_suffix"},{"location":"configuring/#use_prereleases","text":"Format: bool CLI flags: g , --prereleases Default value: False Imagine that the template supports updates and contains these 2 Git tags: v1.0.0 and v2.0.0a1 . Copier will copy by default v1.0.0 unless you add --prereleases . Also, if you run copier update , Copier would ignore the v2.0.0a1 tag unless this flag is enabled. Warning This behavior is new from Copier 5.0.0. Before that release, prereleases were never ignored. Info Not supported in copier.yml .","title":"use_prereleases"},{"location":"configuring/#vcs_ref","text":"Format: str CLI flags: -r , -vcs-ref Default value: N/A (use latest release) When copying or updating from a Git-versioned template, indicate which template version to copy. This is stored automatically in the answers file, like this: _commit : v1.0.0 Info Not supported in copier.yml . By default, Copier will copy from the last release found in template Git tags, sorted as PEP 440 .","title":"vcs_ref"},{"location":"configuring/#patterns-syntax","text":"Copier supports matching names against patterns in a gitignore style fashion. This works for the options exclude and skip . This means you can write patterns as you would for any .gitignore file. The full range of the gitignore syntax is supported via pathspec . For example, with the following settings in your copier.yml file would exclude all files ending with txt from being copied to the destination folder, except the file a.txt . _exclude : # match all text files... - \"*.txt\" # .. but not this one: - \"!a.txt\"","title":"Patterns syntax"},{"location":"configuring/#the-copier-answersyml-file","text":"If the destination path exists and a .copier-answers.yml file is present there, it will be used to load the last user's answers to the questions made in the copier.yml file . This makes projects easier to update because when the user is asked, the default answers will be the last ones they used. The file must be called exactly {{ _copier_conf.answers_file }}.jinja (or ended with your chosen suffix ) in your template's root folder) to allow applying multiple templates to the same subproject . The default name will be .copier-answers.yml , but you can define a different default path for this file . The file must have this content: # Changes here will be overwritten by Copier; NEVER EDIT MANUALLY {{ _copier_answers|to_nice_yaml }} Important Did you notice that NEVER EDIT MANUALLY part? It is important . The builtin _copier_answers variable includes all data needed to smooth future updates of this project. This includes (but is not limited to) all JSON-serializable values declared as user questions in the copier.yml file . As you can see, you also have the power to customize what will be logged here. Keys that start with an underscore ( _ ) are specific to Copier. Other keys should match questions in copier.yml . The path to the answers file must be expressed relative to the project root, because: Its value must be available at render time. It is used to update projects, and for that a project must be git-tracked. So, the file must be in the repo anyway.","title":"The .copier-answers.yml file"},{"location":"configuring/#applying-multiple-templates-to-the-same-subproject","text":"Imagine this scenario: You use one framework that has a public template to generate a project. It's available at https://github.com/example-framework/framework-template.git . You have a generic template that you apply to all your projects to use the same pre-commit configuration (formatters, linters, static type checkers...). You have published that in https://gitlab.com/my-stuff/pre-commit-template.git . You have a private template that configures your subproject to run in your internal CI. It's found in git@gitlab.example.com:my-company/ci-template.git . All 3 templates are completely independent: Anybody can generate a project for the specific framework, no matter if they want to use pre-commit or not. You want to share the same pre-commit configurations, no matter if the subproject is for one or another framework. You want to have a centralized CI configuration for all your company projects, no matter their pre-commit configuration or the framework they rely on. Well, don't worry. Copier has you covered. You just need to use a different answers file for each one. All of them contain a {{ _copier_conf.answers_file }}.jinja file as specified above . Then you apply all the templates to the same project: mkdir my-project cd my-project git init # Apply framework template copier -a .copier-answers.main.yml copy https://github.com/example-framework/framework-template.git . git add . git commit -m 'Start project based on framework template' # Apply pre-commit template copier -a .copier-answers.pre-commit.yml copy https://gitlab.com/my-stuff/pre-commit-template.git . git add . pre-commit run -a # Just in case \ud83d\ude09 git commit -am 'Apply pre-commit template' # Apply internal CI template copier -a .copier-answers.ci.yml copy git@gitlab.example.com:my-company/ci-template.git . git add . git commit -m 'Apply internal CI template' Done! After a while, when templates get new releases, updates are handled separately for each template: copier -a .copier-answers.main.yml update copier -a .copier-answers.pre-commit.yml update copier -a .copier-answers.ci.yml update","title":"Applying multiple templates to the same subproject"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Report Bugs \u00b6 Report bugs at https://github.com/copier-org/copier/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"Feature request\" is open to whoever wants to implement it. Write Documentation \u00b6 The project could always use more documentation, whether as part of the official project docs, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/copier-org/copier/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome. :) Discuss \u00b6 Feel free to discuss with our community through our discussions channel . Be polite! Dev Environment Setup \u00b6 We use some tools as part of our development workflow which you'll need to install into your host environment: Poetry v1.2+ for packaging and dependency management Or you can use to start hacking with one click! Get Started! \u00b6 Ready to contribute? Here's how to set up the project for local development. Fork the Copier repo on GitHub. Clone your fork locally: git clone git@github.com:my-user/copier.git cd copier Use Poetry to set up a development environment: # Tell Poetry to create the virtualenv in the project directory poetry config virtualenvs.in-project true --local # Create a virtualenv with all dependencies from pyproject.toml poetry install --with docs # Install development helper tools poetry run pre-commit install -t pre-commit -t commit-msg # Create a new shell with the virtualenv activated poetry shell Create a branch for local development: git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass all tests: poe test poe lint To have multiple Python versions on the same machine for running tox , I recommend using pyenv ( do not confuse it with pipenv ,). Commit your changes and push your branch to GitHub: git add . cz commit # use `git commit` if you prefer, but this helps git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request has code, it should include tests. Check that all checks pass on GitHub CI. Tips \u00b6 To run a subset of tests: poe test tests/the-tests-file.py","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/copier-org/copier/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"Feature request\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"The project could always use more documentation, whether as part of the official project docs, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/copier-org/copier/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome. :)","title":"Submit Feedback"},{"location":"contributing/#discuss","text":"Feel free to discuss with our community through our discussions channel . Be polite!","title":"Discuss"},{"location":"contributing/#dev-environment-setup","text":"We use some tools as part of our development workflow which you'll need to install into your host environment: Poetry v1.2+ for packaging and dependency management Or you can use to start hacking with one click!","title":"Dev Environment Setup"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up the project for local development. Fork the Copier repo on GitHub. Clone your fork locally: git clone git@github.com:my-user/copier.git cd copier Use Poetry to set up a development environment: # Tell Poetry to create the virtualenv in the project directory poetry config virtualenvs.in-project true --local # Create a virtualenv with all dependencies from pyproject.toml poetry install --with docs # Install development helper tools poetry run pre-commit install -t pre-commit -t commit-msg # Create a new shell with the virtualenv activated poetry shell Create a branch for local development: git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass all tests: poe test poe lint To have multiple Python versions on the same machine for running tox , I recommend using pyenv ( do not confuse it with pipenv ,). Commit your changes and push your branch to GitHub: git add . cz commit # use `git commit` if you prefer, but this helps git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request has code, it should include tests. Check that all checks pass on GitHub CI.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"To run a subset of tests: poe test tests/the-tests-file.py","title":"Tips"},{"location":"creating/","text":"Creating a template \u00b6 A template is a directory: usually the root folder of a Git repository. The content of the files inside the project template is copied to the destination without changes, unless they end with .jinja (or your chosen suffix ). In that case, the templating engine will be used to render them. Jinja2 templating is used. Learn more about it by reading Jinja2 documentation . If a YAML file named copier.yml or copier.yaml is found in the root of the project, the user will be prompted to fill in or confirm the default values. Minimal example \u00b6 \ud83d\udcc1 my_copier_template ------------------------ # your template project \u251c\u2500\u2500 \ud83d\udcc4 copier.yml ---------------------------- # your template configuration \u251c\u2500\u2500 \ud83d\udcc1 .git ---------------------------------- # your template is a Git repository \u251c\u2500\u2500 \ud83d\udcc1 {{ project_name }} ---------------------- # a folder with a templated name \u2502 \u2514\u2500\u2500 \ud83d\udcc4 {{ module_name }} .py.jinja ---------- # a file with a templated name \u2514\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja --- # answers are recorded here copier.yml # questions project_name : type : str help : What is your project name? module_name : type : str help : What is your Python module name? {{project_name}}/{{module_name}}.py.jinja print(\"Hello from {{module_name}}!\") {{_copier_conf.answers_file}}.jinja # Changes here will be overwritten by Copier {{ _copier_answers | to_nice_yaml }} Generating a project from this template with super_project and world as answers for the project_name and module_name questions respectively would create in the following directory and files: \ud83d\udcc1 generated_project \u251c\u2500\u2500 \ud83d\udcc1 super_project \u2502 \u2514\u2500\u2500 \ud83d\udcc4 world.py \u2514\u2500\u2500 \ud83d\udcc4 .copier-answers.yml super_project/world.py print ( \"Hello from world!\" ) .copier-answers.yml # Changes here will be overwritten by Copier _commit : 0.1.0 _src_path : gh:your_account/your_template project_name : super_project module_name : world Copier allows much more advanced templating: see the next chapter, configuring a template , to see all the configurations options and their usage. Template helpers \u00b6 In addition to all the features Jinja supports , Copier includes: All functions and filters from jinja2-ansible-filters . This includes the to_nice_yaml filter, which is used extensively in our context. _copier_answers includes the current answers dict, but slightly modified to make it suitable to autoupdate your project safely : It doesn't contain secret answers. It doesn't contain any data that is not easy to render to JSON or YAML. It contains special keys like _commit and _src_path , indicating how the last template update was done. _copier_conf includes a representation of the current Copier Worker object, also slightly modified: It only contains JSON-serializable data. You can serialize it with {{ _copier_conf|to_json }} . \u26a0\ufe0f It contains secret answers inside its .data key. Modifying it doesn't alter the current rendering configuration. It contains the current commit hash from the template in {{ _copier_conf.vcs_ref_hash }} .","title":"Creating a template"},{"location":"creating/#creating-a-template","text":"A template is a directory: usually the root folder of a Git repository. The content of the files inside the project template is copied to the destination without changes, unless they end with .jinja (or your chosen suffix ). In that case, the templating engine will be used to render them. Jinja2 templating is used. Learn more about it by reading Jinja2 documentation . If a YAML file named copier.yml or copier.yaml is found in the root of the project, the user will be prompted to fill in or confirm the default values.","title":"Creating a template"},{"location":"creating/#minimal-example","text":"\ud83d\udcc1 my_copier_template ------------------------ # your template project \u251c\u2500\u2500 \ud83d\udcc4 copier.yml ---------------------------- # your template configuration \u251c\u2500\u2500 \ud83d\udcc1 .git ---------------------------------- # your template is a Git repository \u251c\u2500\u2500 \ud83d\udcc1 {{ project_name }} ---------------------- # a folder with a templated name \u2502 \u2514\u2500\u2500 \ud83d\udcc4 {{ module_name }} .py.jinja ---------- # a file with a templated name \u2514\u2500\u2500 \ud83d\udcc4 {{ _copier_conf.answers_file }} .jinja --- # answers are recorded here copier.yml # questions project_name : type : str help : What is your project name? module_name : type : str help : What is your Python module name? {{project_name}}/{{module_name}}.py.jinja print(\"Hello from {{module_name}}!\") {{_copier_conf.answers_file}}.jinja # Changes here will be overwritten by Copier {{ _copier_answers | to_nice_yaml }} Generating a project from this template with super_project and world as answers for the project_name and module_name questions respectively would create in the following directory and files: \ud83d\udcc1 generated_project \u251c\u2500\u2500 \ud83d\udcc1 super_project \u2502 \u2514\u2500\u2500 \ud83d\udcc4 world.py \u2514\u2500\u2500 \ud83d\udcc4 .copier-answers.yml super_project/world.py print ( \"Hello from world!\" ) .copier-answers.yml # Changes here will be overwritten by Copier _commit : 0.1.0 _src_path : gh:your_account/your_template project_name : super_project module_name : world Copier allows much more advanced templating: see the next chapter, configuring a template , to see all the configurations options and their usage.","title":"Minimal example"},{"location":"creating/#template-helpers","text":"In addition to all the features Jinja supports , Copier includes: All functions and filters from jinja2-ansible-filters . This includes the to_nice_yaml filter, which is used extensively in our context. _copier_answers includes the current answers dict, but slightly modified to make it suitable to autoupdate your project safely : It doesn't contain secret answers. It doesn't contain any data that is not easy to render to JSON or YAML. It contains special keys like _commit and _src_path , indicating how the last template update was done. _copier_conf includes a representation of the current Copier Worker object, also slightly modified: It only contains JSON-serializable data. You can serialize it with {{ _copier_conf|to_json }} . \u26a0\ufe0f It contains secret answers inside its .data key. Modifying it doesn't alter the current rendering configuration. It contains the current commit hash from the template in {{ _copier_conf.vcs_ref_hash }} .","title":"Template helpers"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 How can I alter the context before rendering the project? \u00b6 Similar questions: How can I add/remove variables to/from the rendering context? How to infer context variables based on the users answers, without prompting users? Answer: Use the ContextHook extension . The ContextHook extension lets you modify the context used to render templates, so that you can add, change or remove variables. In order for Copier to be able to load and use the extension when generating a project, it must be installed alongside Copier itself. More details in the jinja_extensions docs . You can then configure your Jinja extensions in Copier's configuration file: copier.yaml _jinja_extensions : - copier_templates_extensions.TemplateExtensionLoader - extensions/context.py:ContextUpdater Following this example, you are supposed to provide a context.py file in the extensions folder at the root of your template to modify the context. If for example your copier.yaml contains a multiple-choice variable like this: copier.yaml flavor : type : str choices : - docker - instances - kubernetes - none The context.py file contains your context hook which could look like: extensions/context.py from copier_templates_extensions import ContextHook class ContextUpdater ( ContextHook ): def hook ( self , context ): flavor = context [ \"flavor\" ] # user's answer to the \"flavor\" question return { \"isDocker\" : flavor == \"docker\" \"isK8s\" : flavor == \"kubernetes\" \"isInstances\" : flavor == \"instances\" \"isLite\" : flavor == \"none\" \"isNotDocker\" : flavor != \"docker\" \"isNotK8s\" : flavor != \"kubernetes\" \"isNotInstances\" : flavor != \"instances\" \"isNotLite\" : flavor != \"none\" \"hasContainers\" : flavor in { \"docker\" , \"kubernetes\" } } Before rendering each templated file/folder, the context will be updated with this new context object that you return from the hook. If you wish to update the context in-place rather than update it, set the update class attribute to false: extensions/context.py from copier_templates_extensions import ContextHook class ContextUpdater ( ContextHook ): update = False def hook ( self , context ): flavor = context [ \"flavor\" ] # user's answer to the \"flavor\" question context [ \"isDocker\" ] = flavor == \"docker\" context [ \"isK8s\" ] = flavor == \"kubernetes\" context [ \"isInstances\" ] = flavor == \"instances\" context [ \"isLite\" ] = flavor == \"none\" context [ \"isNotDocker\" ] = flavor != \"docker\" context [ \"isNotK8s\" ] = flavor != \"kubernetes\" context [ \"isNotInstances\" ] = flavor != \"instances\" context [ \"isNotLite\" ] = flavor != \"none\" context [ \"hasContainers\" ] = context [ \"isDocker\" ] or context [ \"isK8s\" ] # you can now actually remove items from the context del context [ \"flavor\" ] Now you can use these added variables in your Jinja templates, and in files and folders names!","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#how-can-i-alter-the-context-before-rendering-the-project","text":"Similar questions: How can I add/remove variables to/from the rendering context? How to infer context variables based on the users answers, without prompting users? Answer: Use the ContextHook extension . The ContextHook extension lets you modify the context used to render templates, so that you can add, change or remove variables. In order for Copier to be able to load and use the extension when generating a project, it must be installed alongside Copier itself. More details in the jinja_extensions docs . You can then configure your Jinja extensions in Copier's configuration file: copier.yaml _jinja_extensions : - copier_templates_extensions.TemplateExtensionLoader - extensions/context.py:ContextUpdater Following this example, you are supposed to provide a context.py file in the extensions folder at the root of your template to modify the context. If for example your copier.yaml contains a multiple-choice variable like this: copier.yaml flavor : type : str choices : - docker - instances - kubernetes - none The context.py file contains your context hook which could look like: extensions/context.py from copier_templates_extensions import ContextHook class ContextUpdater ( ContextHook ): def hook ( self , context ): flavor = context [ \"flavor\" ] # user's answer to the \"flavor\" question return { \"isDocker\" : flavor == \"docker\" \"isK8s\" : flavor == \"kubernetes\" \"isInstances\" : flavor == \"instances\" \"isLite\" : flavor == \"none\" \"isNotDocker\" : flavor != \"docker\" \"isNotK8s\" : flavor != \"kubernetes\" \"isNotInstances\" : flavor != \"instances\" \"isNotLite\" : flavor != \"none\" \"hasContainers\" : flavor in { \"docker\" , \"kubernetes\" } } Before rendering each templated file/folder, the context will be updated with this new context object that you return from the hook. If you wish to update the context in-place rather than update it, set the update class attribute to false: extensions/context.py from copier_templates_extensions import ContextHook class ContextUpdater ( ContextHook ): update = False def hook ( self , context ): flavor = context [ \"flavor\" ] # user's answer to the \"flavor\" question context [ \"isDocker\" ] = flavor == \"docker\" context [ \"isK8s\" ] = flavor == \"kubernetes\" context [ \"isInstances\" ] = flavor == \"instances\" context [ \"isLite\" ] = flavor == \"none\" context [ \"isNotDocker\" ] = flavor != \"docker\" context [ \"isNotK8s\" ] = flavor != \"kubernetes\" context [ \"isNotInstances\" ] = flavor != \"instances\" context [ \"isNotLite\" ] = flavor != \"none\" context [ \"hasContainers\" ] = context [ \"isDocker\" ] or context [ \"isK8s\" ] # you can now actually remove items from the context del context [ \"flavor\" ] Now you can use these added variables in your Jinja templates, and in files and folders names!","title":"How can I alter the context before rendering the project?"},{"location":"generating/","text":"Generating a project \u00b6 Warning Generate projects only from trusted templates as their tasks run with the same level of access as your user. As seen in the quick usage section, you can generate a project from a template using the copier command-line tool: copier path/to/project/template path/to/destination Or within Python code: copier . run_auto ( \"path/to/project/template\" , \"path/to/destination\" ) The \"template\" parameter can be a local path, an URL, or a shortcut URL: GitHub: gh:namespace/project GitLab: gl:namespace/project Use the --data command-line argument or the data parameter of the copier.run_auto() function to pass whatever extra context you want to be available in the templates. The arguments can be any valid Python value, even a function. Use the --vcs-ref command-line argument to checkout a particular Git ref before generating the project. All the available options are described with the --help-all option. Templates versions \u00b6 By default, Copier will copy from the last release found in template Git tags, sorted as PEP 440 , regardless of whether the template is from a URL or a local clone of a Git repository. The exception to this is if you use a local clone of a template repository that has had any modifications made, in this case Copier will use this modified working copy of the template to aid development of new template features. If you would like to override the version of template being installed, the --vcs-ref argument can be used to specify a branch, tag or other reference to use. For example to use the latest master branch from a public repository: copier --vcs-ref master https://github.com/foo/copier-template.git ./path/to/destination Or to work from the current checked out revision of a local template: copier --vcs-ref HEAD path/to/project/template path/to/destination Tip If there are uncommited changes in the local template, they will be included in the HEAD ref Regenerating a project \u00b6 When you execute copier copy $template $project again over a preexisting $project , Copier will just \"recopy\" it, ignoring previous history. Warning This is not the recommended approach for updating a project , where you usually want Copier to respect the project evolution wherever it doesn't conflict with the template evolution.","title":"Generating a project"},{"location":"generating/#generating-a-project","text":"Warning Generate projects only from trusted templates as their tasks run with the same level of access as your user. As seen in the quick usage section, you can generate a project from a template using the copier command-line tool: copier path/to/project/template path/to/destination Or within Python code: copier . run_auto ( \"path/to/project/template\" , \"path/to/destination\" ) The \"template\" parameter can be a local path, an URL, or a shortcut URL: GitHub: gh:namespace/project GitLab: gl:namespace/project Use the --data command-line argument or the data parameter of the copier.run_auto() function to pass whatever extra context you want to be available in the templates. The arguments can be any valid Python value, even a function. Use the --vcs-ref command-line argument to checkout a particular Git ref before generating the project. All the available options are described with the --help-all option.","title":"Generating a project"},{"location":"generating/#templates-versions","text":"By default, Copier will copy from the last release found in template Git tags, sorted as PEP 440 , regardless of whether the template is from a URL or a local clone of a Git repository. The exception to this is if you use a local clone of a template repository that has had any modifications made, in this case Copier will use this modified working copy of the template to aid development of new template features. If you would like to override the version of template being installed, the --vcs-ref argument can be used to specify a branch, tag or other reference to use. For example to use the latest master branch from a public repository: copier --vcs-ref master https://github.com/foo/copier-template.git ./path/to/destination Or to work from the current checked out revision of a local template: copier --vcs-ref HEAD path/to/project/template path/to/destination Tip If there are uncommited changes in the local template, they will be included in the HEAD ref","title":"Templates versions"},{"location":"generating/#regenerating-a-project","text":"When you execute copier copy $template $project again over a preexisting $project , Copier will just \"recopy\" it, ignoring previous history. Warning This is not the recommended approach for updating a project , where you usually want Copier to respect the project evolution wherever it doesn't conflict with the template evolution.","title":"Regenerating a project"},{"location":"updating/","text":"Updating a project \u00b6 The best way to update a project from its template is when all of these conditions are true: The template includes a valid .copier-answers.yml file . The template is versioned with Git (with tags). The destination folder is versioned with Git. If that's your case, then just enter the destination folder, make sure git status shows it clean, and run: copier update This will read all available Git tags, will compare them using PEP 440 , and will check out the latest one before updating. To update to the latest commit, add --vcs-ref=HEAD . You can use any other Git ref you want. When updating, Copier will do its best to respect your project evolution by using the answers you provided when copied last time. However, sometimes it's impossible for Copier to know what to do with a diff code hunk. In those cases, you will find *.rej files that contain the unresolved diffs. You should review those manually before committing. You probably don't want *.rej files in your Git history, but if you add them to .gitignore , some important changes could pass unnoticed to you. That's why the recommended way to deal with them is to not add them to add a pre-commit (or equivalent) hook that forbids them, just like this: .pre-commit-config.yaml repos : - repo : local hooks : - id : forbidden-files name : forbidden files entry : found Copier update rejection files; review them and remove them language : fail files : \"\\\\.rej$\" Never change the answers file manually \u00b6 Important Never update .copier-answers.yml manually. This will trick Copier, making it believe that those modified answers produced the current subproject, while it was produced by a different answers set. This will produce unpredictable behavior of the smart diff algorithm used for updates, which may work under certain circumstances, but not always. This is an unsupported way to update . Please do not open issues if you updated this way. The correct process to update a subproject is: Run copier update . Answer to the questions. They'll default to your answers on your last update. If you want to just reuse all previous answers: copier --force update If you want to change just one question, and leave all others untouched, and don't want to go through the whole questionary again: copier --force --data updated_question = \"my new answer\" update How the update works \u00b6 To understand how the updating process works, take a look at this diagram: graph TD %% nodes ---------------------------------------------------------- template_repo(\"template repository\") template_current(\"/tmp/template<br>(current tag)\") template_latest(\"/tmp/template<br>(latest tag)\") project_regen(\"/tmp/project<br>(fresh, current version)\") project_current(\"current project\") project_half(\"half migrated<br>project\") project_updated(\"updated project\") project_applied(\"updated project<br>(diff applied)\") project_full(\"fully updated<br>and migrated project\") update[\"update current<br>project in-place<br>(prompting)<br>+ run tasks again\"] compare[\"compare to get diff\"] apply[\"apply diff\"] diff(\"diff\") %% edges ---------------------------------------------------------- template_repo --> |git clone| template_current template_repo --> |git clone| template_latest template_current --> |generate and run tasks| project_regen project_current --> compare project_current --> |apply pre-migrations| project_half project_regen --> compare project_half --> update template_latest --> update update --> project_updated compare --> diff diff --> apply project_updated --> apply apply --> project_applied project_applied --> |apply post-migrations| project_full %% style ---------------------------------------------------------- classDef blackborder stroke:#000; class compare,update,apply blackborder; As you can see here, copier does several things: it regenerates a fresh project from the current template version then it compares both version, to get the diff from \"fresh project\" to \"current project\" now it applies pre-migrations to your project, and updates the current project with the latest template changes (asking confirmation) finally, it re-applies the previously obtained diff, and then run the post-migrations Important The diff obtained by comparing the fresh, regenerated project to your current project can cancel the modifications applied by the update from the latest template version. During the process, copier will ask you confirmation to overwrite or skip modifications, but in the end, it is possible that nothing has changed (except for the version in .copier-answers.yml of course). This is not a bug: although it can be quite surprising, this behavior is correct. Migration across Copier major versions \u00b6 When there's a new major release of Copier (for example from Copier 5.x to 6.x), there are chances that there's something that changed. Maybe your template will not work as it did before. As explained above , Copier needs to make a copy of the template in its old state with its old answers so it can actually produce a diff with the new state and answers and apply the smart update to the project. However, how can I be sure that Copier will produce the same \"old state\" if I copied the template with an older Copier major release? . Good question. We will do our best to respect older behaviors for at least one extra major release cycle, but the simpler answer is that you can't be sure of that. How to overcome that situation? You can write good migrations . Then you can test them on your template's CI on a matrix against several Copier versions. Or you can just recopy the project when you update to a newer Copier major release.","title":"Updating a project"},{"location":"updating/#updating-a-project","text":"The best way to update a project from its template is when all of these conditions are true: The template includes a valid .copier-answers.yml file . The template is versioned with Git (with tags). The destination folder is versioned with Git. If that's your case, then just enter the destination folder, make sure git status shows it clean, and run: copier update This will read all available Git tags, will compare them using PEP 440 , and will check out the latest one before updating. To update to the latest commit, add --vcs-ref=HEAD . You can use any other Git ref you want. When updating, Copier will do its best to respect your project evolution by using the answers you provided when copied last time. However, sometimes it's impossible for Copier to know what to do with a diff code hunk. In those cases, you will find *.rej files that contain the unresolved diffs. You should review those manually before committing. You probably don't want *.rej files in your Git history, but if you add them to .gitignore , some important changes could pass unnoticed to you. That's why the recommended way to deal with them is to not add them to add a pre-commit (or equivalent) hook that forbids them, just like this: .pre-commit-config.yaml repos : - repo : local hooks : - id : forbidden-files name : forbidden files entry : found Copier update rejection files; review them and remove them language : fail files : \"\\\\.rej$\"","title":"Updating a project"},{"location":"updating/#never-change-the-answers-file-manually","text":"Important Never update .copier-answers.yml manually. This will trick Copier, making it believe that those modified answers produced the current subproject, while it was produced by a different answers set. This will produce unpredictable behavior of the smart diff algorithm used for updates, which may work under certain circumstances, but not always. This is an unsupported way to update . Please do not open issues if you updated this way. The correct process to update a subproject is: Run copier update . Answer to the questions. They'll default to your answers on your last update. If you want to just reuse all previous answers: copier --force update If you want to change just one question, and leave all others untouched, and don't want to go through the whole questionary again: copier --force --data updated_question = \"my new answer\" update","title":"Never change the answers file manually"},{"location":"updating/#how-the-update-works","text":"To understand how the updating process works, take a look at this diagram: graph TD %% nodes ---------------------------------------------------------- template_repo(\"template repository\") template_current(\"/tmp/template<br>(current tag)\") template_latest(\"/tmp/template<br>(latest tag)\") project_regen(\"/tmp/project<br>(fresh, current version)\") project_current(\"current project\") project_half(\"half migrated<br>project\") project_updated(\"updated project\") project_applied(\"updated project<br>(diff applied)\") project_full(\"fully updated<br>and migrated project\") update[\"update current<br>project in-place<br>(prompting)<br>+ run tasks again\"] compare[\"compare to get diff\"] apply[\"apply diff\"] diff(\"diff\") %% edges ---------------------------------------------------------- template_repo --> |git clone| template_current template_repo --> |git clone| template_latest template_current --> |generate and run tasks| project_regen project_current --> compare project_current --> |apply pre-migrations| project_half project_regen --> compare project_half --> update template_latest --> update update --> project_updated compare --> diff diff --> apply project_updated --> apply apply --> project_applied project_applied --> |apply post-migrations| project_full %% style ---------------------------------------------------------- classDef blackborder stroke:#000; class compare,update,apply blackborder; As you can see here, copier does several things: it regenerates a fresh project from the current template version then it compares both version, to get the diff from \"fresh project\" to \"current project\" now it applies pre-migrations to your project, and updates the current project with the latest template changes (asking confirmation) finally, it re-applies the previously obtained diff, and then run the post-migrations Important The diff obtained by comparing the fresh, regenerated project to your current project can cancel the modifications applied by the update from the latest template version. During the process, copier will ask you confirmation to overwrite or skip modifications, but in the end, it is possible that nothing has changed (except for the version in .copier-answers.yml of course). This is not a bug: although it can be quite surprising, this behavior is correct.","title":"How the update works"},{"location":"updating/#migration-across-copier-major-versions","text":"When there's a new major release of Copier (for example from Copier 5.x to 6.x), there are chances that there's something that changed. Maybe your template will not work as it did before. As explained above , Copier needs to make a copy of the template in its old state with its old answers so it can actually produce a diff with the new state and answers and apply the smart update to the project. However, how can I be sure that Copier will produce the same \"old state\" if I copied the template with an older Copier major release? . Good question. We will do our best to respect older behaviors for at least one extra major release cycle, but the simpler answer is that you can't be sure of that. How to overcome that situation? You can write good migrations . Then you can test them on your template's CI on a matrix against several Copier versions. Or you can just recopy the project when you update to a newer Copier major release.","title":"Migration across Copier major versions"},{"location":"reference/cli/","text":"Command line entrypoint. This module declares the Copier CLI applications. Basically, there are 3 different commands you can run: copier , the main app, which is a shortcut for the copy and update subapps. If the destination project is found and has an answers file with enough information, it will become a shortcut for copier update . Otherwise it will be a shortcut for copier copy . Example # Copy a new project copier gh:copier-org/autopretty my-project # Update it cd my-project copier copier copy , used to bootstrap a new project from a template. Example copier copy gh:copier-org/autopretty my-project copier update to update a preexisting project to a newer version of its template. Example copier update Below are the docs of each one of those. CopierApp \u00b6 Bases: cli . Application The Copier CLI application. Attributes: Name Type Description answers_file cli . SwitchAttr Set answers_file option. exclude cli . SwitchAttr Set exclude option. vcs_ref cli . SwitchAttr Set vcs_ref option. pretend cli . Flag Set pretend option. force cli . Flag Set force option. defaults cli . Flag Set defaults option. overwrite cli . Flag Set overwrite option. skip cli . Flag Set skip_if_exists option. prereleases cli . Flag Set use_prereleases option. quiet cli . Flag Set quiet option. Source code in copier/cli.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class CopierApp ( cli . Application ): \"\"\"The Copier CLI application. Attributes: answers_file: Set [answers_file][] option. exclude: Set [exclude][] option. vcs_ref: Set [vcs_ref][] option. pretend: Set [pretend][] option. force: Set [force][] option. defaults: Set [defaults][] option. overwrite: Set [overwrite][] option. skip: Set [skip_if_exists][] option. prereleases: Set [use_prereleases][] option. quiet: Set [quiet][] option. \"\"\" DESCRIPTION = \"Create a new project from a template.\" DESCRIPTION_MORE = ( dedent ( \"\"\"\\ Docs in https://copier.readthedocs.io/ \"\"\" ) + ( colors . yellow | dedent ( \"\"\"\\ WARNING! Use only trusted project templates, as they might execute code with the same level of access as your user.\\n \"\"\" ) ) ) USAGE = dedent ( \"\"\"\\ copier [MAIN_SWITCHES] [copy] [SUB_SWITCHES] template_src destination_path copier [MAIN_SWITCHES] [update] [SUB_SWITCHES] [destination_path] \"\"\" ) VERSION = copier_version () CALL_MAIN_IF_NESTED_COMMAND = False data : AnyByStrDict = {} answers_file : cli . SwitchAttr = cli . SwitchAttr ( [ \"-a\" , \"--answers-file\" ], default = None , help = ( \"Update using this path (relative to `destination_path`) \" \"to find the answers file\" ), ) exclude : cli . SwitchAttr = cli . SwitchAttr ( [ \"-x\" , \"--exclude\" ], str , list = True , help = ( \"A name or shell-style pattern matching files or folders \" \"that must not be copied\" ), ) vcs_ref : cli . SwitchAttr = cli . SwitchAttr ( [ \"-r\" , \"--vcs-ref\" ], str , help = ( \"Git reference to checkout in `template_src`. \" \"If you do not specify it, it will try to checkout the latest git tag, \" \"as sorted using the PEP 440 algorithm. If you want to checkout always \" \"the latest version, use `--vcs-ref=HEAD`.\" ), ) pretend : cli . Flag = cli . Flag ( [ \"-n\" , \"--pretend\" ], help = \"Run but do not make any changes\" ) force : cli . Flag = cli . Flag ( [ \"-f\" , \"--force\" ], help = \"Same as `--defaults --overwrite`.\" , ) defaults : cli . Flag = cli . Flag ( [ \"-l\" , \"--defaults\" ], help = \"Use default answers to questions, which might be null if not specified.\" , ) overwrite : cli . Flag = cli . Flag ( [ \"-w\" , \"--overwrite\" ], help = \"Overwrite files that already exist, without asking.\" , ) skip : cli . Flag = cli . SwitchAttr ( [ \"-s\" , \"--skip\" ], str , list = True , help = \"Skip specified files if they exist already\" , ) quiet : cli . Flag = cli . Flag ([ \"-q\" , \"--quiet\" ], help = \"Suppress status output\" ) prereleases : cli . Flag = cli . Flag ( [ \"-g\" , \"--prereleases\" ], help = \"Use prereleases to compare template VCS tags.\" , ) @cli . switch ( [ \"-d\" , \"--data\" ], str , \"VARIABLE=VALUE\" , list = True , help = \"Make VARIABLE available as VALUE when rendering the template\" , ) def data_switch ( self , values : StrSeq ) -> None : \"\"\"Update [data][] with provided values. Arguments: values: The list of values to apply. Each value in the list is of the following form: `NAME=VALUE`. \"\"\" for arg in values : key , value = arg . split ( \"=\" , 1 ) value = yaml . safe_load ( value ) self . data [ key ] = value def _worker ( self , src_path : OptStr = None , dst_path : str = \".\" , ** kwargs ) -> Worker : \"\"\" Run Copier's internal API using CLI switches. Arguments: src_path: The source path of the template to generate the project from. dst_path: The path to generate the project to. **kwargs: Arguments passed to [Worker][copier.main.Worker]. \"\"\" return Worker ( data = self . data , dst_path = Path ( dst_path ), answers_file = self . answers_file , exclude = self . exclude , defaults = self . force or self . defaults , overwrite = self . force or self . overwrite , pretend = self . pretend , quiet = self . quiet , src_path = src_path , vcs_ref = self . vcs_ref , use_prereleases = self . prereleases , ** kwargs , ) @handle_exceptions def main ( self , * args : str ) -> int : \"\"\"Copier CLI app shortcuts. This method redirects abstract CLI calls (those that don't specify `copy` or `update`) to [CopierCopySubApp.main][copier.cli.CopierCopySubApp.main] or [CopierUpdateSubApp.main][copier.cli.CopierUpdateSubApp.main] automatically. Examples: - `copier from to` \u2192 `copier copy from to` - `copier from` \u2192 `copier update from` - `copier` \u2192 `copier update .` \"\"\" # Redirect to subcommand if supplied if args and args [ 0 ] in self . _subcommands : self . nested_command = ( self . _subcommands [ args [ 0 ]] . subapplication , [ \"copier %s \" % args [ 0 ]] + list ( args [ 1 :]), ) # If using 0 or 1 args, you want to update elif len ( args ) in { 0 , 1 }: self . nested_command = ( self . _subcommands [ \"update\" ] . subapplication , [ \"copier update\" ] + list ( args ), ) # If using 2 args, you want to copy elif len ( args ) == 2 : self . nested_command = ( self . _subcommands [ \"copy\" ] . subapplication , [ \"copier copy\" ] + list ( args ), ) # If using more args, you're wrong else : self . help () raise UserMessageError ( \"Unsupported arguments\" ) return 0 data_switch ( values ) \u00b6 Update data with provided values. Parameters: Name Type Description Default values StrSeq The list of values to apply. Each value in the list is of the following form: NAME=VALUE . required Source code in copier/cli.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 @cli . switch ( [ \"-d\" , \"--data\" ], str , \"VARIABLE=VALUE\" , list = True , help = \"Make VARIABLE available as VALUE when rendering the template\" , ) def data_switch ( self , values : StrSeq ) -> None : \"\"\"Update [data][] with provided values. Arguments: values: The list of values to apply. Each value in the list is of the following form: `NAME=VALUE`. \"\"\" for arg in values : key , value = arg . split ( \"=\" , 1 ) value = yaml . safe_load ( value ) self . data [ key ] = value main ( * args ) \u00b6 Copier CLI app shortcuts. This method redirects abstract CLI calls (those that don't specify copy or update ) to CopierCopySubApp.main or CopierUpdateSubApp.main automatically. Examples: copier from to \u2192 copier copy from to copier from \u2192 copier update from copier \u2192 copier update . Source code in copier/cli.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 @handle_exceptions def main ( self , * args : str ) -> int : \"\"\"Copier CLI app shortcuts. This method redirects abstract CLI calls (those that don't specify `copy` or `update`) to [CopierCopySubApp.main][copier.cli.CopierCopySubApp.main] or [CopierUpdateSubApp.main][copier.cli.CopierUpdateSubApp.main] automatically. Examples: - `copier from to` \u2192 `copier copy from to` - `copier from` \u2192 `copier update from` - `copier` \u2192 `copier update .` \"\"\" # Redirect to subcommand if supplied if args and args [ 0 ] in self . _subcommands : self . nested_command = ( self . _subcommands [ args [ 0 ]] . subapplication , [ \"copier %s \" % args [ 0 ]] + list ( args [ 1 :]), ) # If using 0 or 1 args, you want to update elif len ( args ) in { 0 , 1 }: self . nested_command = ( self . _subcommands [ \"update\" ] . subapplication , [ \"copier update\" ] + list ( args ), ) # If using 2 args, you want to copy elif len ( args ) == 2 : self . nested_command = ( self . _subcommands [ \"copy\" ] . subapplication , [ \"copier copy\" ] + list ( args ), ) # If using more args, you're wrong else : self . help () raise UserMessageError ( \"Unsupported arguments\" ) return 0 CopierCopySubApp \u00b6 Bases: cli . Application The copier copy subcommand. Use this subcommand to bootstrap a new subproject from a template, or to override a preexisting subproject ignoring its history diff. Attributes: Name Type Description cleanup_on_error cli . Flag Set cleanup_on_error option. Source code in copier/cli.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 @CopierApp . subcommand ( \"copy\" ) class CopierCopySubApp ( cli . Application ): \"\"\"The `copier copy` subcommand. Use this subcommand to bootstrap a new subproject from a template, or to override a preexisting subproject ignoring its history diff. Attributes: cleanup_on_error: Set [cleanup_on_error][] option. \"\"\" DESCRIPTION = \"Copy from a template source to a destination.\" cleanup_on_error : cli . Flag = cli . Flag ( [ \"-C\" , \"--no-cleanup\" ], default = True , help = \"On error, do not delete destination if it was created by Copier.\" , ) @handle_exceptions def main ( self , template_src : str , destination_path : str ) -> int : \"\"\"Call [run_copy][copier.main.Worker.run_copy]. Params: template_src: Indicate where to get the template from. This can be a git URL or a local path. destination_path: Where to generate the new subproject. It must not exist or be empty. \"\"\" self . parent . _worker ( template_src , destination_path , cleanup_on_error = self . cleanup_on_error , ) . run_copy () return 0 main ( template_src , destination_path ) \u00b6 Call run_copy . Parameters: Name Type Description Default template_src str Indicate where to get the template from. This can be a git URL or a local path. required destination_path str Where to generate the new subproject. It must not exist or be empty. required Source code in copier/cli.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 @handle_exceptions def main ( self , template_src : str , destination_path : str ) -> int : \"\"\"Call [run_copy][copier.main.Worker.run_copy]. Params: template_src: Indicate where to get the template from. This can be a git URL or a local path. destination_path: Where to generate the new subproject. It must not exist or be empty. \"\"\" self . parent . _worker ( template_src , destination_path , cleanup_on_error = self . cleanup_on_error , ) . run_copy () return 0 CopierUpdateSubApp \u00b6 Bases: cli . Application The copier update subcommand. Use this subcommand to update an existing subproject from a template that supports updates. Source code in copier/cli.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @CopierApp . subcommand ( \"update\" ) class CopierUpdateSubApp ( cli . Application ): \"\"\"The `copier update` subcommand. Use this subcommand to update an existing subproject from a template that supports updates. \"\"\" DESCRIPTION = \"Update a copy from its original template\" DESCRIPTION_MORE = dedent ( \"\"\"\\ The copy must have a valid answers file which contains info from the last Copier execution, including the source template (it must be a key called `_src_path`). If that file contains also `_commit` and `destination_path` is a git repository, this command will do its best to respect the diff that you have generated since the last `copier` execution. To avoid that, use `copier copy` instead. \"\"\" ) @handle_exceptions def main ( self , destination_path : cli . ExistingDirectory = \".\" ) -> int : \"\"\"Call [run_update][copier.main.Worker.run_update]. Parameters: destination_path: Only the destination path is needed to update, because the `src_path` comes from [the answers file][the-copier-answersyml-file]. The subproject must exist. If not specified, the currently working directory is used. \"\"\" self . parent . _worker ( dst_path = destination_path , ) . run_update () return 0 main ( destination_path = '.' ) \u00b6 Call run_update . Parameters: Name Type Description Default destination_path cli . ExistingDirectory Only the destination path is needed to update, because the src_path comes from the answers file . The subproject must exist. If not specified, the currently working directory is used. '.' Source code in copier/cli.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @handle_exceptions def main ( self , destination_path : cli . ExistingDirectory = \".\" ) -> int : \"\"\"Call [run_update][copier.main.Worker.run_update]. Parameters: destination_path: Only the destination path is needed to update, because the `src_path` comes from [the answers file][the-copier-answersyml-file]. The subproject must exist. If not specified, the currently working directory is used. \"\"\" self . parent . _worker ( dst_path = destination_path , ) . run_update () return 0 handle_exceptions ( method ) \u00b6 Handle keyboard interruption while running a method. Source code in copier/cli.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def handle_exceptions ( method ): \"\"\"Handle keyboard interruption while running a method.\"\"\" @wraps ( method ) def _wrapper ( * args , ** kwargs ): try : try : return method ( * args , ** kwargs ) except KeyboardInterrupt : raise UserMessageError ( \"Execution stopped by user\" ) except UserMessageError as error : print ( colors . red | \" \\n \" . join ( error . args ), file = sys . stderr ) return 1 return _wrapper","title":"cli.py"},{"location":"reference/cli/#copier.cli.CopierApp","text":"Bases: cli . Application The Copier CLI application. Attributes: Name Type Description answers_file cli . SwitchAttr Set answers_file option. exclude cli . SwitchAttr Set exclude option. vcs_ref cli . SwitchAttr Set vcs_ref option. pretend cli . Flag Set pretend option. force cli . Flag Set force option. defaults cli . Flag Set defaults option. overwrite cli . Flag Set overwrite option. skip cli . Flag Set skip_if_exists option. prereleases cli . Flag Set use_prereleases option. quiet cli . Flag Set quiet option. Source code in copier/cli.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class CopierApp ( cli . Application ): \"\"\"The Copier CLI application. Attributes: answers_file: Set [answers_file][] option. exclude: Set [exclude][] option. vcs_ref: Set [vcs_ref][] option. pretend: Set [pretend][] option. force: Set [force][] option. defaults: Set [defaults][] option. overwrite: Set [overwrite][] option. skip: Set [skip_if_exists][] option. prereleases: Set [use_prereleases][] option. quiet: Set [quiet][] option. \"\"\" DESCRIPTION = \"Create a new project from a template.\" DESCRIPTION_MORE = ( dedent ( \"\"\"\\ Docs in https://copier.readthedocs.io/ \"\"\" ) + ( colors . yellow | dedent ( \"\"\"\\ WARNING! Use only trusted project templates, as they might execute code with the same level of access as your user.\\n \"\"\" ) ) ) USAGE = dedent ( \"\"\"\\ copier [MAIN_SWITCHES] [copy] [SUB_SWITCHES] template_src destination_path copier [MAIN_SWITCHES] [update] [SUB_SWITCHES] [destination_path] \"\"\" ) VERSION = copier_version () CALL_MAIN_IF_NESTED_COMMAND = False data : AnyByStrDict = {} answers_file : cli . SwitchAttr = cli . SwitchAttr ( [ \"-a\" , \"--answers-file\" ], default = None , help = ( \"Update using this path (relative to `destination_path`) \" \"to find the answers file\" ), ) exclude : cli . SwitchAttr = cli . SwitchAttr ( [ \"-x\" , \"--exclude\" ], str , list = True , help = ( \"A name or shell-style pattern matching files or folders \" \"that must not be copied\" ), ) vcs_ref : cli . SwitchAttr = cli . SwitchAttr ( [ \"-r\" , \"--vcs-ref\" ], str , help = ( \"Git reference to checkout in `template_src`. \" \"If you do not specify it, it will try to checkout the latest git tag, \" \"as sorted using the PEP 440 algorithm. If you want to checkout always \" \"the latest version, use `--vcs-ref=HEAD`.\" ), ) pretend : cli . Flag = cli . Flag ( [ \"-n\" , \"--pretend\" ], help = \"Run but do not make any changes\" ) force : cli . Flag = cli . Flag ( [ \"-f\" , \"--force\" ], help = \"Same as `--defaults --overwrite`.\" , ) defaults : cli . Flag = cli . Flag ( [ \"-l\" , \"--defaults\" ], help = \"Use default answers to questions, which might be null if not specified.\" , ) overwrite : cli . Flag = cli . Flag ( [ \"-w\" , \"--overwrite\" ], help = \"Overwrite files that already exist, without asking.\" , ) skip : cli . Flag = cli . SwitchAttr ( [ \"-s\" , \"--skip\" ], str , list = True , help = \"Skip specified files if they exist already\" , ) quiet : cli . Flag = cli . Flag ([ \"-q\" , \"--quiet\" ], help = \"Suppress status output\" ) prereleases : cli . Flag = cli . Flag ( [ \"-g\" , \"--prereleases\" ], help = \"Use prereleases to compare template VCS tags.\" , ) @cli . switch ( [ \"-d\" , \"--data\" ], str , \"VARIABLE=VALUE\" , list = True , help = \"Make VARIABLE available as VALUE when rendering the template\" , ) def data_switch ( self , values : StrSeq ) -> None : \"\"\"Update [data][] with provided values. Arguments: values: The list of values to apply. Each value in the list is of the following form: `NAME=VALUE`. \"\"\" for arg in values : key , value = arg . split ( \"=\" , 1 ) value = yaml . safe_load ( value ) self . data [ key ] = value def _worker ( self , src_path : OptStr = None , dst_path : str = \".\" , ** kwargs ) -> Worker : \"\"\" Run Copier's internal API using CLI switches. Arguments: src_path: The source path of the template to generate the project from. dst_path: The path to generate the project to. **kwargs: Arguments passed to [Worker][copier.main.Worker]. \"\"\" return Worker ( data = self . data , dst_path = Path ( dst_path ), answers_file = self . answers_file , exclude = self . exclude , defaults = self . force or self . defaults , overwrite = self . force or self . overwrite , pretend = self . pretend , quiet = self . quiet , src_path = src_path , vcs_ref = self . vcs_ref , use_prereleases = self . prereleases , ** kwargs , ) @handle_exceptions def main ( self , * args : str ) -> int : \"\"\"Copier CLI app shortcuts. This method redirects abstract CLI calls (those that don't specify `copy` or `update`) to [CopierCopySubApp.main][copier.cli.CopierCopySubApp.main] or [CopierUpdateSubApp.main][copier.cli.CopierUpdateSubApp.main] automatically. Examples: - `copier from to` \u2192 `copier copy from to` - `copier from` \u2192 `copier update from` - `copier` \u2192 `copier update .` \"\"\" # Redirect to subcommand if supplied if args and args [ 0 ] in self . _subcommands : self . nested_command = ( self . _subcommands [ args [ 0 ]] . subapplication , [ \"copier %s \" % args [ 0 ]] + list ( args [ 1 :]), ) # If using 0 or 1 args, you want to update elif len ( args ) in { 0 , 1 }: self . nested_command = ( self . _subcommands [ \"update\" ] . subapplication , [ \"copier update\" ] + list ( args ), ) # If using 2 args, you want to copy elif len ( args ) == 2 : self . nested_command = ( self . _subcommands [ \"copy\" ] . subapplication , [ \"copier copy\" ] + list ( args ), ) # If using more args, you're wrong else : self . help () raise UserMessageError ( \"Unsupported arguments\" ) return 0","title":"CopierApp"},{"location":"reference/cli/#copier.cli.CopierApp.data_switch","text":"Update data with provided values. Parameters: Name Type Description Default values StrSeq The list of values to apply. Each value in the list is of the following form: NAME=VALUE . required Source code in copier/cli.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 @cli . switch ( [ \"-d\" , \"--data\" ], str , \"VARIABLE=VALUE\" , list = True , help = \"Make VARIABLE available as VALUE when rendering the template\" , ) def data_switch ( self , values : StrSeq ) -> None : \"\"\"Update [data][] with provided values. Arguments: values: The list of values to apply. Each value in the list is of the following form: `NAME=VALUE`. \"\"\" for arg in values : key , value = arg . split ( \"=\" , 1 ) value = yaml . safe_load ( value ) self . data [ key ] = value","title":"data_switch()"},{"location":"reference/cli/#copier.cli.CopierApp.main","text":"Copier CLI app shortcuts. This method redirects abstract CLI calls (those that don't specify copy or update ) to CopierCopySubApp.main or CopierUpdateSubApp.main automatically. Examples: copier from to \u2192 copier copy from to copier from \u2192 copier update from copier \u2192 copier update . Source code in copier/cli.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 @handle_exceptions def main ( self , * args : str ) -> int : \"\"\"Copier CLI app shortcuts. This method redirects abstract CLI calls (those that don't specify `copy` or `update`) to [CopierCopySubApp.main][copier.cli.CopierCopySubApp.main] or [CopierUpdateSubApp.main][copier.cli.CopierUpdateSubApp.main] automatically. Examples: - `copier from to` \u2192 `copier copy from to` - `copier from` \u2192 `copier update from` - `copier` \u2192 `copier update .` \"\"\" # Redirect to subcommand if supplied if args and args [ 0 ] in self . _subcommands : self . nested_command = ( self . _subcommands [ args [ 0 ]] . subapplication , [ \"copier %s \" % args [ 0 ]] + list ( args [ 1 :]), ) # If using 0 or 1 args, you want to update elif len ( args ) in { 0 , 1 }: self . nested_command = ( self . _subcommands [ \"update\" ] . subapplication , [ \"copier update\" ] + list ( args ), ) # If using 2 args, you want to copy elif len ( args ) == 2 : self . nested_command = ( self . _subcommands [ \"copy\" ] . subapplication , [ \"copier copy\" ] + list ( args ), ) # If using more args, you're wrong else : self . help () raise UserMessageError ( \"Unsupported arguments\" ) return 0","title":"main()"},{"location":"reference/cli/#copier.cli.CopierCopySubApp","text":"Bases: cli . Application The copier copy subcommand. Use this subcommand to bootstrap a new subproject from a template, or to override a preexisting subproject ignoring its history diff. Attributes: Name Type Description cleanup_on_error cli . Flag Set cleanup_on_error option. Source code in copier/cli.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 @CopierApp . subcommand ( \"copy\" ) class CopierCopySubApp ( cli . Application ): \"\"\"The `copier copy` subcommand. Use this subcommand to bootstrap a new subproject from a template, or to override a preexisting subproject ignoring its history diff. Attributes: cleanup_on_error: Set [cleanup_on_error][] option. \"\"\" DESCRIPTION = \"Copy from a template source to a destination.\" cleanup_on_error : cli . Flag = cli . Flag ( [ \"-C\" , \"--no-cleanup\" ], default = True , help = \"On error, do not delete destination if it was created by Copier.\" , ) @handle_exceptions def main ( self , template_src : str , destination_path : str ) -> int : \"\"\"Call [run_copy][copier.main.Worker.run_copy]. Params: template_src: Indicate where to get the template from. This can be a git URL or a local path. destination_path: Where to generate the new subproject. It must not exist or be empty. \"\"\" self . parent . _worker ( template_src , destination_path , cleanup_on_error = self . cleanup_on_error , ) . run_copy () return 0","title":"CopierCopySubApp"},{"location":"reference/cli/#copier.cli.CopierCopySubApp.main","text":"Call run_copy . Parameters: Name Type Description Default template_src str Indicate where to get the template from. This can be a git URL or a local path. required destination_path str Where to generate the new subproject. It must not exist or be empty. required Source code in copier/cli.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 @handle_exceptions def main ( self , template_src : str , destination_path : str ) -> int : \"\"\"Call [run_copy][copier.main.Worker.run_copy]. Params: template_src: Indicate where to get the template from. This can be a git URL or a local path. destination_path: Where to generate the new subproject. It must not exist or be empty. \"\"\" self . parent . _worker ( template_src , destination_path , cleanup_on_error = self . cleanup_on_error , ) . run_copy () return 0","title":"main()"},{"location":"reference/cli/#copier.cli.CopierUpdateSubApp","text":"Bases: cli . Application The copier update subcommand. Use this subcommand to update an existing subproject from a template that supports updates. Source code in copier/cli.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @CopierApp . subcommand ( \"update\" ) class CopierUpdateSubApp ( cli . Application ): \"\"\"The `copier update` subcommand. Use this subcommand to update an existing subproject from a template that supports updates. \"\"\" DESCRIPTION = \"Update a copy from its original template\" DESCRIPTION_MORE = dedent ( \"\"\"\\ The copy must have a valid answers file which contains info from the last Copier execution, including the source template (it must be a key called `_src_path`). If that file contains also `_commit` and `destination_path` is a git repository, this command will do its best to respect the diff that you have generated since the last `copier` execution. To avoid that, use `copier copy` instead. \"\"\" ) @handle_exceptions def main ( self , destination_path : cli . ExistingDirectory = \".\" ) -> int : \"\"\"Call [run_update][copier.main.Worker.run_update]. Parameters: destination_path: Only the destination path is needed to update, because the `src_path` comes from [the answers file][the-copier-answersyml-file]. The subproject must exist. If not specified, the currently working directory is used. \"\"\" self . parent . _worker ( dst_path = destination_path , ) . run_update () return 0","title":"CopierUpdateSubApp"},{"location":"reference/cli/#copier.cli.CopierUpdateSubApp.main","text":"Call run_update . Parameters: Name Type Description Default destination_path cli . ExistingDirectory Only the destination path is needed to update, because the src_path comes from the answers file . The subproject must exist. If not specified, the currently working directory is used. '.' Source code in copier/cli.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @handle_exceptions def main ( self , destination_path : cli . ExistingDirectory = \".\" ) -> int : \"\"\"Call [run_update][copier.main.Worker.run_update]. Parameters: destination_path: Only the destination path is needed to update, because the `src_path` comes from [the answers file][the-copier-answersyml-file]. The subproject must exist. If not specified, the currently working directory is used. \"\"\" self . parent . _worker ( dst_path = destination_path , ) . run_update () return 0","title":"main()"},{"location":"reference/cli/#copier.cli.handle_exceptions","text":"Handle keyboard interruption while running a method. Source code in copier/cli.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def handle_exceptions ( method ): \"\"\"Handle keyboard interruption while running a method.\"\"\" @wraps ( method ) def _wrapper ( * args , ** kwargs ): try : try : return method ( * args , ** kwargs ) except KeyboardInterrupt : raise UserMessageError ( \"Execution stopped by user\" ) except UserMessageError as error : print ( colors . red | \" \\n \" . join ( error . args ), file = sys . stderr ) return 1 return _wrapper","title":"handle_exceptions()"},{"location":"reference/errors/","text":"Custom exceptions used by Copier. ConfigFileError \u00b6 Bases: ValueError , CopierError Parent class defining problems with the config file. Source code in copier/errors.py 29 30 class ConfigFileError ( ValueError , CopierError ): \"\"\"Parent class defining problems with the config file.\"\"\" CopierAnswersInterrupt \u00b6 Bases: CopierError , KeyboardInterrupt CopierAnswersInterrupt is raised during interactive question prompts. It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an opportunity for the caller to conduct additional cleanup, such as writing the partially completed answers to a file. Attributes: Name Type Description answers AnswersMap that contains the partially completed answers object. last_question Question representing the last_question that was asked at the time the interrupt was raised. template Template that was being processed for answers. Source code in copier/errors.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class CopierAnswersInterrupt ( CopierError , KeyboardInterrupt ): \"\"\"CopierAnswersInterrupt is raised during interactive question prompts. It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an opportunity for the caller to conduct additional cleanup, such as writing the partially completed answers to a file. Attributes: answers: AnswersMap that contains the partially completed answers object. last_question: Question representing the last_question that was asked at the time the interrupt was raised. template: Template that was being processed for answers. \"\"\" def __init__ ( self , answers : \"AnswersMap\" , last_question : \"Question\" , template : \"Template\" ) -> None : self . answers = answers self . last_question = last_question self . template = template CopierError \u00b6 Bases: Exception Base class for all other Copier errors. Source code in copier/errors.py 17 18 class CopierError ( Exception ): \"\"\"Base class for all other Copier errors.\"\"\" CopierWarning \u00b6 Bases: Warning Base class for all other Copier warnings. Source code in copier/errors.py 102 103 class CopierWarning ( Warning ): \"\"\"Base class for all other Copier warnings.\"\"\" DirtyLocalWarning \u00b6 Bases: UserWarning , CopierWarning Changes and untracked files present in template. Source code in copier/errors.py 114 115 class DirtyLocalWarning ( UserWarning , CopierWarning ): \"\"\"Changes and untracked files present in template.\"\"\" ExtensionNotFoundError \u00b6 Bases: UserMessageError Extensions listed in the configuration could not be loaded. Source code in copier/errors.py 69 70 class ExtensionNotFoundError ( UserMessageError ): \"\"\"Extensions listed in the configuration could not be loaded.\"\"\" InvalidConfigFileError \u00b6 Bases: ConfigFileError Indicates that the config file is wrong. Source code in copier/errors.py 33 34 35 36 37 38 39 class InvalidConfigFileError ( ConfigFileError ): \"\"\"Indicates that the config file is wrong.\"\"\" def __init__ ( self , conf_path : Path , quiet : bool ): msg = str ( conf_path ) printf_exception ( self , \"INVALID CONFIG FILE\" , msg = msg , quiet = quiet ) super () . __init__ ( msg ) InvalidTypeError \u00b6 Bases: TypeError , CopierError The question type is not among the supported ones. Source code in copier/errors.py 51 52 class InvalidTypeError ( TypeError , CopierError ): \"\"\"The question type is not among the supported ones.\"\"\" MultipleConfigFilesError \u00b6 Bases: ConfigFileError Both copier.yml and copier.yaml found, and that's an error. Source code in copier/errors.py 42 43 44 45 46 47 48 class MultipleConfigFilesError ( ConfigFileError ): \"\"\"Both copier.yml and copier.yaml found, and that's an error.\"\"\" def __init__ ( self , conf_paths : \"PathSeq\" ): msg = str ( conf_paths ) printf_exception ( self , \"MULTIPLE CONFIG FILES\" , msg = msg ) super () . __init__ ( msg ) OldTemplateWarning \u00b6 Bases: UserWarning , CopierWarning Template was designed for an older Copier version. Source code in copier/errors.py 110 111 class OldTemplateWarning ( UserWarning , CopierWarning ): \"\"\"Template was designed for an older Copier version.\"\"\" PathNotAbsoluteError \u00b6 Bases: _PathValueError , CopierError The path is not absolute, but it should be. Source code in copier/errors.py 55 56 57 58 59 class PathNotAbsoluteError ( _PathValueError , CopierError ): \"\"\"The path is not absolute, but it should be.\"\"\" code = \"path.not_absolute\" msg_template = '\" {path} \" is not an absolute path' PathNotRelativeError \u00b6 Bases: _PathValueError , CopierError The path is not relative, but it should be. Source code in copier/errors.py 62 63 64 65 66 class PathNotRelativeError ( _PathValueError , CopierError ): \"\"\"The path is not relative, but it should be.\"\"\" code = \"path.not_relative\" msg_template = '\" {path} \" is not a relative path' UnknownCopierVersionWarning \u00b6 Bases: UserWarning , CopierWarning Cannot determine installed Copier version. Source code in copier/errors.py 106 107 class UnknownCopierVersionWarning ( UserWarning , CopierWarning ): \"\"\"Cannot determine installed Copier version.\"\"\" UnsupportedVersionError \u00b6 Bases: UserMessageError Copier version does not support template version. Source code in copier/errors.py 25 26 class UnsupportedVersionError ( UserMessageError ): \"\"\"Copier version does not support template version.\"\"\" UserMessageError \u00b6 Bases: CopierError Exit the program giving a message to the user. Source code in copier/errors.py 21 22 class UserMessageError ( CopierError ): \"\"\"Exit the program giving a message to the user.\"\"\"","title":"errors.py"},{"location":"reference/errors/#copier.errors.ConfigFileError","text":"Bases: ValueError , CopierError Parent class defining problems with the config file. Source code in copier/errors.py 29 30 class ConfigFileError ( ValueError , CopierError ): \"\"\"Parent class defining problems with the config file.\"\"\"","title":"ConfigFileError"},{"location":"reference/errors/#copier.errors.CopierAnswersInterrupt","text":"Bases: CopierError , KeyboardInterrupt CopierAnswersInterrupt is raised during interactive question prompts. It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an opportunity for the caller to conduct additional cleanup, such as writing the partially completed answers to a file. Attributes: Name Type Description answers AnswersMap that contains the partially completed answers object. last_question Question representing the last_question that was asked at the time the interrupt was raised. template Template that was being processed for answers. Source code in copier/errors.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class CopierAnswersInterrupt ( CopierError , KeyboardInterrupt ): \"\"\"CopierAnswersInterrupt is raised during interactive question prompts. It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an opportunity for the caller to conduct additional cleanup, such as writing the partially completed answers to a file. Attributes: answers: AnswersMap that contains the partially completed answers object. last_question: Question representing the last_question that was asked at the time the interrupt was raised. template: Template that was being processed for answers. \"\"\" def __init__ ( self , answers : \"AnswersMap\" , last_question : \"Question\" , template : \"Template\" ) -> None : self . answers = answers self . last_question = last_question self . template = template","title":"CopierAnswersInterrupt"},{"location":"reference/errors/#copier.errors.CopierError","text":"Bases: Exception Base class for all other Copier errors. Source code in copier/errors.py 17 18 class CopierError ( Exception ): \"\"\"Base class for all other Copier errors.\"\"\"","title":"CopierError"},{"location":"reference/errors/#copier.errors.CopierWarning","text":"Bases: Warning Base class for all other Copier warnings. Source code in copier/errors.py 102 103 class CopierWarning ( Warning ): \"\"\"Base class for all other Copier warnings.\"\"\"","title":"CopierWarning"},{"location":"reference/errors/#copier.errors.DirtyLocalWarning","text":"Bases: UserWarning , CopierWarning Changes and untracked files present in template. Source code in copier/errors.py 114 115 class DirtyLocalWarning ( UserWarning , CopierWarning ): \"\"\"Changes and untracked files present in template.\"\"\"","title":"DirtyLocalWarning"},{"location":"reference/errors/#copier.errors.ExtensionNotFoundError","text":"Bases: UserMessageError Extensions listed in the configuration could not be loaded. Source code in copier/errors.py 69 70 class ExtensionNotFoundError ( UserMessageError ): \"\"\"Extensions listed in the configuration could not be loaded.\"\"\"","title":"ExtensionNotFoundError"},{"location":"reference/errors/#copier.errors.InvalidConfigFileError","text":"Bases: ConfigFileError Indicates that the config file is wrong. Source code in copier/errors.py 33 34 35 36 37 38 39 class InvalidConfigFileError ( ConfigFileError ): \"\"\"Indicates that the config file is wrong.\"\"\" def __init__ ( self , conf_path : Path , quiet : bool ): msg = str ( conf_path ) printf_exception ( self , \"INVALID CONFIG FILE\" , msg = msg , quiet = quiet ) super () . __init__ ( msg )","title":"InvalidConfigFileError"},{"location":"reference/errors/#copier.errors.InvalidTypeError","text":"Bases: TypeError , CopierError The question type is not among the supported ones. Source code in copier/errors.py 51 52 class InvalidTypeError ( TypeError , CopierError ): \"\"\"The question type is not among the supported ones.\"\"\"","title":"InvalidTypeError"},{"location":"reference/errors/#copier.errors.MultipleConfigFilesError","text":"Bases: ConfigFileError Both copier.yml and copier.yaml found, and that's an error. Source code in copier/errors.py 42 43 44 45 46 47 48 class MultipleConfigFilesError ( ConfigFileError ): \"\"\"Both copier.yml and copier.yaml found, and that's an error.\"\"\" def __init__ ( self , conf_paths : \"PathSeq\" ): msg = str ( conf_paths ) printf_exception ( self , \"MULTIPLE CONFIG FILES\" , msg = msg ) super () . __init__ ( msg )","title":"MultipleConfigFilesError"},{"location":"reference/errors/#copier.errors.OldTemplateWarning","text":"Bases: UserWarning , CopierWarning Template was designed for an older Copier version. Source code in copier/errors.py 110 111 class OldTemplateWarning ( UserWarning , CopierWarning ): \"\"\"Template was designed for an older Copier version.\"\"\"","title":"OldTemplateWarning"},{"location":"reference/errors/#copier.errors.PathNotAbsoluteError","text":"Bases: _PathValueError , CopierError The path is not absolute, but it should be. Source code in copier/errors.py 55 56 57 58 59 class PathNotAbsoluteError ( _PathValueError , CopierError ): \"\"\"The path is not absolute, but it should be.\"\"\" code = \"path.not_absolute\" msg_template = '\" {path} \" is not an absolute path'","title":"PathNotAbsoluteError"},{"location":"reference/errors/#copier.errors.PathNotRelativeError","text":"Bases: _PathValueError , CopierError The path is not relative, but it should be. Source code in copier/errors.py 62 63 64 65 66 class PathNotRelativeError ( _PathValueError , CopierError ): \"\"\"The path is not relative, but it should be.\"\"\" code = \"path.not_relative\" msg_template = '\" {path} \" is not a relative path'","title":"PathNotRelativeError"},{"location":"reference/errors/#copier.errors.UnknownCopierVersionWarning","text":"Bases: UserWarning , CopierWarning Cannot determine installed Copier version. Source code in copier/errors.py 106 107 class UnknownCopierVersionWarning ( UserWarning , CopierWarning ): \"\"\"Cannot determine installed Copier version.\"\"\"","title":"UnknownCopierVersionWarning"},{"location":"reference/errors/#copier.errors.UnsupportedVersionError","text":"Bases: UserMessageError Copier version does not support template version. Source code in copier/errors.py 25 26 class UnsupportedVersionError ( UserMessageError ): \"\"\"Copier version does not support template version.\"\"\"","title":"UnsupportedVersionError"},{"location":"reference/errors/#copier.errors.UserMessageError","text":"Bases: CopierError Exit the program giving a message to the user. Source code in copier/errors.py 21 22 class UserMessageError ( CopierError ): \"\"\"Exit the program giving a message to the user.\"\"\"","title":"UserMessageError"},{"location":"reference/main/","text":"Main functions and classes, used to generate or update projects. Worker \u00b6 Copier process state manager. This class represents the state of a copier work, and contains methods to actually produce the desired work. To use it properly, use it as a context manager and fill all dataclass fields. Then, execute one of its main methods, which are prefixed with run_ : run_copy to copy a subproject. run_update to update a subproject. run_auto to let it choose whether you want to copy or update the subproject. Example with Worker ( src_path = \"https://github.com/copier-org/autopretty.git\" , \"output\" ) as worker : worker . run_copy () Attributes: Name Type Description src_path Optional [ str ] String that can be resolved to a template path, be it local or remote. See copier.vcs.get_repo . If it is None , then it means that you are updating a project , and the original src_path will be obtained from the answers file . dst_path Path Destination path where to render the subproject. answers_file Optional [ RelativePath ] Indicates the path for the answers file . The path must be relative to dst_path . If it is None , the default value will be obtained from copier.template.Template.answers_relpath . vcs_ref OptStr Specify the VCS tag/commit to use in the template. data AnyByStrDict Answers to the questionary defined in the template. exclude StrSeq User-chosen additional file exclusion patterns . use_prereleases bool Consider prereleases when detecting the latest one? See use_prereleases . Useless if specifying a vcs_ref . skip_if_exists StrSeq User-chosen additional file skip patterns . cleanup_on_error bool Delete dst_path if there's an error? See cleanup_on_error . defaults bool When True , use default answers to questions, which might be null if not specified. See defaults . user_defaults AnyByStrDict Specify user defaults that may override a template's defaults during question prompts. overwrite bool When True , Overwrite files that already exist, without asking. See overwrite . pretend bool When True , produce no real rendering. See pretend . quiet bool When True , disable all output. See quiet . Source code in copier/main.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 @dataclass ( config = ConfigDict ( extra = Extra . forbid )) class Worker : \"\"\"Copier process state manager. This class represents the state of a copier work, and contains methods to actually produce the desired work. To use it properly, use it as a context manager and fill all dataclass fields. Then, execute one of its main methods, which are prefixed with `run_`: - [run_copy][copier.main.Worker.run_copy] to copy a subproject. - [run_update][copier.main.Worker.run_update] to update a subproject. - [run_auto][copier.main.Worker.run_auto] to let it choose whether you want to copy or update the subproject. Example: ```python with Worker(src_path=\"https://github.com/copier-org/autopretty.git\", \"output\") as worker: worker.run_copy() ``` Attributes: src_path: String that can be resolved to a template path, be it local or remote. See [copier.vcs.get_repo][]. If it is `None`, then it means that you are [updating a project][updating-a-project], and the original `src_path` will be obtained from [the answers file][the-copier-answersyml-file]. dst_path: Destination path where to render the subproject. answers_file: Indicates the path for [the answers file][the-copier-answersyml-file]. The path must be relative to `dst_path`. If it is `None`, the default value will be obtained from [copier.template.Template.answers_relpath][]. vcs_ref: Specify the VCS tag/commit to use in the template. data: Answers to the questionary defined in the template. exclude: User-chosen additional [file exclusion patterns][exclude]. use_prereleases: Consider prereleases when detecting the *latest* one? See [use_prereleases][]. Useless if specifying a [vcs_ref][]. skip_if_exists: User-chosen additional [file skip patterns][skip_if_exists]. cleanup_on_error: Delete `dst_path` if there's an error? See [cleanup_on_error][]. defaults: When `True`, use default answers to questions, which might be null if not specified. See [defaults][]. user_defaults: Specify user defaults that may override a template's defaults during question prompts. overwrite: When `True`, Overwrite files that already exist, without asking. See [overwrite][]. pretend: When `True`, produce no real rendering. See [pretend][]. quiet: When `True`, disable all output. See [quiet][]. \"\"\" src_path : Optional [ str ] = None dst_path : Path = field ( default = Path ( \".\" )) answers_file : Optional [ RelativePath ] = None vcs_ref : OptStr = None data : AnyByStrDict = field ( default_factory = dict ) exclude : StrSeq = () use_prereleases : bool = False skip_if_exists : StrSeq = () cleanup_on_error : bool = True defaults : bool = False user_defaults : AnyByStrDict = field ( default_factory = dict ) overwrite : bool = False pretend : bool = False quiet : bool = False def __enter__ ( self ): return self def __exit__ ( self , type , value , traceback ): if value is not None : # exception was raised from code inside context manager: # try to clean up, ignoring any exception, then re-raise with suppress ( Exception ): self . _cleanup () raise value # otherwise clean up and let any exception bubble up self . _cleanup () def _cleanup ( self ): self . template . _cleanup () def _answers_to_remember ( self ) -> Mapping : \"\"\"Get only answers that will be remembered in the copier answers file.\"\"\" # All internal values must appear first answers : AnyByStrDict = {} commit = self . template . commit src = self . template . url for key , value in (( \"_commit\" , commit ), ( \"_src_path\" , src )): if value is not None : answers [ key ] = value # Other data goes next answers . update ( ( str ( k ), v ) for ( k , v ) in self . answers . combined . items () if not k . startswith ( \"_\" ) and k not in self . template . secret_questions and k in self . template . questions_data and isinstance ( k , JSONSerializable ) and isinstance ( v , JSONSerializable ) ) return answers def _execute_tasks ( self , tasks : Sequence [ Task ]) -> None : \"\"\"Run the given tasks. Arguments: tasks: The list of tasks to run. \"\"\" for i , task in enumerate ( tasks ): task_cmd = task . cmd if isinstance ( task_cmd , str ): task_cmd = self . _render_string ( task_cmd ) use_shell = True else : task_cmd = [ self . _render_string ( str ( part )) for part in task_cmd ] use_shell = False if not self . quiet : print ( colors . info | f \" > Running task { i + 1 } of { len ( tasks ) } : { task_cmd } \" , file = sys . stderr , ) with local . cwd ( self . subproject . local_abspath ), local . env ( ** task . extra_env ): subprocess . run ( task_cmd , shell = use_shell , check = True , env = local . env ) def _render_context ( self ) -> Mapping : \"\"\"Produce render context for Jinja.\"\"\" # Backwards compatibility # FIXME Remove it? conf = asdict ( self ) conf . update ( { \"answers_file\" : self . answers_relpath , \"src_path\" : self . template . local_abspath , \"vcs_ref_hash\" : self . template . commit_hash , } ) return dict ( DEFAULT_DATA , ** self . answers . combined , _copier_answers = self . _answers_to_remember (), _copier_conf = conf , _folder_name = self . subproject . local_abspath . name , _copier_python = sys . executable , ) def _path_matcher ( self , patterns : Iterable [ str ]) -> Callable [[ Path ], bool ]: \"\"\"Produce a function that matches against specified patterns.\"\"\" # TODO Is normalization really needed? normalized_patterns = ( normalize ( \"NFD\" , pattern ) for pattern in patterns ) spec = PathSpec . from_lines ( \"gitwildmatch\" , normalized_patterns ) return spec . match_file def _solve_render_conflict ( self , dst_relpath : Path ): \"\"\"Properly solve render conflicts. It can ask the user if running in interactive mode. \"\"\" assert not dst_relpath . is_absolute () printf ( \"conflict\" , dst_relpath , style = Style . DANGER , quiet = self . quiet , file_ = sys . stderr , ) if self . match_skip ( dst_relpath ): printf ( \"skip\" , dst_relpath , style = Style . OK , quiet = self . quiet , file_ = sys . stderr , ) return False if self . overwrite or dst_relpath == self . answers_relpath : printf ( \"overwrite\" , dst_relpath , style = Style . WARNING , quiet = self . quiet , file_ = sys . stderr , ) return True return bool ( ask ( f \" Overwrite { dst_relpath } ?\" , default = True )) def _render_allowed ( self , dst_relpath : Path , is_dir : bool = False , expected_contents : bytes = b \"\" , expected_permissions = None , ) -> bool : \"\"\"Determine if a file or directory can be rendered. Args: dst_relpath: Relative path to destination. is_dir: Indicate if the path must be treated as a directory or not. expected_contents: Used to compare existing file contents with them. Allows to know if rendering is needed. \"\"\" assert not dst_relpath . is_absolute () assert not expected_contents or not is_dir , \"Dirs cannot have expected content\" dst_abspath = Path ( self . subproject . local_abspath , dst_relpath ) if dst_relpath != Path ( \".\" ) and self . match_exclude ( dst_relpath ): return False try : previous_content = dst_abspath . read_bytes () except FileNotFoundError : printf ( \"create\" , dst_relpath , style = Style . OK , quiet = self . quiet , file_ = sys . stderr , ) return True except ( IsADirectoryError , PermissionError ) as error : # HACK https://bugs.python.org/issue43095 if isinstance ( error , PermissionError ) and not ( error . errno == 13 and platform . system () == \"Windows\" ): raise if is_dir : printf ( \"identical\" , dst_relpath , style = Style . IGNORE , quiet = self . quiet , file_ = sys . stderr , ) return True return self . _solve_render_conflict ( dst_relpath ) else : if previous_content == expected_contents : printf ( \"identical\" , dst_relpath , style = Style . IGNORE , quiet = self . quiet , file_ = sys . stderr , ) return True return self . _solve_render_conflict ( dst_relpath ) @cached_property def answers ( self ) -> AnswersMap : \"\"\"Container of all answers to the questionary. It asks the user the 1st time it is called, if running interactively. \"\"\" result = AnswersMap ( default = self . template . default_answers , user_defaults = self . user_defaults , init = self . data , last = self . subproject . last_answers , metadata = self . template . metadata , ) questions : List [ Question ] = [] for var_name , details in self . template . questions_data . items (): if var_name in result . init : # Do not ask again continue questions . append ( Question ( answers = result , ask_user = not self . defaults , jinja_env = self . jinja_env , var_name = var_name , ** details , ) ) for question in questions : # Display TUI and ask user interactively only without --defaults try : new_answer = ( question . get_default () if self . defaults else unsafe_prompt ( [ question . get_questionary_structure ()], answers = result . combined )[ question . var_name ] ) except KeyboardInterrupt as err : raise CopierAnswersInterrupt ( result , question , self . template ) from err previous_answer = result . combined . get ( question . var_name ) # If question was skipped and it's the 1st # run, you could be getting a raw templated value default_answer = result . default . get ( question . var_name ) if new_answer == default_answer : new_answer = question . render_value ( default_answer ) new_answer = question . filter_answer ( new_answer ) if new_answer != previous_answer : result . user [ question . var_name ] = new_answer return result @cached_property def answers_relpath ( self ) -> Path : \"\"\"Obtain the proper relative path for the answers file. It comes from: 1. User choice. 2. Template default. 3. Copier default. \"\"\" return self . answers_file or self . template . answers_relpath @cached_property def all_exclusions ( self ) -> StrSeq : \"\"\"Combine default, template and user-chosen exclusions.\"\"\" return self . template . exclude + tuple ( self . exclude ) @cached_property def jinja_env ( self ) -> SandboxedEnvironment : \"\"\"Return a pre-configured Jinja environment. Respects template settings. \"\"\" paths = [ str ( self . template . local_abspath )] loader = FileSystemLoader ( paths ) default_extensions = [ \"jinja2_ansible_filters.AnsibleCoreFiltersExtension\" , ] extensions = default_extensions + list ( self . template . jinja_extensions ) # We want to minimize the risk of hidden malware in the templates # so we use the SandboxedEnvironment instead of the regular one. # Of course we still have the post-copy tasks to worry about, but at least # they are more visible to the final user. try : env = SandboxedEnvironment ( loader = loader , extensions = extensions , ** self . template . envops ) except ModuleNotFoundError as error : raise ExtensionNotFoundError ( f \"Copier could not load some Jinja extensions: \\n { error } \\n \" \"Make sure to install these extensions alongside Copier itself. \\n \" \"See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions\" ) # patch the `to_json` filter to support Pydantic dataclasses env . filters [ \"to_json\" ] = partial ( env . filters [ \"to_json\" ], default = pydantic_encoder ) return env @cached_property def match_exclude ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all exclusions.\"\"\" return self . _path_matcher ( self . all_exclusions ) @cached_property def match_skip ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all skip-if-exists patterns.\"\"\" return self . _path_matcher ( map ( self . _render_string , tuple ( chain ( self . skip_if_exists , self . template . skip_if_exists )), ) ) def _render_file ( self , src_abspath : Path ) -> None : \"\"\"Render one file. Args: src_abspath: The absolute path to the file that will be rendered. \"\"\" # TODO Get from main.render_file() assert src_abspath . is_absolute () src_relpath = src_abspath . relative_to ( self . template . local_abspath ) . as_posix () src_renderpath = src_abspath . relative_to ( self . template_copy_root ) dst_relpath = self . _render_path ( src_renderpath ) if dst_relpath is None : return if src_abspath . name . endswith ( self . template . templates_suffix ): try : tpl = self . jinja_env . get_template ( src_relpath ) except UnicodeDecodeError : if self . template . templates_suffix : # suffix is not empty, re-raise raise # suffix is empty, fallback to copy new_content = src_abspath . read_bytes () else : new_content = tpl . render ( ** self . _render_context ()) . encode () else : new_content = src_abspath . read_bytes () dst_abspath = Path ( self . subproject . local_abspath , dst_relpath ) if dst_abspath . is_dir (): return src_mode = src_abspath . stat () . st_mode if not self . _render_allowed ( dst_relpath , expected_contents = new_content , expected_permissions = src_mode , ): return if not self . pretend : dst_abspath . write_bytes ( new_content ) dst_abspath . chmod ( src_mode ) def _render_folder ( self , src_abspath : Path ) -> None : \"\"\"Recursively render a folder. Args: src_path: Folder to be rendered. It must be an absolute path within the template. \"\"\" assert src_abspath . is_absolute () src_relpath = src_abspath . relative_to ( self . template_copy_root ) dst_relpath = self . _render_path ( src_relpath ) if dst_relpath is None : return if not self . _render_allowed ( dst_relpath , is_dir = True ): return dst_abspath = Path ( self . subproject . local_abspath , dst_relpath ) if not self . pretend : dst_abspath . mkdir ( parents = True , exist_ok = True ) for file in src_abspath . iterdir (): if file . is_dir (): self . _render_folder ( file ) else : self . _render_file ( file ) def _render_path ( self , relpath : Path ) -> Optional [ Path ]: \"\"\"Render one relative path. Args: relpath: The relative path to be rendered. Obviously, it can be templated. \"\"\" is_template = relpath . name . endswith ( self . template . templates_suffix ) templated_sibling = ( self . template . local_abspath / f \" { relpath }{ self . template . templates_suffix } \" ) # With an empty suffix, the templated sibling always exists. if templated_sibling . exists () and self . template . templates_suffix : return None rendered_parts = [] for part in relpath . parts : # Skip folder if any part is rendered as an empty string part = self . _render_string ( part ) if not part : return None rendered_parts . append ( part ) with suppress ( IndexError ): # With an empty suffix, the next instruction # would erroneously empty the last rendered part if is_template and self . template . templates_suffix : rendered_parts [ - 1 ] = rendered_parts [ - 1 ][ : - len ( self . template . templates_suffix ) ] result = Path ( * rendered_parts ) if not is_template : templated_sibling = ( self . template . local_abspath / f \" { result }{ self . template . templates_suffix } \" ) if templated_sibling . exists (): return None return result def _render_string ( self , string : str ) -> str : \"\"\"Render one templated string. Args: string: The template source string. \"\"\" tpl = self . jinja_env . from_string ( string ) return tpl . render ( ** self . _render_context ()) @cached_property def subproject ( self ) -> Subproject : \"\"\"Get related subproject.\"\"\" return Subproject ( local_abspath = self . dst_path . absolute (), answers_relpath = self . answers_file or Path ( \".copier-answers.yml\" ), ) @cached_property def template ( self ) -> Template : \"\"\"Get related template.\"\"\" url = self . src_path if not url : if self . subproject . template is None : raise TypeError ( \"Template not found\" ) url = str ( self . subproject . template . url ) return Template ( url = url , ref = self . vcs_ref , use_prereleases = self . use_prereleases ) @cached_property def template_copy_root ( self ) -> Path : \"\"\"Absolute path from where to start copying. It points to the cloned template local abspath + the rendered subdir, if any. \"\"\" subdir = self . _render_string ( self . template . subdirectory ) or \"\" return self . template . local_abspath / subdir # Main operations def run_auto ( self ) -> None : \"\"\"Copy or update automatically. If `src_path` was supplied, execute [run_copy][copier.main.Worker.run_copy]. Otherwise, execute [run_update][copier.main.Worker.run_update]. \"\"\" if self . src_path : return self . run_copy () return self . run_update () def run_copy ( self ) -> None : \"\"\"Generate a subproject from zero, ignoring what was in the folder. If `dst_path` was missing, it will be created. Otherwise, `src_path` be rendered directly into it, without worrying about evolving what was there already. See [generating a project][generating-a-project]. \"\"\" was_existing = self . subproject . local_abspath . exists () src_abspath = self . template_copy_root try : if not self . quiet : # TODO Unify printing tools print ( f \" \\n Copying from template version { self . template . version } \" , file = sys . stderr , ) self . _render_folder ( src_abspath ) if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space self . _execute_tasks ( self . template . tasks ) except Exception : if not was_existing and self . cleanup_on_error : rmtree ( self . subproject . local_abspath ) raise if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space def run_update ( self ) -> None : \"\"\"Update a subproject that was already generated. See [updating a project][updating-a-project]. \"\"\" # Check all you need is there if self . subproject . vcs != \"git\" : raise UserMessageError ( \"Updating is only supported in git-tracked subprojects.\" ) if self . subproject . is_dirty (): raise UserMessageError ( \"Destination repository is dirty; cannot continue. \" \"Please commit or stash your local changes and retry.\" ) if self . subproject . template is None or self . subproject . template . ref is None : raise UserMessageError ( \"Cannot update because cannot obtain old template references \" f \"from ` { self . subproject . answers_relpath } `.\" ) if self . template . commit is None : raise UserMessageError ( \"Updating is only supported in git-tracked templates.\" ) if not self . subproject . template . version : raise UserMessageError ( \"Cannot update: version from last update not detected.\" ) if not self . template . version : raise UserMessageError ( \"Cannot update: version from template not detected.\" ) if self . subproject . template . version > self . template . version : raise UserMessageError ( f \"Your are downgrading from { self . subproject . template . version } to { self . template . version } . \" \"Downgrades are not supported.\" ) if not self . quiet : # TODO Unify printing tools print ( f \"Updating to template version { self . template . version } \" , file = sys . stderr ) # Copy old template into a temporary destination with TemporaryDirectory ( prefix = f \" { __name__ } .update_diff.\" ) as old_copy , TemporaryDirectory ( prefix = f \" { __name__ } .recopy_diff.\" ) as new_copy : old_worker = replace ( self , dst_path = old_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , vcs_ref = self . subproject . template . commit , ) recopy_worker = replace ( self , dst_path = new_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , ) old_worker . run_copy () recopy_worker . run_copy () compared = dircmp ( old_copy , new_copy ) # Extract diff between temporary destination and real destination with local . cwd ( old_copy ): subproject_top = git ( \"-C\" , self . subproject . local_abspath . absolute (), \"rev-parse\" , \"--show-toplevel\" , ) . strip () git ( \"init\" , retcode = None ) git ( \"add\" , \".\" ) git ( \"config\" , \"user.name\" , \"Copier\" ) git ( \"config\" , \"user.email\" , \"copier@copier\" ) # 1st commit could fail if any pre-commit hook reformats code git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 1\" , retcode = None ) git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 2\" ) git ( \"config\" , \"--unset\" , \"user.name\" ) git ( \"config\" , \"--unset\" , \"user.email\" ) git ( \"remote\" , \"add\" , \"real_dst\" , \"file://\" + subproject_top ) git ( \"fetch\" , \"--depth=1\" , \"real_dst\" , \"HEAD\" ) diff_cmd = git [ \"diff-tree\" , \"--unified=1\" , \"HEAD...FETCH_HEAD\" ] try : diff = diff_cmd ( \"--inter-hunk-context=-1\" ) except ProcessExecutionError : print ( colors . warn | \"Make sure Git >= 2.24 is installed to improve updates.\" , file = sys . stderr , ) diff = diff_cmd ( \"--inter-hunk-context=0\" ) # Run pre-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"before\" , self . subproject . template ) ) # Clear last answers cache to load possible answers migration with suppress ( AttributeError ): del self . answers with suppress ( AttributeError ): del self . subproject . last_answers # Do a normal update in final destination self . run_copy () # Try to apply cached diff into final destination with local . cwd ( self . subproject . local_abspath ): apply_cmd = git [ \"apply\" , \"--reject\" , \"--exclude\" , self . answers_relpath ] for skip_pattern in chain ( self . skip_if_exists , self . template . skip_if_exists ): apply_cmd = apply_cmd [ \"--exclude\" , skip_pattern ] ( apply_cmd << diff )( retcode = None ) # Trigger recursive removal of deleted files in last template version _remove_old_files ( self . subproject . local_abspath , compared ) # Run post-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"after\" , self . subproject . template ) ) all_exclusions () \u00b6 Combine default, template and user-chosen exclusions. Source code in copier/main.py 403 404 405 406 @cached_property def all_exclusions ( self ) -> StrSeq : \"\"\"Combine default, template and user-chosen exclusions.\"\"\" return self . template . exclude + tuple ( self . exclude ) answers () \u00b6 Container of all answers to the questionary. It asks the user the 1st time it is called, if running interactively. Source code in copier/main.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 @cached_property def answers ( self ) -> AnswersMap : \"\"\"Container of all answers to the questionary. It asks the user the 1st time it is called, if running interactively. \"\"\" result = AnswersMap ( default = self . template . default_answers , user_defaults = self . user_defaults , init = self . data , last = self . subproject . last_answers , metadata = self . template . metadata , ) questions : List [ Question ] = [] for var_name , details in self . template . questions_data . items (): if var_name in result . init : # Do not ask again continue questions . append ( Question ( answers = result , ask_user = not self . defaults , jinja_env = self . jinja_env , var_name = var_name , ** details , ) ) for question in questions : # Display TUI and ask user interactively only without --defaults try : new_answer = ( question . get_default () if self . defaults else unsafe_prompt ( [ question . get_questionary_structure ()], answers = result . combined )[ question . var_name ] ) except KeyboardInterrupt as err : raise CopierAnswersInterrupt ( result , question , self . template ) from err previous_answer = result . combined . get ( question . var_name ) # If question was skipped and it's the 1st # run, you could be getting a raw templated value default_answer = result . default . get ( question . var_name ) if new_answer == default_answer : new_answer = question . render_value ( default_answer ) new_answer = question . filter_answer ( new_answer ) if new_answer != previous_answer : result . user [ question . var_name ] = new_answer return result answers_relpath () \u00b6 Obtain the proper relative path for the answers file. It comes from: User choice. Template default. Copier default. Source code in copier/main.py 391 392 393 394 395 396 397 398 399 400 401 @cached_property def answers_relpath ( self ) -> Path : \"\"\"Obtain the proper relative path for the answers file. It comes from: 1. User choice. 2. Template default. 3. Copier default. \"\"\" return self . answers_file or self . template . answers_relpath jinja_env () \u00b6 Return a pre-configured Jinja environment. Respects template settings. Source code in copier/main.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 @cached_property def jinja_env ( self ) -> SandboxedEnvironment : \"\"\"Return a pre-configured Jinja environment. Respects template settings. \"\"\" paths = [ str ( self . template . local_abspath )] loader = FileSystemLoader ( paths ) default_extensions = [ \"jinja2_ansible_filters.AnsibleCoreFiltersExtension\" , ] extensions = default_extensions + list ( self . template . jinja_extensions ) # We want to minimize the risk of hidden malware in the templates # so we use the SandboxedEnvironment instead of the regular one. # Of course we still have the post-copy tasks to worry about, but at least # they are more visible to the final user. try : env = SandboxedEnvironment ( loader = loader , extensions = extensions , ** self . template . envops ) except ModuleNotFoundError as error : raise ExtensionNotFoundError ( f \"Copier could not load some Jinja extensions: \\n { error } \\n \" \"Make sure to install these extensions alongside Copier itself. \\n \" \"See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions\" ) # patch the `to_json` filter to support Pydantic dataclasses env . filters [ \"to_json\" ] = partial ( env . filters [ \"to_json\" ], default = pydantic_encoder ) return env match_exclude () \u00b6 Get a callable to match paths against all exclusions. Source code in copier/main.py 440 441 442 443 @cached_property def match_exclude ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all exclusions.\"\"\" return self . _path_matcher ( self . all_exclusions ) match_skip () \u00b6 Get a callable to match paths against all skip-if-exists patterns. Source code in copier/main.py 445 446 447 448 449 450 451 452 453 @cached_property def match_skip ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all skip-if-exists patterns.\"\"\" return self . _path_matcher ( map ( self . _render_string , tuple ( chain ( self . skip_if_exists , self . template . skip_if_exists )), ) ) run_auto () \u00b6 Copy or update automatically. If src_path was supplied, execute run_copy . Otherwise, execute run_update . Source code in copier/main.py 597 598 599 600 601 602 603 604 605 606 607 def run_auto ( self ) -> None : \"\"\"Copy or update automatically. If `src_path` was supplied, execute [run_copy][copier.main.Worker.run_copy]. Otherwise, execute [run_update][copier.main.Worker.run_update]. \"\"\" if self . src_path : return self . run_copy () return self . run_update () run_copy () \u00b6 Generate a subproject from zero, ignoring what was in the folder. If dst_path was missing, it will be created. Otherwise, src_path be rendered directly into it, without worrying about evolving what was there already. See generating a project . Source code in copier/main.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def run_copy ( self ) -> None : \"\"\"Generate a subproject from zero, ignoring what was in the folder. If `dst_path` was missing, it will be created. Otherwise, `src_path` be rendered directly into it, without worrying about evolving what was there already. See [generating a project][generating-a-project]. \"\"\" was_existing = self . subproject . local_abspath . exists () src_abspath = self . template_copy_root try : if not self . quiet : # TODO Unify printing tools print ( f \" \\n Copying from template version { self . template . version } \" , file = sys . stderr , ) self . _render_folder ( src_abspath ) if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space self . _execute_tasks ( self . template . tasks ) except Exception : if not was_existing and self . cleanup_on_error : rmtree ( self . subproject . local_abspath ) raise if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space run_update () \u00b6 Update a subproject that was already generated. See updating a project . Source code in copier/main.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def run_update ( self ) -> None : \"\"\"Update a subproject that was already generated. See [updating a project][updating-a-project]. \"\"\" # Check all you need is there if self . subproject . vcs != \"git\" : raise UserMessageError ( \"Updating is only supported in git-tracked subprojects.\" ) if self . subproject . is_dirty (): raise UserMessageError ( \"Destination repository is dirty; cannot continue. \" \"Please commit or stash your local changes and retry.\" ) if self . subproject . template is None or self . subproject . template . ref is None : raise UserMessageError ( \"Cannot update because cannot obtain old template references \" f \"from ` { self . subproject . answers_relpath } `.\" ) if self . template . commit is None : raise UserMessageError ( \"Updating is only supported in git-tracked templates.\" ) if not self . subproject . template . version : raise UserMessageError ( \"Cannot update: version from last update not detected.\" ) if not self . template . version : raise UserMessageError ( \"Cannot update: version from template not detected.\" ) if self . subproject . template . version > self . template . version : raise UserMessageError ( f \"Your are downgrading from { self . subproject . template . version } to { self . template . version } . \" \"Downgrades are not supported.\" ) if not self . quiet : # TODO Unify printing tools print ( f \"Updating to template version { self . template . version } \" , file = sys . stderr ) # Copy old template into a temporary destination with TemporaryDirectory ( prefix = f \" { __name__ } .update_diff.\" ) as old_copy , TemporaryDirectory ( prefix = f \" { __name__ } .recopy_diff.\" ) as new_copy : old_worker = replace ( self , dst_path = old_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , vcs_ref = self . subproject . template . commit , ) recopy_worker = replace ( self , dst_path = new_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , ) old_worker . run_copy () recopy_worker . run_copy () compared = dircmp ( old_copy , new_copy ) # Extract diff between temporary destination and real destination with local . cwd ( old_copy ): subproject_top = git ( \"-C\" , self . subproject . local_abspath . absolute (), \"rev-parse\" , \"--show-toplevel\" , ) . strip () git ( \"init\" , retcode = None ) git ( \"add\" , \".\" ) git ( \"config\" , \"user.name\" , \"Copier\" ) git ( \"config\" , \"user.email\" , \"copier@copier\" ) # 1st commit could fail if any pre-commit hook reformats code git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 1\" , retcode = None ) git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 2\" ) git ( \"config\" , \"--unset\" , \"user.name\" ) git ( \"config\" , \"--unset\" , \"user.email\" ) git ( \"remote\" , \"add\" , \"real_dst\" , \"file://\" + subproject_top ) git ( \"fetch\" , \"--depth=1\" , \"real_dst\" , \"HEAD\" ) diff_cmd = git [ \"diff-tree\" , \"--unified=1\" , \"HEAD...FETCH_HEAD\" ] try : diff = diff_cmd ( \"--inter-hunk-context=-1\" ) except ProcessExecutionError : print ( colors . warn | \"Make sure Git >= 2.24 is installed to improve updates.\" , file = sys . stderr , ) diff = diff_cmd ( \"--inter-hunk-context=0\" ) # Run pre-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"before\" , self . subproject . template ) ) # Clear last answers cache to load possible answers migration with suppress ( AttributeError ): del self . answers with suppress ( AttributeError ): del self . subproject . last_answers # Do a normal update in final destination self . run_copy () # Try to apply cached diff into final destination with local . cwd ( self . subproject . local_abspath ): apply_cmd = git [ \"apply\" , \"--reject\" , \"--exclude\" , self . answers_relpath ] for skip_pattern in chain ( self . skip_if_exists , self . template . skip_if_exists ): apply_cmd = apply_cmd [ \"--exclude\" , skip_pattern ] ( apply_cmd << diff )( retcode = None ) # Trigger recursive removal of deleted files in last template version _remove_old_files ( self . subproject . local_abspath , compared ) # Run post-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"after\" , self . subproject . template ) ) subproject () \u00b6 Get related subproject. Source code in copier/main.py 569 570 571 572 573 574 575 @cached_property def subproject ( self ) -> Subproject : \"\"\"Get related subproject.\"\"\" return Subproject ( local_abspath = self . dst_path . absolute (), answers_relpath = self . answers_file or Path ( \".copier-answers.yml\" ), ) template () \u00b6 Get related template. Source code in copier/main.py 577 578 579 580 581 582 583 584 585 @cached_property def template ( self ) -> Template : \"\"\"Get related template.\"\"\" url = self . src_path if not url : if self . subproject . template is None : raise TypeError ( \"Template not found\" ) url = str ( self . subproject . template . url ) return Template ( url = url , ref = self . vcs_ref , use_prereleases = self . use_prereleases ) template_copy_root () \u00b6 Absolute path from where to start copying. It points to the cloned template local abspath + the rendered subdir, if any. Source code in copier/main.py 587 588 589 590 591 592 593 594 @cached_property def template_copy_root ( self ) -> Path : \"\"\"Absolute path from where to start copying. It points to the cloned template local abspath + the rendered subdir, if any. \"\"\" subdir = self . _render_string ( self . template . subdirectory ) or \"\" return self . template . local_abspath / subdir run_auto ( src_path = None , dst_path = '.' , data = None , ** kwargs ) \u00b6 Generate or update a subproject. This is a shortcut for run_auto . See Worker fields to understand this function's args. Source code in copier/main.py 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def run_auto ( src_path : OptStr = None , dst_path : StrOrPath = \".\" , data : AnyByStrDict = None , ** kwargs , ) -> Worker : \"\"\"Generate or update a subproject. This is a shortcut for [run_auto][copier.main.Worker.run_auto]. See [Worker][copier.main.Worker] fields to understand this function's args. \"\"\" if src_path is None : return run_update ( dst_path , data , ** kwargs ) return run_copy ( src_path , dst_path , data , ** kwargs ) run_copy ( src_path , dst_path = '.' , data = None , ** kwargs ) \u00b6 Copy a template to a destination, from zero. This is a shortcut for run_copy . See Worker fields to understand this function's args. Source code in copier/main.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 def run_copy ( src_path : str , dst_path : StrOrPath = \".\" , data : AnyByStrDict = None , ** kwargs , ) -> Worker : \"\"\"Copy a template to a destination, from zero. This is a shortcut for [run_copy][copier.main.Worker.run_copy]. See [Worker][copier.main.Worker] fields to understand this function's args. \"\"\" if data is not None : kwargs [ \"data\" ] = data with Worker ( src_path = src_path , dst_path = Path ( dst_path ), ** kwargs ) as worker : worker . run_copy () return worker run_update ( dst_path = '.' , data = None , ** kwargs ) \u00b6 Update a subproject, from its template. This is a shortcut for run_update . See Worker fields to understand this function's args. Source code in copier/main.py 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 def run_update ( dst_path : StrOrPath = \".\" , data : AnyByStrDict = None , ** kwargs , ) -> Worker : \"\"\"Update a subproject, from its template. This is a shortcut for [run_update][copier.main.Worker.run_update]. See [Worker][copier.main.Worker] fields to understand this function's args. \"\"\" if data is not None : kwargs [ \"data\" ] = data with Worker ( dst_path = Path ( dst_path ), ** kwargs ) as worker : worker . run_update () return worker","title":"main.py"},{"location":"reference/main/#copier.main.Worker","text":"Copier process state manager. This class represents the state of a copier work, and contains methods to actually produce the desired work. To use it properly, use it as a context manager and fill all dataclass fields. Then, execute one of its main methods, which are prefixed with run_ : run_copy to copy a subproject. run_update to update a subproject. run_auto to let it choose whether you want to copy or update the subproject. Example with Worker ( src_path = \"https://github.com/copier-org/autopretty.git\" , \"output\" ) as worker : worker . run_copy () Attributes: Name Type Description src_path Optional [ str ] String that can be resolved to a template path, be it local or remote. See copier.vcs.get_repo . If it is None , then it means that you are updating a project , and the original src_path will be obtained from the answers file . dst_path Path Destination path where to render the subproject. answers_file Optional [ RelativePath ] Indicates the path for the answers file . The path must be relative to dst_path . If it is None , the default value will be obtained from copier.template.Template.answers_relpath . vcs_ref OptStr Specify the VCS tag/commit to use in the template. data AnyByStrDict Answers to the questionary defined in the template. exclude StrSeq User-chosen additional file exclusion patterns . use_prereleases bool Consider prereleases when detecting the latest one? See use_prereleases . Useless if specifying a vcs_ref . skip_if_exists StrSeq User-chosen additional file skip patterns . cleanup_on_error bool Delete dst_path if there's an error? See cleanup_on_error . defaults bool When True , use default answers to questions, which might be null if not specified. See defaults . user_defaults AnyByStrDict Specify user defaults that may override a template's defaults during question prompts. overwrite bool When True , Overwrite files that already exist, without asking. See overwrite . pretend bool When True , produce no real rendering. See pretend . quiet bool When True , disable all output. See quiet . Source code in copier/main.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 @dataclass ( config = ConfigDict ( extra = Extra . forbid )) class Worker : \"\"\"Copier process state manager. This class represents the state of a copier work, and contains methods to actually produce the desired work. To use it properly, use it as a context manager and fill all dataclass fields. Then, execute one of its main methods, which are prefixed with `run_`: - [run_copy][copier.main.Worker.run_copy] to copy a subproject. - [run_update][copier.main.Worker.run_update] to update a subproject. - [run_auto][copier.main.Worker.run_auto] to let it choose whether you want to copy or update the subproject. Example: ```python with Worker(src_path=\"https://github.com/copier-org/autopretty.git\", \"output\") as worker: worker.run_copy() ``` Attributes: src_path: String that can be resolved to a template path, be it local or remote. See [copier.vcs.get_repo][]. If it is `None`, then it means that you are [updating a project][updating-a-project], and the original `src_path` will be obtained from [the answers file][the-copier-answersyml-file]. dst_path: Destination path where to render the subproject. answers_file: Indicates the path for [the answers file][the-copier-answersyml-file]. The path must be relative to `dst_path`. If it is `None`, the default value will be obtained from [copier.template.Template.answers_relpath][]. vcs_ref: Specify the VCS tag/commit to use in the template. data: Answers to the questionary defined in the template. exclude: User-chosen additional [file exclusion patterns][exclude]. use_prereleases: Consider prereleases when detecting the *latest* one? See [use_prereleases][]. Useless if specifying a [vcs_ref][]. skip_if_exists: User-chosen additional [file skip patterns][skip_if_exists]. cleanup_on_error: Delete `dst_path` if there's an error? See [cleanup_on_error][]. defaults: When `True`, use default answers to questions, which might be null if not specified. See [defaults][]. user_defaults: Specify user defaults that may override a template's defaults during question prompts. overwrite: When `True`, Overwrite files that already exist, without asking. See [overwrite][]. pretend: When `True`, produce no real rendering. See [pretend][]. quiet: When `True`, disable all output. See [quiet][]. \"\"\" src_path : Optional [ str ] = None dst_path : Path = field ( default = Path ( \".\" )) answers_file : Optional [ RelativePath ] = None vcs_ref : OptStr = None data : AnyByStrDict = field ( default_factory = dict ) exclude : StrSeq = () use_prereleases : bool = False skip_if_exists : StrSeq = () cleanup_on_error : bool = True defaults : bool = False user_defaults : AnyByStrDict = field ( default_factory = dict ) overwrite : bool = False pretend : bool = False quiet : bool = False def __enter__ ( self ): return self def __exit__ ( self , type , value , traceback ): if value is not None : # exception was raised from code inside context manager: # try to clean up, ignoring any exception, then re-raise with suppress ( Exception ): self . _cleanup () raise value # otherwise clean up and let any exception bubble up self . _cleanup () def _cleanup ( self ): self . template . _cleanup () def _answers_to_remember ( self ) -> Mapping : \"\"\"Get only answers that will be remembered in the copier answers file.\"\"\" # All internal values must appear first answers : AnyByStrDict = {} commit = self . template . commit src = self . template . url for key , value in (( \"_commit\" , commit ), ( \"_src_path\" , src )): if value is not None : answers [ key ] = value # Other data goes next answers . update ( ( str ( k ), v ) for ( k , v ) in self . answers . combined . items () if not k . startswith ( \"_\" ) and k not in self . template . secret_questions and k in self . template . questions_data and isinstance ( k , JSONSerializable ) and isinstance ( v , JSONSerializable ) ) return answers def _execute_tasks ( self , tasks : Sequence [ Task ]) -> None : \"\"\"Run the given tasks. Arguments: tasks: The list of tasks to run. \"\"\" for i , task in enumerate ( tasks ): task_cmd = task . cmd if isinstance ( task_cmd , str ): task_cmd = self . _render_string ( task_cmd ) use_shell = True else : task_cmd = [ self . _render_string ( str ( part )) for part in task_cmd ] use_shell = False if not self . quiet : print ( colors . info | f \" > Running task { i + 1 } of { len ( tasks ) } : { task_cmd } \" , file = sys . stderr , ) with local . cwd ( self . subproject . local_abspath ), local . env ( ** task . extra_env ): subprocess . run ( task_cmd , shell = use_shell , check = True , env = local . env ) def _render_context ( self ) -> Mapping : \"\"\"Produce render context for Jinja.\"\"\" # Backwards compatibility # FIXME Remove it? conf = asdict ( self ) conf . update ( { \"answers_file\" : self . answers_relpath , \"src_path\" : self . template . local_abspath , \"vcs_ref_hash\" : self . template . commit_hash , } ) return dict ( DEFAULT_DATA , ** self . answers . combined , _copier_answers = self . _answers_to_remember (), _copier_conf = conf , _folder_name = self . subproject . local_abspath . name , _copier_python = sys . executable , ) def _path_matcher ( self , patterns : Iterable [ str ]) -> Callable [[ Path ], bool ]: \"\"\"Produce a function that matches against specified patterns.\"\"\" # TODO Is normalization really needed? normalized_patterns = ( normalize ( \"NFD\" , pattern ) for pattern in patterns ) spec = PathSpec . from_lines ( \"gitwildmatch\" , normalized_patterns ) return spec . match_file def _solve_render_conflict ( self , dst_relpath : Path ): \"\"\"Properly solve render conflicts. It can ask the user if running in interactive mode. \"\"\" assert not dst_relpath . is_absolute () printf ( \"conflict\" , dst_relpath , style = Style . DANGER , quiet = self . quiet , file_ = sys . stderr , ) if self . match_skip ( dst_relpath ): printf ( \"skip\" , dst_relpath , style = Style . OK , quiet = self . quiet , file_ = sys . stderr , ) return False if self . overwrite or dst_relpath == self . answers_relpath : printf ( \"overwrite\" , dst_relpath , style = Style . WARNING , quiet = self . quiet , file_ = sys . stderr , ) return True return bool ( ask ( f \" Overwrite { dst_relpath } ?\" , default = True )) def _render_allowed ( self , dst_relpath : Path , is_dir : bool = False , expected_contents : bytes = b \"\" , expected_permissions = None , ) -> bool : \"\"\"Determine if a file or directory can be rendered. Args: dst_relpath: Relative path to destination. is_dir: Indicate if the path must be treated as a directory or not. expected_contents: Used to compare existing file contents with them. Allows to know if rendering is needed. \"\"\" assert not dst_relpath . is_absolute () assert not expected_contents or not is_dir , \"Dirs cannot have expected content\" dst_abspath = Path ( self . subproject . local_abspath , dst_relpath ) if dst_relpath != Path ( \".\" ) and self . match_exclude ( dst_relpath ): return False try : previous_content = dst_abspath . read_bytes () except FileNotFoundError : printf ( \"create\" , dst_relpath , style = Style . OK , quiet = self . quiet , file_ = sys . stderr , ) return True except ( IsADirectoryError , PermissionError ) as error : # HACK https://bugs.python.org/issue43095 if isinstance ( error , PermissionError ) and not ( error . errno == 13 and platform . system () == \"Windows\" ): raise if is_dir : printf ( \"identical\" , dst_relpath , style = Style . IGNORE , quiet = self . quiet , file_ = sys . stderr , ) return True return self . _solve_render_conflict ( dst_relpath ) else : if previous_content == expected_contents : printf ( \"identical\" , dst_relpath , style = Style . IGNORE , quiet = self . quiet , file_ = sys . stderr , ) return True return self . _solve_render_conflict ( dst_relpath ) @cached_property def answers ( self ) -> AnswersMap : \"\"\"Container of all answers to the questionary. It asks the user the 1st time it is called, if running interactively. \"\"\" result = AnswersMap ( default = self . template . default_answers , user_defaults = self . user_defaults , init = self . data , last = self . subproject . last_answers , metadata = self . template . metadata , ) questions : List [ Question ] = [] for var_name , details in self . template . questions_data . items (): if var_name in result . init : # Do not ask again continue questions . append ( Question ( answers = result , ask_user = not self . defaults , jinja_env = self . jinja_env , var_name = var_name , ** details , ) ) for question in questions : # Display TUI and ask user interactively only without --defaults try : new_answer = ( question . get_default () if self . defaults else unsafe_prompt ( [ question . get_questionary_structure ()], answers = result . combined )[ question . var_name ] ) except KeyboardInterrupt as err : raise CopierAnswersInterrupt ( result , question , self . template ) from err previous_answer = result . combined . get ( question . var_name ) # If question was skipped and it's the 1st # run, you could be getting a raw templated value default_answer = result . default . get ( question . var_name ) if new_answer == default_answer : new_answer = question . render_value ( default_answer ) new_answer = question . filter_answer ( new_answer ) if new_answer != previous_answer : result . user [ question . var_name ] = new_answer return result @cached_property def answers_relpath ( self ) -> Path : \"\"\"Obtain the proper relative path for the answers file. It comes from: 1. User choice. 2. Template default. 3. Copier default. \"\"\" return self . answers_file or self . template . answers_relpath @cached_property def all_exclusions ( self ) -> StrSeq : \"\"\"Combine default, template and user-chosen exclusions.\"\"\" return self . template . exclude + tuple ( self . exclude ) @cached_property def jinja_env ( self ) -> SandboxedEnvironment : \"\"\"Return a pre-configured Jinja environment. Respects template settings. \"\"\" paths = [ str ( self . template . local_abspath )] loader = FileSystemLoader ( paths ) default_extensions = [ \"jinja2_ansible_filters.AnsibleCoreFiltersExtension\" , ] extensions = default_extensions + list ( self . template . jinja_extensions ) # We want to minimize the risk of hidden malware in the templates # so we use the SandboxedEnvironment instead of the regular one. # Of course we still have the post-copy tasks to worry about, but at least # they are more visible to the final user. try : env = SandboxedEnvironment ( loader = loader , extensions = extensions , ** self . template . envops ) except ModuleNotFoundError as error : raise ExtensionNotFoundError ( f \"Copier could not load some Jinja extensions: \\n { error } \\n \" \"Make sure to install these extensions alongside Copier itself. \\n \" \"See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions\" ) # patch the `to_json` filter to support Pydantic dataclasses env . filters [ \"to_json\" ] = partial ( env . filters [ \"to_json\" ], default = pydantic_encoder ) return env @cached_property def match_exclude ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all exclusions.\"\"\" return self . _path_matcher ( self . all_exclusions ) @cached_property def match_skip ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all skip-if-exists patterns.\"\"\" return self . _path_matcher ( map ( self . _render_string , tuple ( chain ( self . skip_if_exists , self . template . skip_if_exists )), ) ) def _render_file ( self , src_abspath : Path ) -> None : \"\"\"Render one file. Args: src_abspath: The absolute path to the file that will be rendered. \"\"\" # TODO Get from main.render_file() assert src_abspath . is_absolute () src_relpath = src_abspath . relative_to ( self . template . local_abspath ) . as_posix () src_renderpath = src_abspath . relative_to ( self . template_copy_root ) dst_relpath = self . _render_path ( src_renderpath ) if dst_relpath is None : return if src_abspath . name . endswith ( self . template . templates_suffix ): try : tpl = self . jinja_env . get_template ( src_relpath ) except UnicodeDecodeError : if self . template . templates_suffix : # suffix is not empty, re-raise raise # suffix is empty, fallback to copy new_content = src_abspath . read_bytes () else : new_content = tpl . render ( ** self . _render_context ()) . encode () else : new_content = src_abspath . read_bytes () dst_abspath = Path ( self . subproject . local_abspath , dst_relpath ) if dst_abspath . is_dir (): return src_mode = src_abspath . stat () . st_mode if not self . _render_allowed ( dst_relpath , expected_contents = new_content , expected_permissions = src_mode , ): return if not self . pretend : dst_abspath . write_bytes ( new_content ) dst_abspath . chmod ( src_mode ) def _render_folder ( self , src_abspath : Path ) -> None : \"\"\"Recursively render a folder. Args: src_path: Folder to be rendered. It must be an absolute path within the template. \"\"\" assert src_abspath . is_absolute () src_relpath = src_abspath . relative_to ( self . template_copy_root ) dst_relpath = self . _render_path ( src_relpath ) if dst_relpath is None : return if not self . _render_allowed ( dst_relpath , is_dir = True ): return dst_abspath = Path ( self . subproject . local_abspath , dst_relpath ) if not self . pretend : dst_abspath . mkdir ( parents = True , exist_ok = True ) for file in src_abspath . iterdir (): if file . is_dir (): self . _render_folder ( file ) else : self . _render_file ( file ) def _render_path ( self , relpath : Path ) -> Optional [ Path ]: \"\"\"Render one relative path. Args: relpath: The relative path to be rendered. Obviously, it can be templated. \"\"\" is_template = relpath . name . endswith ( self . template . templates_suffix ) templated_sibling = ( self . template . local_abspath / f \" { relpath }{ self . template . templates_suffix } \" ) # With an empty suffix, the templated sibling always exists. if templated_sibling . exists () and self . template . templates_suffix : return None rendered_parts = [] for part in relpath . parts : # Skip folder if any part is rendered as an empty string part = self . _render_string ( part ) if not part : return None rendered_parts . append ( part ) with suppress ( IndexError ): # With an empty suffix, the next instruction # would erroneously empty the last rendered part if is_template and self . template . templates_suffix : rendered_parts [ - 1 ] = rendered_parts [ - 1 ][ : - len ( self . template . templates_suffix ) ] result = Path ( * rendered_parts ) if not is_template : templated_sibling = ( self . template . local_abspath / f \" { result }{ self . template . templates_suffix } \" ) if templated_sibling . exists (): return None return result def _render_string ( self , string : str ) -> str : \"\"\"Render one templated string. Args: string: The template source string. \"\"\" tpl = self . jinja_env . from_string ( string ) return tpl . render ( ** self . _render_context ()) @cached_property def subproject ( self ) -> Subproject : \"\"\"Get related subproject.\"\"\" return Subproject ( local_abspath = self . dst_path . absolute (), answers_relpath = self . answers_file or Path ( \".copier-answers.yml\" ), ) @cached_property def template ( self ) -> Template : \"\"\"Get related template.\"\"\" url = self . src_path if not url : if self . subproject . template is None : raise TypeError ( \"Template not found\" ) url = str ( self . subproject . template . url ) return Template ( url = url , ref = self . vcs_ref , use_prereleases = self . use_prereleases ) @cached_property def template_copy_root ( self ) -> Path : \"\"\"Absolute path from where to start copying. It points to the cloned template local abspath + the rendered subdir, if any. \"\"\" subdir = self . _render_string ( self . template . subdirectory ) or \"\" return self . template . local_abspath / subdir # Main operations def run_auto ( self ) -> None : \"\"\"Copy or update automatically. If `src_path` was supplied, execute [run_copy][copier.main.Worker.run_copy]. Otherwise, execute [run_update][copier.main.Worker.run_update]. \"\"\" if self . src_path : return self . run_copy () return self . run_update () def run_copy ( self ) -> None : \"\"\"Generate a subproject from zero, ignoring what was in the folder. If `dst_path` was missing, it will be created. Otherwise, `src_path` be rendered directly into it, without worrying about evolving what was there already. See [generating a project][generating-a-project]. \"\"\" was_existing = self . subproject . local_abspath . exists () src_abspath = self . template_copy_root try : if not self . quiet : # TODO Unify printing tools print ( f \" \\n Copying from template version { self . template . version } \" , file = sys . stderr , ) self . _render_folder ( src_abspath ) if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space self . _execute_tasks ( self . template . tasks ) except Exception : if not was_existing and self . cleanup_on_error : rmtree ( self . subproject . local_abspath ) raise if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space def run_update ( self ) -> None : \"\"\"Update a subproject that was already generated. See [updating a project][updating-a-project]. \"\"\" # Check all you need is there if self . subproject . vcs != \"git\" : raise UserMessageError ( \"Updating is only supported in git-tracked subprojects.\" ) if self . subproject . is_dirty (): raise UserMessageError ( \"Destination repository is dirty; cannot continue. \" \"Please commit or stash your local changes and retry.\" ) if self . subproject . template is None or self . subproject . template . ref is None : raise UserMessageError ( \"Cannot update because cannot obtain old template references \" f \"from ` { self . subproject . answers_relpath } `.\" ) if self . template . commit is None : raise UserMessageError ( \"Updating is only supported in git-tracked templates.\" ) if not self . subproject . template . version : raise UserMessageError ( \"Cannot update: version from last update not detected.\" ) if not self . template . version : raise UserMessageError ( \"Cannot update: version from template not detected.\" ) if self . subproject . template . version > self . template . version : raise UserMessageError ( f \"Your are downgrading from { self . subproject . template . version } to { self . template . version } . \" \"Downgrades are not supported.\" ) if not self . quiet : # TODO Unify printing tools print ( f \"Updating to template version { self . template . version } \" , file = sys . stderr ) # Copy old template into a temporary destination with TemporaryDirectory ( prefix = f \" { __name__ } .update_diff.\" ) as old_copy , TemporaryDirectory ( prefix = f \" { __name__ } .recopy_diff.\" ) as new_copy : old_worker = replace ( self , dst_path = old_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , vcs_ref = self . subproject . template . commit , ) recopy_worker = replace ( self , dst_path = new_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , ) old_worker . run_copy () recopy_worker . run_copy () compared = dircmp ( old_copy , new_copy ) # Extract diff between temporary destination and real destination with local . cwd ( old_copy ): subproject_top = git ( \"-C\" , self . subproject . local_abspath . absolute (), \"rev-parse\" , \"--show-toplevel\" , ) . strip () git ( \"init\" , retcode = None ) git ( \"add\" , \".\" ) git ( \"config\" , \"user.name\" , \"Copier\" ) git ( \"config\" , \"user.email\" , \"copier@copier\" ) # 1st commit could fail if any pre-commit hook reformats code git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 1\" , retcode = None ) git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 2\" ) git ( \"config\" , \"--unset\" , \"user.name\" ) git ( \"config\" , \"--unset\" , \"user.email\" ) git ( \"remote\" , \"add\" , \"real_dst\" , \"file://\" + subproject_top ) git ( \"fetch\" , \"--depth=1\" , \"real_dst\" , \"HEAD\" ) diff_cmd = git [ \"diff-tree\" , \"--unified=1\" , \"HEAD...FETCH_HEAD\" ] try : diff = diff_cmd ( \"--inter-hunk-context=-1\" ) except ProcessExecutionError : print ( colors . warn | \"Make sure Git >= 2.24 is installed to improve updates.\" , file = sys . stderr , ) diff = diff_cmd ( \"--inter-hunk-context=0\" ) # Run pre-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"before\" , self . subproject . template ) ) # Clear last answers cache to load possible answers migration with suppress ( AttributeError ): del self . answers with suppress ( AttributeError ): del self . subproject . last_answers # Do a normal update in final destination self . run_copy () # Try to apply cached diff into final destination with local . cwd ( self . subproject . local_abspath ): apply_cmd = git [ \"apply\" , \"--reject\" , \"--exclude\" , self . answers_relpath ] for skip_pattern in chain ( self . skip_if_exists , self . template . skip_if_exists ): apply_cmd = apply_cmd [ \"--exclude\" , skip_pattern ] ( apply_cmd << diff )( retcode = None ) # Trigger recursive removal of deleted files in last template version _remove_old_files ( self . subproject . local_abspath , compared ) # Run post-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"after\" , self . subproject . template ) )","title":"Worker"},{"location":"reference/main/#copier.main.Worker.all_exclusions","text":"Combine default, template and user-chosen exclusions. Source code in copier/main.py 403 404 405 406 @cached_property def all_exclusions ( self ) -> StrSeq : \"\"\"Combine default, template and user-chosen exclusions.\"\"\" return self . template . exclude + tuple ( self . exclude )","title":"all_exclusions()"},{"location":"reference/main/#copier.main.Worker.answers","text":"Container of all answers to the questionary. It asks the user the 1st time it is called, if running interactively. Source code in copier/main.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 @cached_property def answers ( self ) -> AnswersMap : \"\"\"Container of all answers to the questionary. It asks the user the 1st time it is called, if running interactively. \"\"\" result = AnswersMap ( default = self . template . default_answers , user_defaults = self . user_defaults , init = self . data , last = self . subproject . last_answers , metadata = self . template . metadata , ) questions : List [ Question ] = [] for var_name , details in self . template . questions_data . items (): if var_name in result . init : # Do not ask again continue questions . append ( Question ( answers = result , ask_user = not self . defaults , jinja_env = self . jinja_env , var_name = var_name , ** details , ) ) for question in questions : # Display TUI and ask user interactively only without --defaults try : new_answer = ( question . get_default () if self . defaults else unsafe_prompt ( [ question . get_questionary_structure ()], answers = result . combined )[ question . var_name ] ) except KeyboardInterrupt as err : raise CopierAnswersInterrupt ( result , question , self . template ) from err previous_answer = result . combined . get ( question . var_name ) # If question was skipped and it's the 1st # run, you could be getting a raw templated value default_answer = result . default . get ( question . var_name ) if new_answer == default_answer : new_answer = question . render_value ( default_answer ) new_answer = question . filter_answer ( new_answer ) if new_answer != previous_answer : result . user [ question . var_name ] = new_answer return result","title":"answers()"},{"location":"reference/main/#copier.main.Worker.answers_relpath","text":"Obtain the proper relative path for the answers file. It comes from: User choice. Template default. Copier default. Source code in copier/main.py 391 392 393 394 395 396 397 398 399 400 401 @cached_property def answers_relpath ( self ) -> Path : \"\"\"Obtain the proper relative path for the answers file. It comes from: 1. User choice. 2. Template default. 3. Copier default. \"\"\" return self . answers_file or self . template . answers_relpath","title":"answers_relpath()"},{"location":"reference/main/#copier.main.Worker.jinja_env","text":"Return a pre-configured Jinja environment. Respects template settings. Source code in copier/main.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 @cached_property def jinja_env ( self ) -> SandboxedEnvironment : \"\"\"Return a pre-configured Jinja environment. Respects template settings. \"\"\" paths = [ str ( self . template . local_abspath )] loader = FileSystemLoader ( paths ) default_extensions = [ \"jinja2_ansible_filters.AnsibleCoreFiltersExtension\" , ] extensions = default_extensions + list ( self . template . jinja_extensions ) # We want to minimize the risk of hidden malware in the templates # so we use the SandboxedEnvironment instead of the regular one. # Of course we still have the post-copy tasks to worry about, but at least # they are more visible to the final user. try : env = SandboxedEnvironment ( loader = loader , extensions = extensions , ** self . template . envops ) except ModuleNotFoundError as error : raise ExtensionNotFoundError ( f \"Copier could not load some Jinja extensions: \\n { error } \\n \" \"Make sure to install these extensions alongside Copier itself. \\n \" \"See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions\" ) # patch the `to_json` filter to support Pydantic dataclasses env . filters [ \"to_json\" ] = partial ( env . filters [ \"to_json\" ], default = pydantic_encoder ) return env","title":"jinja_env()"},{"location":"reference/main/#copier.main.Worker.match_exclude","text":"Get a callable to match paths against all exclusions. Source code in copier/main.py 440 441 442 443 @cached_property def match_exclude ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all exclusions.\"\"\" return self . _path_matcher ( self . all_exclusions )","title":"match_exclude()"},{"location":"reference/main/#copier.main.Worker.match_skip","text":"Get a callable to match paths against all skip-if-exists patterns. Source code in copier/main.py 445 446 447 448 449 450 451 452 453 @cached_property def match_skip ( self ) -> Callable [[ Path ], bool ]: \"\"\"Get a callable to match paths against all skip-if-exists patterns.\"\"\" return self . _path_matcher ( map ( self . _render_string , tuple ( chain ( self . skip_if_exists , self . template . skip_if_exists )), ) )","title":"match_skip()"},{"location":"reference/main/#copier.main.Worker.run_auto","text":"Copy or update automatically. If src_path was supplied, execute run_copy . Otherwise, execute run_update . Source code in copier/main.py 597 598 599 600 601 602 603 604 605 606 607 def run_auto ( self ) -> None : \"\"\"Copy or update automatically. If `src_path` was supplied, execute [run_copy][copier.main.Worker.run_copy]. Otherwise, execute [run_update][copier.main.Worker.run_update]. \"\"\" if self . src_path : return self . run_copy () return self . run_update ()","title":"run_auto()"},{"location":"reference/main/#copier.main.Worker.run_copy","text":"Generate a subproject from zero, ignoring what was in the folder. If dst_path was missing, it will be created. Otherwise, src_path be rendered directly into it, without worrying about evolving what was there already. See generating a project . Source code in copier/main.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def run_copy ( self ) -> None : \"\"\"Generate a subproject from zero, ignoring what was in the folder. If `dst_path` was missing, it will be created. Otherwise, `src_path` be rendered directly into it, without worrying about evolving what was there already. See [generating a project][generating-a-project]. \"\"\" was_existing = self . subproject . local_abspath . exists () src_abspath = self . template_copy_root try : if not self . quiet : # TODO Unify printing tools print ( f \" \\n Copying from template version { self . template . version } \" , file = sys . stderr , ) self . _render_folder ( src_abspath ) if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space self . _execute_tasks ( self . template . tasks ) except Exception : if not was_existing and self . cleanup_on_error : rmtree ( self . subproject . local_abspath ) raise if not self . quiet : # TODO Unify printing tools print ( \"\" ) # padding space","title":"run_copy()"},{"location":"reference/main/#copier.main.Worker.run_update","text":"Update a subproject that was already generated. See updating a project . Source code in copier/main.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def run_update ( self ) -> None : \"\"\"Update a subproject that was already generated. See [updating a project][updating-a-project]. \"\"\" # Check all you need is there if self . subproject . vcs != \"git\" : raise UserMessageError ( \"Updating is only supported in git-tracked subprojects.\" ) if self . subproject . is_dirty (): raise UserMessageError ( \"Destination repository is dirty; cannot continue. \" \"Please commit or stash your local changes and retry.\" ) if self . subproject . template is None or self . subproject . template . ref is None : raise UserMessageError ( \"Cannot update because cannot obtain old template references \" f \"from ` { self . subproject . answers_relpath } `.\" ) if self . template . commit is None : raise UserMessageError ( \"Updating is only supported in git-tracked templates.\" ) if not self . subproject . template . version : raise UserMessageError ( \"Cannot update: version from last update not detected.\" ) if not self . template . version : raise UserMessageError ( \"Cannot update: version from template not detected.\" ) if self . subproject . template . version > self . template . version : raise UserMessageError ( f \"Your are downgrading from { self . subproject . template . version } to { self . template . version } . \" \"Downgrades are not supported.\" ) if not self . quiet : # TODO Unify printing tools print ( f \"Updating to template version { self . template . version } \" , file = sys . stderr ) # Copy old template into a temporary destination with TemporaryDirectory ( prefix = f \" { __name__ } .update_diff.\" ) as old_copy , TemporaryDirectory ( prefix = f \" { __name__ } .recopy_diff.\" ) as new_copy : old_worker = replace ( self , dst_path = old_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , vcs_ref = self . subproject . template . commit , ) recopy_worker = replace ( self , dst_path = new_copy , data = self . subproject . last_answers , defaults = True , quiet = True , src_path = self . subproject . template . url , ) old_worker . run_copy () recopy_worker . run_copy () compared = dircmp ( old_copy , new_copy ) # Extract diff between temporary destination and real destination with local . cwd ( old_copy ): subproject_top = git ( \"-C\" , self . subproject . local_abspath . absolute (), \"rev-parse\" , \"--show-toplevel\" , ) . strip () git ( \"init\" , retcode = None ) git ( \"add\" , \".\" ) git ( \"config\" , \"user.name\" , \"Copier\" ) git ( \"config\" , \"user.email\" , \"copier@copier\" ) # 1st commit could fail if any pre-commit hook reformats code git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 1\" , retcode = None ) git ( \"commit\" , \"--allow-empty\" , \"-am\" , \"dumb commit 2\" ) git ( \"config\" , \"--unset\" , \"user.name\" ) git ( \"config\" , \"--unset\" , \"user.email\" ) git ( \"remote\" , \"add\" , \"real_dst\" , \"file://\" + subproject_top ) git ( \"fetch\" , \"--depth=1\" , \"real_dst\" , \"HEAD\" ) diff_cmd = git [ \"diff-tree\" , \"--unified=1\" , \"HEAD...FETCH_HEAD\" ] try : diff = diff_cmd ( \"--inter-hunk-context=-1\" ) except ProcessExecutionError : print ( colors . warn | \"Make sure Git >= 2.24 is installed to improve updates.\" , file = sys . stderr , ) diff = diff_cmd ( \"--inter-hunk-context=0\" ) # Run pre-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"before\" , self . subproject . template ) ) # Clear last answers cache to load possible answers migration with suppress ( AttributeError ): del self . answers with suppress ( AttributeError ): del self . subproject . last_answers # Do a normal update in final destination self . run_copy () # Try to apply cached diff into final destination with local . cwd ( self . subproject . local_abspath ): apply_cmd = git [ \"apply\" , \"--reject\" , \"--exclude\" , self . answers_relpath ] for skip_pattern in chain ( self . skip_if_exists , self . template . skip_if_exists ): apply_cmd = apply_cmd [ \"--exclude\" , skip_pattern ] ( apply_cmd << diff )( retcode = None ) # Trigger recursive removal of deleted files in last template version _remove_old_files ( self . subproject . local_abspath , compared ) # Run post-migration tasks self . _execute_tasks ( self . template . migration_tasks ( \"after\" , self . subproject . template ) )","title":"run_update()"},{"location":"reference/main/#copier.main.Worker.subproject","text":"Get related subproject. Source code in copier/main.py 569 570 571 572 573 574 575 @cached_property def subproject ( self ) -> Subproject : \"\"\"Get related subproject.\"\"\" return Subproject ( local_abspath = self . dst_path . absolute (), answers_relpath = self . answers_file or Path ( \".copier-answers.yml\" ), )","title":"subproject()"},{"location":"reference/main/#copier.main.Worker.template","text":"Get related template. Source code in copier/main.py 577 578 579 580 581 582 583 584 585 @cached_property def template ( self ) -> Template : \"\"\"Get related template.\"\"\" url = self . src_path if not url : if self . subproject . template is None : raise TypeError ( \"Template not found\" ) url = str ( self . subproject . template . url ) return Template ( url = url , ref = self . vcs_ref , use_prereleases = self . use_prereleases )","title":"template()"},{"location":"reference/main/#copier.main.Worker.template_copy_root","text":"Absolute path from where to start copying. It points to the cloned template local abspath + the rendered subdir, if any. Source code in copier/main.py 587 588 589 590 591 592 593 594 @cached_property def template_copy_root ( self ) -> Path : \"\"\"Absolute path from where to start copying. It points to the cloned template local abspath + the rendered subdir, if any. \"\"\" subdir = self . _render_string ( self . template . subdirectory ) or \"\" return self . template . local_abspath / subdir","title":"template_copy_root()"},{"location":"reference/main/#copier.main.run_auto","text":"Generate or update a subproject. This is a shortcut for run_auto . See Worker fields to understand this function's args. Source code in copier/main.py 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def run_auto ( src_path : OptStr = None , dst_path : StrOrPath = \".\" , data : AnyByStrDict = None , ** kwargs , ) -> Worker : \"\"\"Generate or update a subproject. This is a shortcut for [run_auto][copier.main.Worker.run_auto]. See [Worker][copier.main.Worker] fields to understand this function's args. \"\"\" if src_path is None : return run_update ( dst_path , data , ** kwargs ) return run_copy ( src_path , dst_path , data , ** kwargs )","title":"run_auto()"},{"location":"reference/main/#copier.main.run_copy","text":"Copy a template to a destination, from zero. This is a shortcut for run_copy . See Worker fields to understand this function's args. Source code in copier/main.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 def run_copy ( src_path : str , dst_path : StrOrPath = \".\" , data : AnyByStrDict = None , ** kwargs , ) -> Worker : \"\"\"Copy a template to a destination, from zero. This is a shortcut for [run_copy][copier.main.Worker.run_copy]. See [Worker][copier.main.Worker] fields to understand this function's args. \"\"\" if data is not None : kwargs [ \"data\" ] = data with Worker ( src_path = src_path , dst_path = Path ( dst_path ), ** kwargs ) as worker : worker . run_copy () return worker","title":"run_copy()"},{"location":"reference/main/#copier.main.run_update","text":"Update a subproject, from its template. This is a shortcut for run_update . See Worker fields to understand this function's args. Source code in copier/main.py 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 def run_update ( dst_path : StrOrPath = \".\" , data : AnyByStrDict = None , ** kwargs , ) -> Worker : \"\"\"Update a subproject, from its template. This is a shortcut for [run_update][copier.main.Worker.run_update]. See [Worker][copier.main.Worker] fields to understand this function's args. \"\"\" if data is not None : kwargs [ \"data\" ] = data with Worker ( dst_path = Path ( dst_path ), ** kwargs ) as worker : worker . run_update () return worker","title":"run_update()"},{"location":"reference/subproject/","text":"Objects to interact with subprojects. A subproject is a project that gets rendered and/or updated with Copier. Subproject \u00b6 Object that represents the subproject and its current state. Attributes: Name Type Description local_abspath AbsolutePath Absolute path on local disk pointing to the subproject root folder. answers_relpath Path Relative path to the answers file . Source code in copier/subproject.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @dataclass class Subproject : \"\"\"Object that represents the subproject and its current state. Attributes: local_abspath: Absolute path on local disk pointing to the subproject root folder. answers_relpath: Relative path to [the answers file][the-copier-answersyml-file]. \"\"\" local_abspath : AbsolutePath answers_relpath : Path = Path ( \".copier-answers.yml\" ) def is_dirty ( self ) -> bool : \"\"\"Indicates if the local template root is dirty. Only applicable for VCS-tracked templates. \"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return bool ( git ( \"status\" , \"--porcelain\" ) . strip ()) return False @property def _raw_answers ( self ) -> AnyByStrDict : \"\"\"The last answers, loaded raw as yaml.\"\"\" try : return yaml . safe_load ( ( self . local_abspath / self . answers_relpath ) . read_text () ) except OSError : return {} @cached_property def last_answers ( self ) -> AnyByStrDict : \"\"\"Last answers, excluding private ones (except _src_path and _commit).\"\"\" return { key : value for key , value in self . _raw_answers . items () if key in { \"_src_path\" , \"_commit\" } or not key . startswith ( \"_\" ) } @cached_property def template ( self ) -> Optional [ Template ]: \"\"\"Template, as it was used the last time.\"\"\" last_url = self . last_answers . get ( \"_src_path\" ) last_ref = self . last_answers . get ( \"_commit\" ) if last_url : return Template ( url = last_url , ref = last_ref ) @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"VCS type of the subproject.\"\"\" if is_in_git_repo ( self . local_abspath ): return \"git\" is_dirty () \u00b6 Indicates if the local template root is dirty. Only applicable for VCS-tracked templates. Source code in copier/subproject.py 41 42 43 44 45 46 47 48 49 def is_dirty ( self ) -> bool : \"\"\"Indicates if the local template root is dirty. Only applicable for VCS-tracked templates. \"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return bool ( git ( \"status\" , \"--porcelain\" ) . strip ()) return False last_answers () \u00b6 Last answers, excluding private ones (except _src_path and _commit). Source code in copier/subproject.py 61 62 63 64 65 66 67 68 @cached_property def last_answers ( self ) -> AnyByStrDict : \"\"\"Last answers, excluding private ones (except _src_path and _commit).\"\"\" return { key : value for key , value in self . _raw_answers . items () if key in { \"_src_path\" , \"_commit\" } or not key . startswith ( \"_\" ) } template () \u00b6 Template, as it was used the last time. Source code in copier/subproject.py 70 71 72 73 74 75 76 @cached_property def template ( self ) -> Optional [ Template ]: \"\"\"Template, as it was used the last time.\"\"\" last_url = self . last_answers . get ( \"_src_path\" ) last_ref = self . last_answers . get ( \"_commit\" ) if last_url : return Template ( url = last_url , ref = last_ref ) vcs () \u00b6 VCS type of the subproject. Source code in copier/subproject.py 78 79 80 81 82 @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"VCS type of the subproject.\"\"\" if is_in_git_repo ( self . local_abspath ): return \"git\"","title":"subproject.py"},{"location":"reference/subproject/#copier.subproject.Subproject","text":"Object that represents the subproject and its current state. Attributes: Name Type Description local_abspath AbsolutePath Absolute path on local disk pointing to the subproject root folder. answers_relpath Path Relative path to the answers file . Source code in copier/subproject.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @dataclass class Subproject : \"\"\"Object that represents the subproject and its current state. Attributes: local_abspath: Absolute path on local disk pointing to the subproject root folder. answers_relpath: Relative path to [the answers file][the-copier-answersyml-file]. \"\"\" local_abspath : AbsolutePath answers_relpath : Path = Path ( \".copier-answers.yml\" ) def is_dirty ( self ) -> bool : \"\"\"Indicates if the local template root is dirty. Only applicable for VCS-tracked templates. \"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return bool ( git ( \"status\" , \"--porcelain\" ) . strip ()) return False @property def _raw_answers ( self ) -> AnyByStrDict : \"\"\"The last answers, loaded raw as yaml.\"\"\" try : return yaml . safe_load ( ( self . local_abspath / self . answers_relpath ) . read_text () ) except OSError : return {} @cached_property def last_answers ( self ) -> AnyByStrDict : \"\"\"Last answers, excluding private ones (except _src_path and _commit).\"\"\" return { key : value for key , value in self . _raw_answers . items () if key in { \"_src_path\" , \"_commit\" } or not key . startswith ( \"_\" ) } @cached_property def template ( self ) -> Optional [ Template ]: \"\"\"Template, as it was used the last time.\"\"\" last_url = self . last_answers . get ( \"_src_path\" ) last_ref = self . last_answers . get ( \"_commit\" ) if last_url : return Template ( url = last_url , ref = last_ref ) @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"VCS type of the subproject.\"\"\" if is_in_git_repo ( self . local_abspath ): return \"git\"","title":"Subproject"},{"location":"reference/subproject/#copier.subproject.Subproject.is_dirty","text":"Indicates if the local template root is dirty. Only applicable for VCS-tracked templates. Source code in copier/subproject.py 41 42 43 44 45 46 47 48 49 def is_dirty ( self ) -> bool : \"\"\"Indicates if the local template root is dirty. Only applicable for VCS-tracked templates. \"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return bool ( git ( \"status\" , \"--porcelain\" ) . strip ()) return False","title":"is_dirty()"},{"location":"reference/subproject/#copier.subproject.Subproject.last_answers","text":"Last answers, excluding private ones (except _src_path and _commit). Source code in copier/subproject.py 61 62 63 64 65 66 67 68 @cached_property def last_answers ( self ) -> AnyByStrDict : \"\"\"Last answers, excluding private ones (except _src_path and _commit).\"\"\" return { key : value for key , value in self . _raw_answers . items () if key in { \"_src_path\" , \"_commit\" } or not key . startswith ( \"_\" ) }","title":"last_answers()"},{"location":"reference/subproject/#copier.subproject.Subproject.template","text":"Template, as it was used the last time. Source code in copier/subproject.py 70 71 72 73 74 75 76 @cached_property def template ( self ) -> Optional [ Template ]: \"\"\"Template, as it was used the last time.\"\"\" last_url = self . last_answers . get ( \"_src_path\" ) last_ref = self . last_answers . get ( \"_commit\" ) if last_url : return Template ( url = last_url , ref = last_ref )","title":"template()"},{"location":"reference/subproject/#copier.subproject.Subproject.vcs","text":"VCS type of the subproject. Source code in copier/subproject.py 78 79 80 81 82 @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"VCS type of the subproject.\"\"\" if is_in_git_repo ( self . local_abspath ): return \"git\"","title":"vcs()"},{"location":"reference/template/","text":"Tools related to template management. Task \u00b6 Object that represents a task to execute. Attributes: Name Type Description cmd Union [ str , Sequence [ str ]] Command to execute. extra_env Env Additional environment variables to set while executing the command. Source code in copier/template.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @dataclass class Task : \"\"\"Object that represents a task to execute. Attributes: cmd: Command to execute. extra_env: Additional environment variables to set while executing the command. \"\"\" cmd : Union [ str , Sequence [ str ]] extra_env : Env = field ( default_factory = dict ) Template \u00b6 Object that represents a template and its current state. See configuring a template . Attributes: Name Type Description url str Absolute origin that points to the template. It can be: A local path. A Git url. Note: if something fails, prefix the URL with git+ . ref OptStr The tag to checkout in the template. Only used if url points to a VCS-tracked template. If None , then it will checkout the latest tag, sorted by PEP440. Otherwise it will checkout the reference used here. Usually it should be a tag, or None . use_prereleases bool When True , the template's latest release will consider prereleases. Only used if: url points to a VCS-tracked template ref is None . Helpful if you want to test templates before doing a proper release, but you need some features that require a proper PEP440 version identifier. Source code in copier/template.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 @dataclass class Template : \"\"\"Object that represents a template and its current state. See [configuring a template][configuring-a-template]. Attributes: url: Absolute origin that points to the template. It can be: - A local path. - A Git url. Note: if something fails, prefix the URL with `git+`. ref: The tag to checkout in the template. Only used if `url` points to a VCS-tracked template. If `None`, then it will checkout the latest tag, sorted by PEP440. Otherwise it will checkout the reference used here. Usually it should be a tag, or `None`. use_prereleases: When `True`, the template's *latest* release will consider prereleases. Only used if: - `url` points to a VCS-tracked template - `ref` is `None`. Helpful if you want to test templates before doing a proper release, but you need some features that require a proper PEP440 version identifier. \"\"\" url : str ref : OptStr = None use_prereleases : bool = False def _cleanup ( self ) -> None : temp_clone = self . _temp_clone if temp_clone : rmtree ( temp_clone , ignore_errors = False , onerror = handle_remove_readonly , ) @property def _temp_clone ( self ) -> Optional [ Path ]: clone_path = self . local_abspath original_path = Path ( self . url ) . expanduser () with suppress ( OSError ): # triggered for URLs on Windows original_path = original_path . resolve () if clone_path != original_path : return clone_path return None @cached_property def _raw_config ( self ) -> AnyByStrDict : \"\"\"Get template configuration, raw. It reads [the `copier.yml` file][the-copieryml-file]. \"\"\" conf_paths = [ p for p in self . local_abspath . glob ( \"copier.*\" ) if p . is_file () and re . match ( r \"\\.ya?ml\" , p . suffix , re . I ) ] if len ( conf_paths ) > 1 : raise MultipleConfigFilesError ( conf_paths ) elif len ( conf_paths ) == 1 : return load_template_config ( conf_paths [ 0 ]) return {} @cached_property def answers_relpath ( self ) -> Path : \"\"\"Get the answers file relative path, as specified in the template. If not specified, returns the default `.copier-answers.yml`. See [answers_file][]. \"\"\" result = Path ( self . config_data . get ( \"answers_file\" , \".copier-answers.yml\" )) assert not result . is_absolute () return result @cached_property def commit ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit description.\"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return git ( \"describe\" , \"--tags\" , \"--always\" ) . strip () @cached_property def commit_hash ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit full hash.\"\"\" if self . vcs == \"git\" : return git ( \"-C\" , self . local_abspath , \"rev-parse\" , \"HEAD\" ) . strip () @cached_property def config_data ( self ) -> AnyByStrDict : \"\"\"Get config from the template. It reads [the `copier.yml` file][the-copieryml-file] to get its [settings][available-settings]. \"\"\" result = filter_config ( self . _raw_config )[ 0 ] with suppress ( KeyError ): verify_copier_version ( result [ \"min_copier_version\" ]) return result @cached_property def default_answers ( self ) -> AnyByStrDict : \"\"\"Get default answers for template's questions.\"\"\" return { key : value . get ( \"default\" ) for key , value in self . questions_data . items ()} @cached_property def envops ( self ) -> Mapping : \"\"\"Get the Jinja configuration specified in the template, or default values. See [envops][]. \"\"\" result = self . config_data . get ( \"envops\" , {}) if \"keep_trailing_newline\" not in result : # NOTE: we want to keep trailing newlines in templates as this is what a # user will most likely expects as a default. # See https://github.com/copier-org/copier/issues/464 result [ \"keep_trailing_newline\" ] = True return result @cached_property def exclude ( self ) -> Tuple [ str , ... ]: \"\"\"Get exclusions specified in the template, or default ones. See [exclude][]. \"\"\" return tuple ( self . config_data . get ( \"exclude\" , DEFAULT_EXCLUDE )) @cached_property def jinja_extensions ( self ) -> Tuple [ str , ... ]: \"\"\"Get Jinja2 extensions specified in the template, or `()`. See [jinja_extensions][]. \"\"\" return tuple ( self . config_data . get ( \"jinja_extensions\" , ())) @cached_property def metadata ( self ) -> AnyByStrDict : \"\"\"Get template metadata. This data, if any, should be saved in the answers file to be able to restore the template to this same state. \"\"\" result : AnyByStrDict = { \"_src_path\" : self . url } if self . commit : result [ \"_commit\" ] = self . commit return result def migration_tasks ( self , stage : Literal [ \"before\" , \"after\" ], from_template : \"Template\" ) -> Sequence [ Task ]: \"\"\"Get migration objects that match current version spec. Versions are compared using PEP 440. See [migrations][]. Args: stage: A valid stage name to find tasks for. from_template: Original template, from which we are migrating. \"\"\" result : List [ Task ] = [] if not ( self . version and from_template . version ): return result extra_env : Env = { \"STAGE\" : stage , \"VERSION_FROM\" : str ( from_template . commit ), \"VERSION_TO\" : str ( self . commit ), \"VERSION_PEP440_FROM\" : str ( from_template . version ), \"VERSION_PEP440_TO\" : str ( self . version ), } migration : dict for migration in self . _raw_config . get ( \"_migrations\" , []): current = parse ( migration [ \"version\" ]) if self . version >= current > from_template . version : extra_env = { ** extra_env , \"VERSION_CURRENT\" : migration [ \"version\" ], \"VERSION_PEP440_CURRENT\" : str ( current ), } for cmd in migration . get ( stage , []): result . append ( Task ( cmd = cmd , extra_env = extra_env )) return result @cached_property def min_copier_version ( self ) -> Optional [ Version ]: \"\"\"Gets minimal copier version for the template and validates it. See [min_copier_version][]. \"\"\" try : return Version ( self . config_data [ \"min_copier_version\" ]) except KeyError : return None @cached_property def questions_data ( self ) -> AnyByStrDict : \"\"\"Get questions from the template. See [questions][]. \"\"\" return filter_config ( self . _raw_config )[ 1 ] @cached_property def secret_questions ( self ) -> Set [ str ]: \"\"\"Get names of secret questions from the template. These questions shouldn't be saved into the answers file. \"\"\" result = set ( self . config_data . get ( \"secret_questions\" , {})) for key , value in self . questions_data . items (): if value . get ( \"secret\" ): result . add ( key ) return result @cached_property def skip_if_exists ( self ) -> StrSeq : \"\"\"Get skip patterns from the template. These files will never be rewritten when rendering the template. See [skip_if_exists][]. \"\"\" return self . config_data . get ( \"skip_if_exists\" , ()) @cached_property def subdirectory ( self ) -> str : \"\"\"Get the subdirectory as specified in the template. The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc. See [subdirectory][]. \"\"\" return self . config_data . get ( \"subdirectory\" , \"\" ) @cached_property def tasks ( self ) -> Sequence [ Task ]: \"\"\"Get tasks defined in the template. See [tasks][]. \"\"\" return [ Task ( cmd = cmd , extra_env = { \"STAGE\" : \"task\" }) for cmd in self . config_data . get ( \"tasks\" , []) ] @cached_property def templates_suffix ( self ) -> str : \"\"\"Get the suffix defined for templates. By default: `.jinja`. See [templates_suffix][]. \"\"\" result = self . config_data . get ( \"templates_suffix\" ) if result is None : return DEFAULT_TEMPLATES_SUFFIX return result @cached_property def local_abspath ( self ) -> Path : \"\"\"Get the absolute path to the template on disk. This may clone it if `url` points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied. \"\"\" result = Path ( self . url ) if self . vcs == \"git\" : result = Path ( clone ( self . url_expanded , self . ref )) if self . ref is None : checkout_latest_tag ( result , self . use_prereleases ) if not result . is_dir (): raise ValueError ( \"Local template must be a directory.\" ) return result . absolute () @cached_property def url_expanded ( self ) -> str : \"\"\"Get usable URL. `url` can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly. \"\"\" return get_repo ( self . url ) or self . url @cached_property def version ( self ) -> Optional [ Version ]: \"\"\"PEP440-compliant version object.\"\"\" if self . vcs != \"git\" or not self . commit : return None try : with local . cwd ( self . local_abspath ): # Leverage dunamai by default; usually it gets best results return Version ( dunamai . Version . from_git () . serialize ( style = dunamai . Style . Pep440 ) ) except ValueError : # A fully descriptive commit can be easily detected converted into a # PEP440 version, because it has the format \"<tag>-<count>-g<hash>\" if re . match ( r \"^.+-\\d+-g\\w+$\" , self . commit ): base , count , git_hash = self . commit . rsplit ( \"-\" , 2 ) return Version ( f \" { base } .post { count } + { git_hash } \" ) # If we get here, the commit string is a tag try : return Version ( self . commit ) except packaging . version . InvalidVersion : # appears to not be a version return None @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"Get VCS system used by the template, if any.\"\"\" if get_repo ( self . url ): return \"git\" answers_relpath () \u00b6 Get the answers file relative path, as specified in the template. If not specified, returns the default .copier-answers.yml . See answers_file . Source code in copier/template.py 231 232 233 234 235 236 237 238 239 240 241 @cached_property def answers_relpath ( self ) -> Path : \"\"\"Get the answers file relative path, as specified in the template. If not specified, returns the default `.copier-answers.yml`. See [answers_file][]. \"\"\" result = Path ( self . config_data . get ( \"answers_file\" , \".copier-answers.yml\" )) assert not result . is_absolute () return result commit () \u00b6 If the template is VCS-tracked, get its commit description. Source code in copier/template.py 243 244 245 246 247 248 @cached_property def commit ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit description.\"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return git ( \"describe\" , \"--tags\" , \"--always\" ) . strip () commit_hash () \u00b6 If the template is VCS-tracked, get its commit full hash. Source code in copier/template.py 250 251 252 253 254 @cached_property def commit_hash ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit full hash.\"\"\" if self . vcs == \"git\" : return git ( \"-C\" , self . local_abspath , \"rev-parse\" , \"HEAD\" ) . strip () config_data () \u00b6 Get config from the template. It reads the copier.yml file to get its settings . Source code in copier/template.py 256 257 258 259 260 261 262 263 264 265 266 @cached_property def config_data ( self ) -> AnyByStrDict : \"\"\"Get config from the template. It reads [the `copier.yml` file][the-copieryml-file] to get its [settings][available-settings]. \"\"\" result = filter_config ( self . _raw_config )[ 0 ] with suppress ( KeyError ): verify_copier_version ( result [ \"min_copier_version\" ]) return result default_answers () \u00b6 Get default answers for template's questions. Source code in copier/template.py 268 269 270 271 @cached_property def default_answers ( self ) -> AnyByStrDict : \"\"\"Get default answers for template's questions.\"\"\" return { key : value . get ( \"default\" ) for key , value in self . questions_data . items ()} envops () \u00b6 Get the Jinja configuration specified in the template, or default values. See envops . Source code in copier/template.py 273 274 275 276 277 278 279 280 281 282 283 284 285 @cached_property def envops ( self ) -> Mapping : \"\"\"Get the Jinja configuration specified in the template, or default values. See [envops][]. \"\"\" result = self . config_data . get ( \"envops\" , {}) if \"keep_trailing_newline\" not in result : # NOTE: we want to keep trailing newlines in templates as this is what a # user will most likely expects as a default. # See https://github.com/copier-org/copier/issues/464 result [ \"keep_trailing_newline\" ] = True return result exclude () \u00b6 Get exclusions specified in the template, or default ones. See exclude . Source code in copier/template.py 287 288 289 290 291 292 293 @cached_property def exclude ( self ) -> Tuple [ str , ... ]: \"\"\"Get exclusions specified in the template, or default ones. See [exclude][]. \"\"\" return tuple ( self . config_data . get ( \"exclude\" , DEFAULT_EXCLUDE )) jinja_extensions () \u00b6 Get Jinja2 extensions specified in the template, or () . See jinja_extensions . Source code in copier/template.py 295 296 297 298 299 300 301 @cached_property def jinja_extensions ( self ) -> Tuple [ str , ... ]: \"\"\"Get Jinja2 extensions specified in the template, or `()`. See [jinja_extensions][]. \"\"\" return tuple ( self . config_data . get ( \"jinja_extensions\" , ())) local_abspath () \u00b6 Get the absolute path to the template on disk. This may clone it if url points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied. Source code in copier/template.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 @cached_property def local_abspath ( self ) -> Path : \"\"\"Get the absolute path to the template on disk. This may clone it if `url` points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied. \"\"\" result = Path ( self . url ) if self . vcs == \"git\" : result = Path ( clone ( self . url_expanded , self . ref )) if self . ref is None : checkout_latest_tag ( result , self . use_prereleases ) if not result . is_dir (): raise ValueError ( \"Local template must be a directory.\" ) return result . absolute () metadata () \u00b6 Get template metadata. This data, if any, should be saved in the answers file to be able to restore the template to this same state. Source code in copier/template.py 303 304 305 306 307 308 309 310 311 312 313 @cached_property def metadata ( self ) -> AnyByStrDict : \"\"\"Get template metadata. This data, if any, should be saved in the answers file to be able to restore the template to this same state. \"\"\" result : AnyByStrDict = { \"_src_path\" : self . url } if self . commit : result [ \"_commit\" ] = self . commit return result migration_tasks ( stage , from_template ) \u00b6 Get migration objects that match current version spec. Versions are compared using PEP 440. See migrations . Parameters: Name Type Description Default stage Literal [ before , after ] A valid stage name to find tasks for. required from_template Template Original template, from which we are migrating. required Source code in copier/template.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def migration_tasks ( self , stage : Literal [ \"before\" , \"after\" ], from_template : \"Template\" ) -> Sequence [ Task ]: \"\"\"Get migration objects that match current version spec. Versions are compared using PEP 440. See [migrations][]. Args: stage: A valid stage name to find tasks for. from_template: Original template, from which we are migrating. \"\"\" result : List [ Task ] = [] if not ( self . version and from_template . version ): return result extra_env : Env = { \"STAGE\" : stage , \"VERSION_FROM\" : str ( from_template . commit ), \"VERSION_TO\" : str ( self . commit ), \"VERSION_PEP440_FROM\" : str ( from_template . version ), \"VERSION_PEP440_TO\" : str ( self . version ), } migration : dict for migration in self . _raw_config . get ( \"_migrations\" , []): current = parse ( migration [ \"version\" ]) if self . version >= current > from_template . version : extra_env = { ** extra_env , \"VERSION_CURRENT\" : migration [ \"version\" ], \"VERSION_PEP440_CURRENT\" : str ( current ), } for cmd in migration . get ( stage , []): result . append ( Task ( cmd = cmd , extra_env = extra_env )) return result min_copier_version () \u00b6 Gets minimal copier version for the template and validates it. See min_copier_version . Source code in copier/template.py 351 352 353 354 355 356 357 358 359 360 @cached_property def min_copier_version ( self ) -> Optional [ Version ]: \"\"\"Gets minimal copier version for the template and validates it. See [min_copier_version][]. \"\"\" try : return Version ( self . config_data [ \"min_copier_version\" ]) except KeyError : return None questions_data () \u00b6 Get questions from the template. See questions . Source code in copier/template.py 362 363 364 365 366 367 368 @cached_property def questions_data ( self ) -> AnyByStrDict : \"\"\"Get questions from the template. See [questions][]. \"\"\" return filter_config ( self . _raw_config )[ 1 ] secret_questions () \u00b6 Get names of secret questions from the template. These questions shouldn't be saved into the answers file. Source code in copier/template.py 370 371 372 373 374 375 376 377 378 379 380 @cached_property def secret_questions ( self ) -> Set [ str ]: \"\"\"Get names of secret questions from the template. These questions shouldn't be saved into the answers file. \"\"\" result = set ( self . config_data . get ( \"secret_questions\" , {})) for key , value in self . questions_data . items (): if value . get ( \"secret\" ): result . add ( key ) return result skip_if_exists () \u00b6 Get skip patterns from the template. These files will never be rewritten when rendering the template. See skip_if_exists . Source code in copier/template.py 382 383 384 385 386 387 388 389 390 @cached_property def skip_if_exists ( self ) -> StrSeq : \"\"\"Get skip patterns from the template. These files will never be rewritten when rendering the template. See [skip_if_exists][]. \"\"\" return self . config_data . get ( \"skip_if_exists\" , ()) subdirectory () \u00b6 Get the subdirectory as specified in the template. The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc. See subdirectory . Source code in copier/template.py 392 393 394 395 396 397 398 399 400 401 402 @cached_property def subdirectory ( self ) -> str : \"\"\"Get the subdirectory as specified in the template. The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc. See [subdirectory][]. \"\"\" return self . config_data . get ( \"subdirectory\" , \"\" ) tasks () \u00b6 Get tasks defined in the template. See tasks . Source code in copier/template.py 404 405 406 407 408 409 410 411 412 413 @cached_property def tasks ( self ) -> Sequence [ Task ]: \"\"\"Get tasks defined in the template. See [tasks][]. \"\"\" return [ Task ( cmd = cmd , extra_env = { \"STAGE\" : \"task\" }) for cmd in self . config_data . get ( \"tasks\" , []) ] templates_suffix () \u00b6 Get the suffix defined for templates. By default: .jinja . See templates_suffix . Source code in copier/template.py 415 416 417 418 419 420 421 422 423 424 425 426 @cached_property def templates_suffix ( self ) -> str : \"\"\"Get the suffix defined for templates. By default: `.jinja`. See [templates_suffix][]. \"\"\" result = self . config_data . get ( \"templates_suffix\" ) if result is None : return DEFAULT_TEMPLATES_SUFFIX return result url_expanded () \u00b6 Get usable URL. url can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly. Source code in copier/template.py 444 445 446 447 448 449 450 451 452 @cached_property def url_expanded ( self ) -> str : \"\"\"Get usable URL. `url` can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly. \"\"\" return get_repo ( self . url ) or self . url vcs () \u00b6 Get VCS system used by the template, if any. Source code in copier/template.py 478 479 480 481 482 @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"Get VCS system used by the template, if any.\"\"\" if get_repo ( self . url ): return \"git\" version () \u00b6 PEP440-compliant version object. Source code in copier/template.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 @cached_property def version ( self ) -> Optional [ Version ]: \"\"\"PEP440-compliant version object.\"\"\" if self . vcs != \"git\" or not self . commit : return None try : with local . cwd ( self . local_abspath ): # Leverage dunamai by default; usually it gets best results return Version ( dunamai . Version . from_git () . serialize ( style = dunamai . Style . Pep440 ) ) except ValueError : # A fully descriptive commit can be easily detected converted into a # PEP440 version, because it has the format \"<tag>-<count>-g<hash>\" if re . match ( r \"^.+-\\d+-g\\w+$\" , self . commit ): base , count , git_hash = self . commit . rsplit ( \"-\" , 2 ) return Version ( f \" { base } .post { count } + { git_hash } \" ) # If we get here, the commit string is a tag try : return Version ( self . commit ) except packaging . version . InvalidVersion : # appears to not be a version return None filter_config ( data ) \u00b6 Separates config and questions data. Source code in copier/template.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def filter_config ( data : AnyByStrDict ) -> Tuple [ AnyByStrDict , AnyByStrDict ]: \"\"\"Separates config and questions data.\"\"\" conf_data : AnyByStrDict = { \"secret_questions\" : set ()} questions_data = {} for k , v in data . items (): if k == \"_secret_questions\" : conf_data [ \"secret_questions\" ] . update ( v ) elif k . startswith ( \"_\" ): conf_data [ k [ 1 :]] = v else : # Transform simplified questions format into complex if not isinstance ( v , dict ): v = { \"default\" : v } questions_data [ k ] = v if v . get ( \"secret\" ): conf_data [ \"secret_questions\" ] . add ( k ) return conf_data , questions_data load_template_config ( conf_path , quiet = False ) \u00b6 Load the copier.yml file. This is like a simple YAML load, but applying all specific quirks needed for the copier.yml file . For example, it supports the !include tag with glob includes, and merges multiple sections. Parameters: Name Type Description Default conf_path Path The path to the copier.yml file. required quiet bool Used to configure the exception. False Raises: Type Description InvalidConfigFileError When the file is formatted badly. Source code in copier/template.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def load_template_config ( conf_path : Path , quiet : bool = False ) -> AnyByStrDict : \"\"\"Load the `copier.yml` file. This is like a simple YAML load, but applying all specific quirks needed for [the `copier.yml` file][the-copieryml-file]. For example, it supports the `!include` tag with glob includes, and merges multiple sections. Params: conf_path: The path to the `copier.yml` file. quiet: Used to configure the exception. Raises: InvalidConfigFileError: When the file is formatted badly. \"\"\" YamlIncludeConstructor . add_to_loader_class ( loader_class = yaml . FullLoader , base_dir = conf_path . parent ) try : with open ( conf_path ) as f : flattened_result = deepflatten ( yaml . load_all ( f , Loader = yaml . FullLoader ), depth = 2 , types = ( list ,), ) return dict ( ChainMap ( * reversed ( list ( flattened_result )))) except yaml . parser . ParserError as e : raise InvalidConfigFileError ( conf_path , quiet ) from e verify_copier_version ( version_str ) \u00b6 Raise an error if the current Copier version is less than the given version. Parameters: Name Type Description Default version_str str Minimal copier version for the template. required Source code in copier/template.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def verify_copier_version ( version_str : str ) -> None : \"\"\"Raise an error if the current Copier version is less than the given version. Args: version_str: Minimal copier version for the template. \"\"\" installed_version = copier_version () # Disable check when running copier as editable installation if installed_version == Version ( \"0.0.0\" ): warn ( \"Cannot check Copier version constraint.\" , UnknownCopierVersionWarning , ) return parsed_min = Version ( version_str ) if installed_version < parsed_min : raise UnsupportedVersionError ( f \"This template requires Copier version >= { version_str } , \" f \"while your version of Copier is { installed_version } .\" ) if installed_version . major > parsed_min . major : warn ( f \"This template was designed for Copier { version_str } , \" f \"but your version of Copier is { installed_version } . \" f \"You could find some incompatibilities.\" , OldTemplateWarning , )","title":"template.py"},{"location":"reference/template/#copier.template.Task","text":"Object that represents a task to execute. Attributes: Name Type Description cmd Union [ str , Sequence [ str ]] Command to execute. extra_env Env Additional environment variables to set while executing the command. Source code in copier/template.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @dataclass class Task : \"\"\"Object that represents a task to execute. Attributes: cmd: Command to execute. extra_env: Additional environment variables to set while executing the command. \"\"\" cmd : Union [ str , Sequence [ str ]] extra_env : Env = field ( default_factory = dict )","title":"Task"},{"location":"reference/template/#copier.template.Template","text":"Object that represents a template and its current state. See configuring a template . Attributes: Name Type Description url str Absolute origin that points to the template. It can be: A local path. A Git url. Note: if something fails, prefix the URL with git+ . ref OptStr The tag to checkout in the template. Only used if url points to a VCS-tracked template. If None , then it will checkout the latest tag, sorted by PEP440. Otherwise it will checkout the reference used here. Usually it should be a tag, or None . use_prereleases bool When True , the template's latest release will consider prereleases. Only used if: url points to a VCS-tracked template ref is None . Helpful if you want to test templates before doing a proper release, but you need some features that require a proper PEP440 version identifier. Source code in copier/template.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 @dataclass class Template : \"\"\"Object that represents a template and its current state. See [configuring a template][configuring-a-template]. Attributes: url: Absolute origin that points to the template. It can be: - A local path. - A Git url. Note: if something fails, prefix the URL with `git+`. ref: The tag to checkout in the template. Only used if `url` points to a VCS-tracked template. If `None`, then it will checkout the latest tag, sorted by PEP440. Otherwise it will checkout the reference used here. Usually it should be a tag, or `None`. use_prereleases: When `True`, the template's *latest* release will consider prereleases. Only used if: - `url` points to a VCS-tracked template - `ref` is `None`. Helpful if you want to test templates before doing a proper release, but you need some features that require a proper PEP440 version identifier. \"\"\" url : str ref : OptStr = None use_prereleases : bool = False def _cleanup ( self ) -> None : temp_clone = self . _temp_clone if temp_clone : rmtree ( temp_clone , ignore_errors = False , onerror = handle_remove_readonly , ) @property def _temp_clone ( self ) -> Optional [ Path ]: clone_path = self . local_abspath original_path = Path ( self . url ) . expanduser () with suppress ( OSError ): # triggered for URLs on Windows original_path = original_path . resolve () if clone_path != original_path : return clone_path return None @cached_property def _raw_config ( self ) -> AnyByStrDict : \"\"\"Get template configuration, raw. It reads [the `copier.yml` file][the-copieryml-file]. \"\"\" conf_paths = [ p for p in self . local_abspath . glob ( \"copier.*\" ) if p . is_file () and re . match ( r \"\\.ya?ml\" , p . suffix , re . I ) ] if len ( conf_paths ) > 1 : raise MultipleConfigFilesError ( conf_paths ) elif len ( conf_paths ) == 1 : return load_template_config ( conf_paths [ 0 ]) return {} @cached_property def answers_relpath ( self ) -> Path : \"\"\"Get the answers file relative path, as specified in the template. If not specified, returns the default `.copier-answers.yml`. See [answers_file][]. \"\"\" result = Path ( self . config_data . get ( \"answers_file\" , \".copier-answers.yml\" )) assert not result . is_absolute () return result @cached_property def commit ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit description.\"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return git ( \"describe\" , \"--tags\" , \"--always\" ) . strip () @cached_property def commit_hash ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit full hash.\"\"\" if self . vcs == \"git\" : return git ( \"-C\" , self . local_abspath , \"rev-parse\" , \"HEAD\" ) . strip () @cached_property def config_data ( self ) -> AnyByStrDict : \"\"\"Get config from the template. It reads [the `copier.yml` file][the-copieryml-file] to get its [settings][available-settings]. \"\"\" result = filter_config ( self . _raw_config )[ 0 ] with suppress ( KeyError ): verify_copier_version ( result [ \"min_copier_version\" ]) return result @cached_property def default_answers ( self ) -> AnyByStrDict : \"\"\"Get default answers for template's questions.\"\"\" return { key : value . get ( \"default\" ) for key , value in self . questions_data . items ()} @cached_property def envops ( self ) -> Mapping : \"\"\"Get the Jinja configuration specified in the template, or default values. See [envops][]. \"\"\" result = self . config_data . get ( \"envops\" , {}) if \"keep_trailing_newline\" not in result : # NOTE: we want to keep trailing newlines in templates as this is what a # user will most likely expects as a default. # See https://github.com/copier-org/copier/issues/464 result [ \"keep_trailing_newline\" ] = True return result @cached_property def exclude ( self ) -> Tuple [ str , ... ]: \"\"\"Get exclusions specified in the template, or default ones. See [exclude][]. \"\"\" return tuple ( self . config_data . get ( \"exclude\" , DEFAULT_EXCLUDE )) @cached_property def jinja_extensions ( self ) -> Tuple [ str , ... ]: \"\"\"Get Jinja2 extensions specified in the template, or `()`. See [jinja_extensions][]. \"\"\" return tuple ( self . config_data . get ( \"jinja_extensions\" , ())) @cached_property def metadata ( self ) -> AnyByStrDict : \"\"\"Get template metadata. This data, if any, should be saved in the answers file to be able to restore the template to this same state. \"\"\" result : AnyByStrDict = { \"_src_path\" : self . url } if self . commit : result [ \"_commit\" ] = self . commit return result def migration_tasks ( self , stage : Literal [ \"before\" , \"after\" ], from_template : \"Template\" ) -> Sequence [ Task ]: \"\"\"Get migration objects that match current version spec. Versions are compared using PEP 440. See [migrations][]. Args: stage: A valid stage name to find tasks for. from_template: Original template, from which we are migrating. \"\"\" result : List [ Task ] = [] if not ( self . version and from_template . version ): return result extra_env : Env = { \"STAGE\" : stage , \"VERSION_FROM\" : str ( from_template . commit ), \"VERSION_TO\" : str ( self . commit ), \"VERSION_PEP440_FROM\" : str ( from_template . version ), \"VERSION_PEP440_TO\" : str ( self . version ), } migration : dict for migration in self . _raw_config . get ( \"_migrations\" , []): current = parse ( migration [ \"version\" ]) if self . version >= current > from_template . version : extra_env = { ** extra_env , \"VERSION_CURRENT\" : migration [ \"version\" ], \"VERSION_PEP440_CURRENT\" : str ( current ), } for cmd in migration . get ( stage , []): result . append ( Task ( cmd = cmd , extra_env = extra_env )) return result @cached_property def min_copier_version ( self ) -> Optional [ Version ]: \"\"\"Gets minimal copier version for the template and validates it. See [min_copier_version][]. \"\"\" try : return Version ( self . config_data [ \"min_copier_version\" ]) except KeyError : return None @cached_property def questions_data ( self ) -> AnyByStrDict : \"\"\"Get questions from the template. See [questions][]. \"\"\" return filter_config ( self . _raw_config )[ 1 ] @cached_property def secret_questions ( self ) -> Set [ str ]: \"\"\"Get names of secret questions from the template. These questions shouldn't be saved into the answers file. \"\"\" result = set ( self . config_data . get ( \"secret_questions\" , {})) for key , value in self . questions_data . items (): if value . get ( \"secret\" ): result . add ( key ) return result @cached_property def skip_if_exists ( self ) -> StrSeq : \"\"\"Get skip patterns from the template. These files will never be rewritten when rendering the template. See [skip_if_exists][]. \"\"\" return self . config_data . get ( \"skip_if_exists\" , ()) @cached_property def subdirectory ( self ) -> str : \"\"\"Get the subdirectory as specified in the template. The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc. See [subdirectory][]. \"\"\" return self . config_data . get ( \"subdirectory\" , \"\" ) @cached_property def tasks ( self ) -> Sequence [ Task ]: \"\"\"Get tasks defined in the template. See [tasks][]. \"\"\" return [ Task ( cmd = cmd , extra_env = { \"STAGE\" : \"task\" }) for cmd in self . config_data . get ( \"tasks\" , []) ] @cached_property def templates_suffix ( self ) -> str : \"\"\"Get the suffix defined for templates. By default: `.jinja`. See [templates_suffix][]. \"\"\" result = self . config_data . get ( \"templates_suffix\" ) if result is None : return DEFAULT_TEMPLATES_SUFFIX return result @cached_property def local_abspath ( self ) -> Path : \"\"\"Get the absolute path to the template on disk. This may clone it if `url` points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied. \"\"\" result = Path ( self . url ) if self . vcs == \"git\" : result = Path ( clone ( self . url_expanded , self . ref )) if self . ref is None : checkout_latest_tag ( result , self . use_prereleases ) if not result . is_dir (): raise ValueError ( \"Local template must be a directory.\" ) return result . absolute () @cached_property def url_expanded ( self ) -> str : \"\"\"Get usable URL. `url` can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly. \"\"\" return get_repo ( self . url ) or self . url @cached_property def version ( self ) -> Optional [ Version ]: \"\"\"PEP440-compliant version object.\"\"\" if self . vcs != \"git\" or not self . commit : return None try : with local . cwd ( self . local_abspath ): # Leverage dunamai by default; usually it gets best results return Version ( dunamai . Version . from_git () . serialize ( style = dunamai . Style . Pep440 ) ) except ValueError : # A fully descriptive commit can be easily detected converted into a # PEP440 version, because it has the format \"<tag>-<count>-g<hash>\" if re . match ( r \"^.+-\\d+-g\\w+$\" , self . commit ): base , count , git_hash = self . commit . rsplit ( \"-\" , 2 ) return Version ( f \" { base } .post { count } + { git_hash } \" ) # If we get here, the commit string is a tag try : return Version ( self . commit ) except packaging . version . InvalidVersion : # appears to not be a version return None @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"Get VCS system used by the template, if any.\"\"\" if get_repo ( self . url ): return \"git\"","title":"Template"},{"location":"reference/template/#copier.template.Template.answers_relpath","text":"Get the answers file relative path, as specified in the template. If not specified, returns the default .copier-answers.yml . See answers_file . Source code in copier/template.py 231 232 233 234 235 236 237 238 239 240 241 @cached_property def answers_relpath ( self ) -> Path : \"\"\"Get the answers file relative path, as specified in the template. If not specified, returns the default `.copier-answers.yml`. See [answers_file][]. \"\"\" result = Path ( self . config_data . get ( \"answers_file\" , \".copier-answers.yml\" )) assert not result . is_absolute () return result","title":"answers_relpath()"},{"location":"reference/template/#copier.template.Template.commit","text":"If the template is VCS-tracked, get its commit description. Source code in copier/template.py 243 244 245 246 247 248 @cached_property def commit ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit description.\"\"\" if self . vcs == \"git\" : with local . cwd ( self . local_abspath ): return git ( \"describe\" , \"--tags\" , \"--always\" ) . strip ()","title":"commit()"},{"location":"reference/template/#copier.template.Template.commit_hash","text":"If the template is VCS-tracked, get its commit full hash. Source code in copier/template.py 250 251 252 253 254 @cached_property def commit_hash ( self ) -> OptStr : \"\"\"If the template is VCS-tracked, get its commit full hash.\"\"\" if self . vcs == \"git\" : return git ( \"-C\" , self . local_abspath , \"rev-parse\" , \"HEAD\" ) . strip ()","title":"commit_hash()"},{"location":"reference/template/#copier.template.Template.config_data","text":"Get config from the template. It reads the copier.yml file to get its settings . Source code in copier/template.py 256 257 258 259 260 261 262 263 264 265 266 @cached_property def config_data ( self ) -> AnyByStrDict : \"\"\"Get config from the template. It reads [the `copier.yml` file][the-copieryml-file] to get its [settings][available-settings]. \"\"\" result = filter_config ( self . _raw_config )[ 0 ] with suppress ( KeyError ): verify_copier_version ( result [ \"min_copier_version\" ]) return result","title":"config_data()"},{"location":"reference/template/#copier.template.Template.default_answers","text":"Get default answers for template's questions. Source code in copier/template.py 268 269 270 271 @cached_property def default_answers ( self ) -> AnyByStrDict : \"\"\"Get default answers for template's questions.\"\"\" return { key : value . get ( \"default\" ) for key , value in self . questions_data . items ()}","title":"default_answers()"},{"location":"reference/template/#copier.template.Template.envops","text":"Get the Jinja configuration specified in the template, or default values. See envops . Source code in copier/template.py 273 274 275 276 277 278 279 280 281 282 283 284 285 @cached_property def envops ( self ) -> Mapping : \"\"\"Get the Jinja configuration specified in the template, or default values. See [envops][]. \"\"\" result = self . config_data . get ( \"envops\" , {}) if \"keep_trailing_newline\" not in result : # NOTE: we want to keep trailing newlines in templates as this is what a # user will most likely expects as a default. # See https://github.com/copier-org/copier/issues/464 result [ \"keep_trailing_newline\" ] = True return result","title":"envops()"},{"location":"reference/template/#copier.template.Template.exclude","text":"Get exclusions specified in the template, or default ones. See exclude . Source code in copier/template.py 287 288 289 290 291 292 293 @cached_property def exclude ( self ) -> Tuple [ str , ... ]: \"\"\"Get exclusions specified in the template, or default ones. See [exclude][]. \"\"\" return tuple ( self . config_data . get ( \"exclude\" , DEFAULT_EXCLUDE ))","title":"exclude()"},{"location":"reference/template/#copier.template.Template.jinja_extensions","text":"Get Jinja2 extensions specified in the template, or () . See jinja_extensions . Source code in copier/template.py 295 296 297 298 299 300 301 @cached_property def jinja_extensions ( self ) -> Tuple [ str , ... ]: \"\"\"Get Jinja2 extensions specified in the template, or `()`. See [jinja_extensions][]. \"\"\" return tuple ( self . config_data . get ( \"jinja_extensions\" , ()))","title":"jinja_extensions()"},{"location":"reference/template/#copier.template.Template.local_abspath","text":"Get the absolute path to the template on disk. This may clone it if url points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied. Source code in copier/template.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 @cached_property def local_abspath ( self ) -> Path : \"\"\"Get the absolute path to the template on disk. This may clone it if `url` points to a VCS-tracked template. Dirty changes for local VCS-tracked templates will be copied. \"\"\" result = Path ( self . url ) if self . vcs == \"git\" : result = Path ( clone ( self . url_expanded , self . ref )) if self . ref is None : checkout_latest_tag ( result , self . use_prereleases ) if not result . is_dir (): raise ValueError ( \"Local template must be a directory.\" ) return result . absolute ()","title":"local_abspath()"},{"location":"reference/template/#copier.template.Template.metadata","text":"Get template metadata. This data, if any, should be saved in the answers file to be able to restore the template to this same state. Source code in copier/template.py 303 304 305 306 307 308 309 310 311 312 313 @cached_property def metadata ( self ) -> AnyByStrDict : \"\"\"Get template metadata. This data, if any, should be saved in the answers file to be able to restore the template to this same state. \"\"\" result : AnyByStrDict = { \"_src_path\" : self . url } if self . commit : result [ \"_commit\" ] = self . commit return result","title":"metadata()"},{"location":"reference/template/#copier.template.Template.migration_tasks","text":"Get migration objects that match current version spec. Versions are compared using PEP 440. See migrations . Parameters: Name Type Description Default stage Literal [ before , after ] A valid stage name to find tasks for. required from_template Template Original template, from which we are migrating. required Source code in copier/template.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def migration_tasks ( self , stage : Literal [ \"before\" , \"after\" ], from_template : \"Template\" ) -> Sequence [ Task ]: \"\"\"Get migration objects that match current version spec. Versions are compared using PEP 440. See [migrations][]. Args: stage: A valid stage name to find tasks for. from_template: Original template, from which we are migrating. \"\"\" result : List [ Task ] = [] if not ( self . version and from_template . version ): return result extra_env : Env = { \"STAGE\" : stage , \"VERSION_FROM\" : str ( from_template . commit ), \"VERSION_TO\" : str ( self . commit ), \"VERSION_PEP440_FROM\" : str ( from_template . version ), \"VERSION_PEP440_TO\" : str ( self . version ), } migration : dict for migration in self . _raw_config . get ( \"_migrations\" , []): current = parse ( migration [ \"version\" ]) if self . version >= current > from_template . version : extra_env = { ** extra_env , \"VERSION_CURRENT\" : migration [ \"version\" ], \"VERSION_PEP440_CURRENT\" : str ( current ), } for cmd in migration . get ( stage , []): result . append ( Task ( cmd = cmd , extra_env = extra_env )) return result","title":"migration_tasks()"},{"location":"reference/template/#copier.template.Template.min_copier_version","text":"Gets minimal copier version for the template and validates it. See min_copier_version . Source code in copier/template.py 351 352 353 354 355 356 357 358 359 360 @cached_property def min_copier_version ( self ) -> Optional [ Version ]: \"\"\"Gets minimal copier version for the template and validates it. See [min_copier_version][]. \"\"\" try : return Version ( self . config_data [ \"min_copier_version\" ]) except KeyError : return None","title":"min_copier_version()"},{"location":"reference/template/#copier.template.Template.questions_data","text":"Get questions from the template. See questions . Source code in copier/template.py 362 363 364 365 366 367 368 @cached_property def questions_data ( self ) -> AnyByStrDict : \"\"\"Get questions from the template. See [questions][]. \"\"\" return filter_config ( self . _raw_config )[ 1 ]","title":"questions_data()"},{"location":"reference/template/#copier.template.Template.secret_questions","text":"Get names of secret questions from the template. These questions shouldn't be saved into the answers file. Source code in copier/template.py 370 371 372 373 374 375 376 377 378 379 380 @cached_property def secret_questions ( self ) -> Set [ str ]: \"\"\"Get names of secret questions from the template. These questions shouldn't be saved into the answers file. \"\"\" result = set ( self . config_data . get ( \"secret_questions\" , {})) for key , value in self . questions_data . items (): if value . get ( \"secret\" ): result . add ( key ) return result","title":"secret_questions()"},{"location":"reference/template/#copier.template.Template.skip_if_exists","text":"Get skip patterns from the template. These files will never be rewritten when rendering the template. See skip_if_exists . Source code in copier/template.py 382 383 384 385 386 387 388 389 390 @cached_property def skip_if_exists ( self ) -> StrSeq : \"\"\"Get skip patterns from the template. These files will never be rewritten when rendering the template. See [skip_if_exists][]. \"\"\" return self . config_data . get ( \"skip_if_exists\" , ())","title":"skip_if_exists()"},{"location":"reference/template/#copier.template.Template.subdirectory","text":"Get the subdirectory as specified in the template. The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc. See subdirectory . Source code in copier/template.py 392 393 394 395 396 397 398 399 400 401 402 @cached_property def subdirectory ( self ) -> str : \"\"\"Get the subdirectory as specified in the template. The subdirectory points to the real template code, allowing the templater to separate it from other template assets, such as docs, tests, etc. See [subdirectory][]. \"\"\" return self . config_data . get ( \"subdirectory\" , \"\" )","title":"subdirectory()"},{"location":"reference/template/#copier.template.Template.tasks","text":"Get tasks defined in the template. See tasks . Source code in copier/template.py 404 405 406 407 408 409 410 411 412 413 @cached_property def tasks ( self ) -> Sequence [ Task ]: \"\"\"Get tasks defined in the template. See [tasks][]. \"\"\" return [ Task ( cmd = cmd , extra_env = { \"STAGE\" : \"task\" }) for cmd in self . config_data . get ( \"tasks\" , []) ]","title":"tasks()"},{"location":"reference/template/#copier.template.Template.templates_suffix","text":"Get the suffix defined for templates. By default: .jinja . See templates_suffix . Source code in copier/template.py 415 416 417 418 419 420 421 422 423 424 425 426 @cached_property def templates_suffix ( self ) -> str : \"\"\"Get the suffix defined for templates. By default: `.jinja`. See [templates_suffix][]. \"\"\" result = self . config_data . get ( \"templates_suffix\" ) if result is None : return DEFAULT_TEMPLATES_SUFFIX return result","title":"templates_suffix()"},{"location":"reference/template/#copier.template.Template.url_expanded","text":"Get usable URL. url can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly. Source code in copier/template.py 444 445 446 447 448 449 450 451 452 @cached_property def url_expanded ( self ) -> str : \"\"\"Get usable URL. `url` can be specified in shortcut format, which wouldn't be understood by the underlying VCS system. This property returns the expanded version, which should work properly. \"\"\" return get_repo ( self . url ) or self . url","title":"url_expanded()"},{"location":"reference/template/#copier.template.Template.vcs","text":"Get VCS system used by the template, if any. Source code in copier/template.py 478 479 480 481 482 @cached_property def vcs ( self ) -> Optional [ VCSTypes ]: \"\"\"Get VCS system used by the template, if any.\"\"\" if get_repo ( self . url ): return \"git\"","title":"vcs()"},{"location":"reference/template/#copier.template.Template.version","text":"PEP440-compliant version object. Source code in copier/template.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 @cached_property def version ( self ) -> Optional [ Version ]: \"\"\"PEP440-compliant version object.\"\"\" if self . vcs != \"git\" or not self . commit : return None try : with local . cwd ( self . local_abspath ): # Leverage dunamai by default; usually it gets best results return Version ( dunamai . Version . from_git () . serialize ( style = dunamai . Style . Pep440 ) ) except ValueError : # A fully descriptive commit can be easily detected converted into a # PEP440 version, because it has the format \"<tag>-<count>-g<hash>\" if re . match ( r \"^.+-\\d+-g\\w+$\" , self . commit ): base , count , git_hash = self . commit . rsplit ( \"-\" , 2 ) return Version ( f \" { base } .post { count } + { git_hash } \" ) # If we get here, the commit string is a tag try : return Version ( self . commit ) except packaging . version . InvalidVersion : # appears to not be a version return None","title":"version()"},{"location":"reference/template/#copier.template.filter_config","text":"Separates config and questions data. Source code in copier/template.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def filter_config ( data : AnyByStrDict ) -> Tuple [ AnyByStrDict , AnyByStrDict ]: \"\"\"Separates config and questions data.\"\"\" conf_data : AnyByStrDict = { \"secret_questions\" : set ()} questions_data = {} for k , v in data . items (): if k == \"_secret_questions\" : conf_data [ \"secret_questions\" ] . update ( v ) elif k . startswith ( \"_\" ): conf_data [ k [ 1 :]] = v else : # Transform simplified questions format into complex if not isinstance ( v , dict ): v = { \"default\" : v } questions_data [ k ] = v if v . get ( \"secret\" ): conf_data [ \"secret_questions\" ] . add ( k ) return conf_data , questions_data","title":"filter_config()"},{"location":"reference/template/#copier.template.load_template_config","text":"Load the copier.yml file. This is like a simple YAML load, but applying all specific quirks needed for the copier.yml file . For example, it supports the !include tag with glob includes, and merges multiple sections. Parameters: Name Type Description Default conf_path Path The path to the copier.yml file. required quiet bool Used to configure the exception. False Raises: Type Description InvalidConfigFileError When the file is formatted badly. Source code in copier/template.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def load_template_config ( conf_path : Path , quiet : bool = False ) -> AnyByStrDict : \"\"\"Load the `copier.yml` file. This is like a simple YAML load, but applying all specific quirks needed for [the `copier.yml` file][the-copieryml-file]. For example, it supports the `!include` tag with glob includes, and merges multiple sections. Params: conf_path: The path to the `copier.yml` file. quiet: Used to configure the exception. Raises: InvalidConfigFileError: When the file is formatted badly. \"\"\" YamlIncludeConstructor . add_to_loader_class ( loader_class = yaml . FullLoader , base_dir = conf_path . parent ) try : with open ( conf_path ) as f : flattened_result = deepflatten ( yaml . load_all ( f , Loader = yaml . FullLoader ), depth = 2 , types = ( list ,), ) return dict ( ChainMap ( * reversed ( list ( flattened_result )))) except yaml . parser . ParserError as e : raise InvalidConfigFileError ( conf_path , quiet ) from e","title":"load_template_config()"},{"location":"reference/template/#copier.template.verify_copier_version","text":"Raise an error if the current Copier version is less than the given version. Parameters: Name Type Description Default version_str str Minimal copier version for the template. required Source code in copier/template.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def verify_copier_version ( version_str : str ) -> None : \"\"\"Raise an error if the current Copier version is less than the given version. Args: version_str: Minimal copier version for the template. \"\"\" installed_version = copier_version () # Disable check when running copier as editable installation if installed_version == Version ( \"0.0.0\" ): warn ( \"Cannot check Copier version constraint.\" , UnknownCopierVersionWarning , ) return parsed_min = Version ( version_str ) if installed_version < parsed_min : raise UnsupportedVersionError ( f \"This template requires Copier version >= { version_str } , \" f \"while your version of Copier is { installed_version } .\" ) if installed_version . major > parsed_min . major : warn ( f \"This template was designed for Copier { version_str } , \" f \"but your version of Copier is { installed_version } . \" f \"You could find some incompatibilities.\" , OldTemplateWarning , )","title":"verify_copier_version()"},{"location":"reference/tools/","text":"Some utility functions. TemporaryDirectory \u00b6 Bases: tempfile . TemporaryDirectory A custom version of tempfile.TemporaryDirectory that handles read-only files better. On Windows, before Python 3.8, shutil.rmtree does not handle read-only files very well. This custom class makes use of a special error handler to make sure that a temporary directory containing read-only files (typically created when git-cloning a repository) is properly cleaned-up (i.e. removed) after using it in a context manager. Source code in copier/tools.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class TemporaryDirectory ( tempfile . TemporaryDirectory ): \"\"\"A custom version of `tempfile.TemporaryDirectory` that handles read-only files better. On Windows, before Python 3.8, `shutil.rmtree` does not handle read-only files very well. This custom class makes use of a [special error handler][copier.tools.handle_remove_readonly] to make sure that a temporary directory containing read-only files (typically created when git-cloning a repository) is properly cleaned-up (i.e. removed) after using it in a context manager. \"\"\" @classmethod def _cleanup ( cls , name , warn_message ): cls . _robust_cleanup ( name ) warnings . warn ( warn_message , ResourceWarning ) def cleanup ( self ): if self . _finalizer . detach (): self . _robust_cleanup ( self . name ) @staticmethod def _robust_cleanup ( name ): shutil . rmtree ( name , ignore_errors = False , onerror = handle_remove_readonly ) cast_str_to_bool ( value ) \u00b6 Parse anything to bool. Parameters: Name Type Description Default value Any Anything to be casted to a bool. Tries to be as smart as possible. Cast to number. Then: 0 = False; anything else = True. Find YAML booleans , YAML nulls or none in it and use it appropriately. Cast to boolean using standard python bool(value) . required Source code in copier/tools.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def cast_str_to_bool ( value : Any ) -> bool : \"\"\"Parse anything to bool. Params: value: Anything to be casted to a bool. Tries to be as smart as possible. 1. Cast to number. Then: 0 = False; anything else = True. 1. Find [YAML booleans](https://yaml.org/type/bool.html), [YAML nulls](https://yaml.org/type/null.html) or `none` in it and use it appropriately. 1. Cast to boolean using standard python `bool(value)`. \"\"\" # Assume it's a number with suppress ( TypeError , ValueError ): return bool ( float ( value )) # Assume it's a string with suppress ( AttributeError ): lower = value . lower () if lower in { \"y\" , \"yes\" , \"t\" , \"true\" , \"on\" }: return True elif lower in { \"n\" , \"no\" , \"f\" , \"false\" , \"off\" , \"~\" , \"null\" , \"none\" }: return False # Assume nothing return bool ( value ) copier_version () \u00b6 Get closest match for the installed copier version. Source code in copier/tools.py 44 45 46 47 48 49 50 51 52 53 54 55 def copier_version () -> Version : \"\"\"Get closest match for the installed copier version.\"\"\" # Importing __version__ at the top of the module creates a circular import # (\"cannot import name '__version__' from partially initialized module 'copier'\"), # so instead we do a lazy import here from . import __version__ if __version__ != \"0.0.0\" : return Version ( __version__ ) # Get the installed package version otherwise, which is sometimes more specific return Version ( version ( \"copier\" )) force_str_end ( original_str , end = ' \\n ' ) \u00b6 Make sure a original_str ends with end . Parameters: Name Type Description Default original_str str String that you want to ensure ending. required end str String that must exist at the end of original_str '\\n' Source code in copier/tools.py 120 121 122 123 124 125 126 127 128 129 def force_str_end ( original_str : str , end : str = \" \\n \" ) -> str : \"\"\"Make sure a `original_str` ends with `end`. Params: original_str: String that you want to ensure ending. end: String that must exist at the end of `original_str` \"\"\" if not original_str . endswith ( end ): return original_str + end return original_str handle_remove_readonly ( func , path , exc ) \u00b6 Handle errors when trying to remove read-only files through shutil.rmtree . This handler makes sure the given file is writable, then re-execute the given removal function. Parameters: Name Type Description Default func Callable An OS-dependant function used to remove a file. required path str The path to the file to remove. required exc Tuple [ BaseException , OSError , TracebackType ] A sys.exc_info() object. required Source code in copier/tools.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def handle_remove_readonly ( func : Callable , path : str , exc : Tuple [ BaseException , OSError , TracebackType ] ) -> None : \"\"\"Handle errors when trying to remove read-only files through `shutil.rmtree`. This handler makes sure the given file is writable, then re-execute the given removal function. Arguments: func: An OS-dependant function used to remove a file. path: The path to the file to remove. exc: A `sys.exc_info()` object. \"\"\" excvalue = exc [ 1 ] if func in ( os . rmdir , os . remove , os . unlink ) and excvalue . errno == errno . EACCES : os . chmod ( path , stat . S_IRWXU | stat . S_IRWXG | stat . S_IRWXO ) # 0777 func ( path ) else : raise","title":"tools.py"},{"location":"reference/tools/#copier.tools.TemporaryDirectory","text":"Bases: tempfile . TemporaryDirectory A custom version of tempfile.TemporaryDirectory that handles read-only files better. On Windows, before Python 3.8, shutil.rmtree does not handle read-only files very well. This custom class makes use of a special error handler to make sure that a temporary directory containing read-only files (typically created when git-cloning a repository) is properly cleaned-up (i.e. removed) after using it in a context manager. Source code in copier/tools.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class TemporaryDirectory ( tempfile . TemporaryDirectory ): \"\"\"A custom version of `tempfile.TemporaryDirectory` that handles read-only files better. On Windows, before Python 3.8, `shutil.rmtree` does not handle read-only files very well. This custom class makes use of a [special error handler][copier.tools.handle_remove_readonly] to make sure that a temporary directory containing read-only files (typically created when git-cloning a repository) is properly cleaned-up (i.e. removed) after using it in a context manager. \"\"\" @classmethod def _cleanup ( cls , name , warn_message ): cls . _robust_cleanup ( name ) warnings . warn ( warn_message , ResourceWarning ) def cleanup ( self ): if self . _finalizer . detach (): self . _robust_cleanup ( self . name ) @staticmethod def _robust_cleanup ( name ): shutil . rmtree ( name , ignore_errors = False , onerror = handle_remove_readonly )","title":"TemporaryDirectory"},{"location":"reference/tools/#copier.tools.cast_str_to_bool","text":"Parse anything to bool. Parameters: Name Type Description Default value Any Anything to be casted to a bool. Tries to be as smart as possible. Cast to number. Then: 0 = False; anything else = True. Find YAML booleans , YAML nulls or none in it and use it appropriately. Cast to boolean using standard python bool(value) . required Source code in copier/tools.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def cast_str_to_bool ( value : Any ) -> bool : \"\"\"Parse anything to bool. Params: value: Anything to be casted to a bool. Tries to be as smart as possible. 1. Cast to number. Then: 0 = False; anything else = True. 1. Find [YAML booleans](https://yaml.org/type/bool.html), [YAML nulls](https://yaml.org/type/null.html) or `none` in it and use it appropriately. 1. Cast to boolean using standard python `bool(value)`. \"\"\" # Assume it's a number with suppress ( TypeError , ValueError ): return bool ( float ( value )) # Assume it's a string with suppress ( AttributeError ): lower = value . lower () if lower in { \"y\" , \"yes\" , \"t\" , \"true\" , \"on\" }: return True elif lower in { \"n\" , \"no\" , \"f\" , \"false\" , \"off\" , \"~\" , \"null\" , \"none\" }: return False # Assume nothing return bool ( value )","title":"cast_str_to_bool()"},{"location":"reference/tools/#copier.tools.copier_version","text":"Get closest match for the installed copier version. Source code in copier/tools.py 44 45 46 47 48 49 50 51 52 53 54 55 def copier_version () -> Version : \"\"\"Get closest match for the installed copier version.\"\"\" # Importing __version__ at the top of the module creates a circular import # (\"cannot import name '__version__' from partially initialized module 'copier'\"), # so instead we do a lazy import here from . import __version__ if __version__ != \"0.0.0\" : return Version ( __version__ ) # Get the installed package version otherwise, which is sometimes more specific return Version ( version ( \"copier\" ))","title":"copier_version()"},{"location":"reference/tools/#copier.tools.force_str_end","text":"Make sure a original_str ends with end . Parameters: Name Type Description Default original_str str String that you want to ensure ending. required end str String that must exist at the end of original_str '\\n' Source code in copier/tools.py 120 121 122 123 124 125 126 127 128 129 def force_str_end ( original_str : str , end : str = \" \\n \" ) -> str : \"\"\"Make sure a `original_str` ends with `end`. Params: original_str: String that you want to ensure ending. end: String that must exist at the end of `original_str` \"\"\" if not original_str . endswith ( end ): return original_str + end return original_str","title":"force_str_end()"},{"location":"reference/tools/#copier.tools.handle_remove_readonly","text":"Handle errors when trying to remove read-only files through shutil.rmtree . This handler makes sure the given file is writable, then re-execute the given removal function. Parameters: Name Type Description Default func Callable An OS-dependant function used to remove a file. required path str The path to the file to remove. required exc Tuple [ BaseException , OSError , TracebackType ] A sys.exc_info() object. required Source code in copier/tools.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def handle_remove_readonly ( func : Callable , path : str , exc : Tuple [ BaseException , OSError , TracebackType ] ) -> None : \"\"\"Handle errors when trying to remove read-only files through `shutil.rmtree`. This handler makes sure the given file is writable, then re-execute the given removal function. Arguments: func: An OS-dependant function used to remove a file. path: The path to the file to remove. exc: A `sys.exc_info()` object. \"\"\" excvalue = exc [ 1 ] if func in ( os . rmdir , os . remove , os . unlink ) and excvalue . errno == errno . EACCES : os . chmod ( path , stat . S_IRWXU | stat . S_IRWXG | stat . S_IRWXO ) # 0777 func ( path ) else : raise","title":"handle_remove_readonly()"},{"location":"reference/types/","text":"Complex types, annotations, validators.","title":"types.py"},{"location":"reference/user_data/","text":"Functions used to load user data. AnswersMap \u00b6 Object that gathers answers from different sources. Attributes: Name Type Description local AnyByStrDict Local overrides to other answers. user AnyByStrDict Answers provided by the user, interactively. init AnyByStrDict Answers provided on init. This will hold those answers that come from --data in CLI mode. See data . metadata AnyByStrDict Data used to be able to reproduce the template. It comes from copier.template.Template.metadata . last AnyByStrDict Data from the answers file . default AnyByStrDict Default data from the template. See copier.template.Template.default_answers . user_defaults AnyByStrDict Default data from the user e.g. previously completed and restored data. See copier.main.Worker . Source code in copier/user_data.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @dataclass class AnswersMap : \"\"\"Object that gathers answers from different sources. Attributes: local: Local overrides to other answers. user: Answers provided by the user, interactively. init: Answers provided on init. This will hold those answers that come from `--data` in CLI mode. See [data][]. metadata: Data used to be able to reproduce the template. It comes from [copier.template.Template.metadata][]. last: Data from [the answers file][the-copier-answersyml-file]. default: Default data from the template. See [copier.template.Template.default_answers][]. user_defaults: Default data from the user e.g. previously completed and restored data. See [copier.main.Worker][]. \"\"\" # Private local : AnyByStrDict = field ( default_factory = dict , init = False ) # Public user : AnyByStrDict = field ( default_factory = dict ) init : AnyByStrDict = field ( default_factory = dict ) metadata : AnyByStrDict = field ( default_factory = dict ) last : AnyByStrDict = field ( default_factory = dict ) user_defaults : AnyByStrDict = field ( default_factory = dict ) default : AnyByStrDict = field ( default_factory = dict ) @cached_property def combined ( self ) -> t_ChainMap [ str , Any ]: \"\"\"Answers combined from different sources, sorted by priority.\"\"\" return ChainMap ( self . local , self . user , self . init , self . metadata , self . last , self . user_defaults , self . default , DEFAULT_DATA , ) def old_commit ( self ) -> OptStr : return self . last . get ( \"_commit\" ) combined () \u00b6 Answers combined from different sources, sorted by priority. Source code in copier/user_data.py 123 124 125 126 127 128 129 130 131 132 133 134 135 @cached_property def combined ( self ) -> t_ChainMap [ str , Any ]: \"\"\"Answers combined from different sources, sorted by priority.\"\"\" return ChainMap ( self . local , self . user , self . init , self . metadata , self . last , self . user_defaults , self . default , DEFAULT_DATA , ) Question \u00b6 One question asked to the user. All attributes are init kwargs. Attributes: Name Type Description choices Union [ Dict [ Any , Any ], Sequence [ Any ]] Selections available for the user if the question requires them. Can be templated. default Any Default value presented to the user to make it easier to respond. Can be templated. help str Additional text printed to the user, explaining the purpose of this question. Can be templated. multiline Union [ str , bool ] Indicates if the question should allow multiline input. Defaults to True for JSON and YAML questions, and to False otherwise. Only meaningful for str-based questions. Can be templated. placeholder str Text that appears if there's nothing written in the input field, but disappears as soon as the user writes anything. Can be templated. secret bool Indicates if the question should be removed from the answers file. If the question type is str, it will hide user input on the screen by displaying asterisks: **** . type_name bool The type of question. Affects the rendering, validation and filtering. Can be templated. var_name str Question name in the answers dict. validator str Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render nothing if the value is valid, and an error message to show to the user otherwise. when Union [ str , bool ] Condition that, if False , skips the question. Can be templated. If it is a boolean, it is used directly. If it is a str, it is converted to boolean using a parser similar to YAML, but only for boolean values. Source code in copier/user_data.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 @dataclass ( config = AllowArbitraryTypes ) class Question : \"\"\"One question asked to the user. All attributes are init kwargs. Attributes: choices: Selections available for the user if the question requires them. Can be templated. default: Default value presented to the user to make it easier to respond. Can be templated. help: Additional text printed to the user, explaining the purpose of this question. Can be templated. multiline: Indicates if the question should allow multiline input. Defaults to `True` for JSON and YAML questions, and to `False` otherwise. Only meaningful for str-based questions. Can be templated. placeholder: Text that appears if there's nothing written in the input field, but disappears as soon as the user writes anything. Can be templated. secret: Indicates if the question should be removed from the answers file. If the question type is str, it will hide user input on the screen by displaying asterisks: `****`. type_name: The type of question. Affects the rendering, validation and filtering. Can be templated. var_name: Question name in the answers dict. validator: Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render *nothing* if the value is valid, and an error message to show to the user otherwise. when: Condition that, if `False`, skips the question. Can be templated. If it is a boolean, it is used directly. If it is a str, it is converted to boolean using a parser similar to YAML, but only for boolean values. \"\"\" var_name : str answers : AnswersMap jinja_env : SandboxedEnvironment choices : Union [ Dict [ Any , Any ], Sequence [ Any ]] = field ( default_factory = list ) default : Any = None help : str = \"\" ask_user : bool = False multiline : Union [ str , bool ] = False placeholder : str = \"\" secret : bool = False type : str = \"\" validator : str = \"\" when : Union [ str , bool ] = True @pydantic_validator ( \"var_name\" ) def _check_var_name ( cls , v ): if v in DEFAULT_DATA : raise ValueError ( \"Invalid question name\" ) return v @pydantic_validator ( \"type\" , always = True ) def _check_type ( cls , v , values ): if v == \"\" : default_type_name = type ( values . get ( \"default\" )) . __name__ v = default_type_name if default_type_name in CAST_STR_TO_NATIVE else \"yaml\" return v def get_default ( self ) -> Any : \"\"\"Get the default value for this question, casted to its expected type.\"\"\" cast_fn = self . get_cast_fn () try : result = self . answers . init [ self . var_name ] except KeyError : try : result = self . answers . last [ self . var_name ] except KeyError : try : result = self . answers . user_defaults [ self . var_name ] except KeyError : result = self . render_value ( self . default ) result = cast_answer_type ( result , cast_fn ) return result def get_default_rendered ( self ) -> Union [ bool , str , Choice , None ]: \"\"\"Get default answer rendered for the questionary lib. The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa. This helper allows such usages. \"\"\" default = self . get_default () # If there are choices, return the one that matches the expressed default if self . choices : for choice in self . _formatted_choices : if choice . value == default : return choice return None # Yes/No questions expect and return bools if isinstance ( default , bool ) and self . get_type_name () == \"bool\" : return default # Emptiness is expressed as an empty str if default is None : return \"\" # JSON and YAML dumped depending on multiline setting if self . get_type_name () == \"json\" : return json . dumps ( default , indent = 2 if self . get_multiline () else None ) if self . get_type_name () == \"yaml\" : return yaml . safe_dump ( default , default_flow_style = not self . get_multiline (), width = 2147483647 ) . strip () # All other data has to be str return str ( default ) @cached_property def _formatted_choices ( self ) -> Sequence [ Choice ]: \"\"\"Obtain choices rendered and properly formatted.\"\"\" result = [] choices = self . choices if isinstance ( self . choices , dict ): choices = list ( self . choices . items ()) for choice in choices : # If a choice is a value pair if isinstance ( choice , ( tuple , list )): name , value = choice # If a choice is a single value else : name = value = choice # The name must always be a str name = str ( self . render_value ( name )) # The value can be templated value = self . render_value ( value ) result . append ( Choice ( name , value )) return result def filter_answer ( self , answer ) -> Any : \"\"\"Cast the answer to the desired type.\"\"\" if answer == self . get_default_rendered (): return self . get_default () return cast_answer_type ( answer , self . get_cast_fn ()) def get_message ( self ) -> str : \"\"\"Get the message that will be printed to the user.\"\"\" if self . help : rendered_help = self . render_value ( self . help ) if rendered_help : return force_str_end ( rendered_help ) + \" \" # Otherwise, there's no help message defined. message = self . var_name answer_type = self . get_type_name () if answer_type != \"str\" : message += f \" ( { answer_type } )\" return message + \" \\n \" def get_placeholder ( self ) -> str : \"\"\"Render and obtain the placeholder.\"\"\" return self . render_value ( self . placeholder ) def get_questionary_structure ( self ) -> AnyByStrDict : \"\"\"Get the question in a format that the questionary lib understands.\"\"\" lexer = None result : AnyByStrDict = { \"default\" : self . get_default_rendered (), \"filter\" : self . filter_answer , \"message\" : self . get_message (), \"mouse_support\" : True , \"name\" : self . var_name , \"qmark\" : \"\ud83d\udd75\ufe0f\" if self . secret else \"\ud83c\udfa4\" , \"when\" : self . get_when , } questionary_type = \"input\" type_name = self . get_type_name () if type_name == \"bool\" : questionary_type = \"confirm\" if self . choices : questionary_type = \"select\" result [ \"choices\" ] = self . _formatted_choices if questionary_type == \"input\" : if self . secret : questionary_type = \"password\" elif type_name == \"yaml\" : lexer = PygmentsLexer ( YamlLexer ) elif type_name == \"json\" : lexer = PygmentsLexer ( JsonLexer ) if lexer : result [ \"lexer\" ] = lexer result [ \"multiline\" ] = self . get_multiline () placeholder = self . get_placeholder () if placeholder : result [ \"placeholder\" ] = placeholder result [ \"validate\" ] = self . validate_answer result . update ({ \"type\" : questionary_type }) return result def get_cast_fn ( self ) -> Callable : \"\"\"Obtain function to cast user answer to desired type.\"\"\" type_name = self . get_type_name () if type_name not in CAST_STR_TO_NATIVE : raise InvalidTypeError ( \"Invalid question type\" ) return CAST_STR_TO_NATIVE . get ( type_name , parse_yaml_string ) def get_type_name ( self ) -> str : \"\"\"Render the type name and return it.\"\"\" return self . render_value ( self . type ) def get_multiline ( self ) -> bool : \"\"\"Get the value for multiline.\"\"\" multiline = self . render_value ( self . multiline ) multiline = cast_answer_type ( multiline , cast_str_to_bool ) return bool ( multiline ) def validate_answer ( self , answer ) -> bool : \"\"\"Validate user answer.\"\"\" cast_fn = self . get_cast_fn () try : ans = cast_fn ( answer ) except Exception : return False try : err_msg = self . render_value ( self . validator , { self . var_name : ans }) . strip () except Exception as error : raise ValidationError ( message = str ( error )) from error if err_msg : raise ValidationError ( message = err_msg ) return True def get_when ( self , answers ) -> bool : \"\"\"Get skip condition for question.\"\"\" if ( # Skip on --defaults not self . ask_user # Skip on --data=this_question=some_answer or self . var_name in self . answers . init ): return False when = self . when when = self . render_value ( when ) when = cast_answer_type ( when , cast_str_to_bool ) return bool ( when ) def render_value ( self , value : Any , extra_answers : Optional [ AnyByStrDict ] = None ) -> str : \"\"\"Render a single templated value using Jinja. If the value cannot be used as a template, it will be returned as is. `extra_answers` are combined self `self.answers.combined` when rendering the template. \"\"\" try : template = self . jinja_env . from_string ( value ) except TypeError : # value was not a string return value try : return template . render ({ ** self . answers . combined , ** ( extra_answers or {})}) except UndefinedError as error : raise UserMessageError ( str ( error )) from error filter_answer ( answer ) \u00b6 Cast the answer to the desired type. Source code in copier/user_data.py 290 291 292 293 294 def filter_answer ( self , answer ) -> Any : \"\"\"Cast the answer to the desired type.\"\"\" if answer == self . get_default_rendered (): return self . get_default () return cast_answer_type ( answer , self . get_cast_fn ()) get_cast_fn () \u00b6 Obtain function to cast user answer to desired type. Source code in copier/user_data.py 349 350 351 352 353 354 def get_cast_fn ( self ) -> Callable : \"\"\"Obtain function to cast user answer to desired type.\"\"\" type_name = self . get_type_name () if type_name not in CAST_STR_TO_NATIVE : raise InvalidTypeError ( \"Invalid question type\" ) return CAST_STR_TO_NATIVE . get ( type_name , parse_yaml_string ) get_default () \u00b6 Get the default value for this question, casted to its expected type. Source code in copier/user_data.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def get_default ( self ) -> Any : \"\"\"Get the default value for this question, casted to its expected type.\"\"\" cast_fn = self . get_cast_fn () try : result = self . answers . init [ self . var_name ] except KeyError : try : result = self . answers . last [ self . var_name ] except KeyError : try : result = self . answers . user_defaults [ self . var_name ] except KeyError : result = self . render_value ( self . default ) result = cast_answer_type ( result , cast_fn ) return result get_default_rendered () \u00b6 Get default answer rendered for the questionary lib. The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa. This helper allows such usages. Source code in copier/user_data.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def get_default_rendered ( self ) -> Union [ bool , str , Choice , None ]: \"\"\"Get default answer rendered for the questionary lib. The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa. This helper allows such usages. \"\"\" default = self . get_default () # If there are choices, return the one that matches the expressed default if self . choices : for choice in self . _formatted_choices : if choice . value == default : return choice return None # Yes/No questions expect and return bools if isinstance ( default , bool ) and self . get_type_name () == \"bool\" : return default # Emptiness is expressed as an empty str if default is None : return \"\" # JSON and YAML dumped depending on multiline setting if self . get_type_name () == \"json\" : return json . dumps ( default , indent = 2 if self . get_multiline () else None ) if self . get_type_name () == \"yaml\" : return yaml . safe_dump ( default , default_flow_style = not self . get_multiline (), width = 2147483647 ) . strip () # All other data has to be str return str ( default ) get_message () \u00b6 Get the message that will be printed to the user. Source code in copier/user_data.py 296 297 298 299 300 301 302 303 304 305 306 307 def get_message ( self ) -> str : \"\"\"Get the message that will be printed to the user.\"\"\" if self . help : rendered_help = self . render_value ( self . help ) if rendered_help : return force_str_end ( rendered_help ) + \" \" # Otherwise, there's no help message defined. message = self . var_name answer_type = self . get_type_name () if answer_type != \"str\" : message += f \" ( { answer_type } )\" return message + \" \\n \" get_multiline () \u00b6 Get the value for multiline. Source code in copier/user_data.py 360 361 362 363 364 def get_multiline ( self ) -> bool : \"\"\"Get the value for multiline.\"\"\" multiline = self . render_value ( self . multiline ) multiline = cast_answer_type ( multiline , cast_str_to_bool ) return bool ( multiline ) get_placeholder () \u00b6 Render and obtain the placeholder. Source code in copier/user_data.py 309 310 311 def get_placeholder ( self ) -> str : \"\"\"Render and obtain the placeholder.\"\"\" return self . render_value ( self . placeholder ) get_questionary_structure () \u00b6 Get the question in a format that the questionary lib understands. Source code in copier/user_data.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def get_questionary_structure ( self ) -> AnyByStrDict : \"\"\"Get the question in a format that the questionary lib understands.\"\"\" lexer = None result : AnyByStrDict = { \"default\" : self . get_default_rendered (), \"filter\" : self . filter_answer , \"message\" : self . get_message (), \"mouse_support\" : True , \"name\" : self . var_name , \"qmark\" : \"\ud83d\udd75\ufe0f\" if self . secret else \"\ud83c\udfa4\" , \"when\" : self . get_when , } questionary_type = \"input\" type_name = self . get_type_name () if type_name == \"bool\" : questionary_type = \"confirm\" if self . choices : questionary_type = \"select\" result [ \"choices\" ] = self . _formatted_choices if questionary_type == \"input\" : if self . secret : questionary_type = \"password\" elif type_name == \"yaml\" : lexer = PygmentsLexer ( YamlLexer ) elif type_name == \"json\" : lexer = PygmentsLexer ( JsonLexer ) if lexer : result [ \"lexer\" ] = lexer result [ \"multiline\" ] = self . get_multiline () placeholder = self . get_placeholder () if placeholder : result [ \"placeholder\" ] = placeholder result [ \"validate\" ] = self . validate_answer result . update ({ \"type\" : questionary_type }) return result get_type_name () \u00b6 Render the type name and return it. Source code in copier/user_data.py 356 357 358 def get_type_name ( self ) -> str : \"\"\"Render the type name and return it.\"\"\" return self . render_value ( self . type ) get_when ( answers ) \u00b6 Get skip condition for question. Source code in copier/user_data.py 382 383 384 385 386 387 388 389 390 391 392 393 394 def get_when ( self , answers ) -> bool : \"\"\"Get skip condition for question.\"\"\" if ( # Skip on --defaults not self . ask_user # Skip on --data=this_question=some_answer or self . var_name in self . answers . init ): return False when = self . when when = self . render_value ( when ) when = cast_answer_type ( when , cast_str_to_bool ) return bool ( when ) render_value ( value , extra_answers = None ) \u00b6 Render a single templated value using Jinja. If the value cannot be used as a template, it will be returned as is. extra_answers are combined self self.answers.combined when rendering the template. Source code in copier/user_data.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def render_value ( self , value : Any , extra_answers : Optional [ AnyByStrDict ] = None ) -> str : \"\"\"Render a single templated value using Jinja. If the value cannot be used as a template, it will be returned as is. `extra_answers` are combined self `self.answers.combined` when rendering the template. \"\"\" try : template = self . jinja_env . from_string ( value ) except TypeError : # value was not a string return value try : return template . render ({ ** self . answers . combined , ** ( extra_answers or {})}) except UndefinedError as error : raise UserMessageError ( str ( error )) from error validate_answer ( answer ) \u00b6 Validate user answer. Source code in copier/user_data.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def validate_answer ( self , answer ) -> bool : \"\"\"Validate user answer.\"\"\" cast_fn = self . get_cast_fn () try : ans = cast_fn ( answer ) except Exception : return False try : err_msg = self . render_value ( self . validator , { self . var_name : ans }) . strip () except Exception as error : raise ValidationError ( message = str ( error )) from error if err_msg : raise ValidationError ( message = err_msg ) return True cast_answer_type ( answer , type_fn ) \u00b6 Cast answer to expected type. Source code in copier/user_data.py 440 441 442 443 444 445 446 447 448 449 def cast_answer_type ( answer : Any , type_fn : Callable ) -> Any : \"\"\"Cast answer to expected type.\"\"\" # Skip casting None into \"None\" if type_fn is str and answer is None : return answer try : return type_fn ( answer ) except ( TypeError , AttributeError ): # JSON or YAML failed because it wasn't a string; no need to convert return answer load_answersfile_data ( dst_path , answers_file = None ) \u00b6 Load answers data from a $dst_path/$answers_file file if it exists. Source code in copier/user_data.py 428 429 430 431 432 433 434 435 436 437 def load_answersfile_data ( dst_path : StrOrPath , answers_file : OptStrOrPath = None , ) -> AnyByStrDict : \"\"\"Load answers data from a `$dst_path/$answers_file` file if it exists.\"\"\" try : with open ( Path ( dst_path ) / ( answers_file or \".copier-answers.yml\" )) as fd : return yaml . safe_load ( fd ) except FileNotFoundError : return {} parse_yaml_string ( string ) \u00b6 Parse a YAML string and raise a ValueError if parsing failed. This method is needed because :meth: prompt requires a ValueError to repeat failed questions. Source code in copier/user_data.py 416 417 418 419 420 421 422 423 424 425 def parse_yaml_string ( string : str ) -> Any : \"\"\"Parse a YAML string and raise a ValueError if parsing failed. This method is needed because :meth:`prompt` requires a ``ValueError`` to repeat failed questions. \"\"\" try : return yaml . safe_load ( string ) except yaml . error . YAMLError as error : raise ValueError ( str ( error ))","title":"user_data.py"},{"location":"reference/user_data/#copier.user_data.AnswersMap","text":"Object that gathers answers from different sources. Attributes: Name Type Description local AnyByStrDict Local overrides to other answers. user AnyByStrDict Answers provided by the user, interactively. init AnyByStrDict Answers provided on init. This will hold those answers that come from --data in CLI mode. See data . metadata AnyByStrDict Data used to be able to reproduce the template. It comes from copier.template.Template.metadata . last AnyByStrDict Data from the answers file . default AnyByStrDict Default data from the template. See copier.template.Template.default_answers . user_defaults AnyByStrDict Default data from the user e.g. previously completed and restored data. See copier.main.Worker . Source code in copier/user_data.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @dataclass class AnswersMap : \"\"\"Object that gathers answers from different sources. Attributes: local: Local overrides to other answers. user: Answers provided by the user, interactively. init: Answers provided on init. This will hold those answers that come from `--data` in CLI mode. See [data][]. metadata: Data used to be able to reproduce the template. It comes from [copier.template.Template.metadata][]. last: Data from [the answers file][the-copier-answersyml-file]. default: Default data from the template. See [copier.template.Template.default_answers][]. user_defaults: Default data from the user e.g. previously completed and restored data. See [copier.main.Worker][]. \"\"\" # Private local : AnyByStrDict = field ( default_factory = dict , init = False ) # Public user : AnyByStrDict = field ( default_factory = dict ) init : AnyByStrDict = field ( default_factory = dict ) metadata : AnyByStrDict = field ( default_factory = dict ) last : AnyByStrDict = field ( default_factory = dict ) user_defaults : AnyByStrDict = field ( default_factory = dict ) default : AnyByStrDict = field ( default_factory = dict ) @cached_property def combined ( self ) -> t_ChainMap [ str , Any ]: \"\"\"Answers combined from different sources, sorted by priority.\"\"\" return ChainMap ( self . local , self . user , self . init , self . metadata , self . last , self . user_defaults , self . default , DEFAULT_DATA , ) def old_commit ( self ) -> OptStr : return self . last . get ( \"_commit\" )","title":"AnswersMap"},{"location":"reference/user_data/#copier.user_data.AnswersMap.combined","text":"Answers combined from different sources, sorted by priority. Source code in copier/user_data.py 123 124 125 126 127 128 129 130 131 132 133 134 135 @cached_property def combined ( self ) -> t_ChainMap [ str , Any ]: \"\"\"Answers combined from different sources, sorted by priority.\"\"\" return ChainMap ( self . local , self . user , self . init , self . metadata , self . last , self . user_defaults , self . default , DEFAULT_DATA , )","title":"combined()"},{"location":"reference/user_data/#copier.user_data.Question","text":"One question asked to the user. All attributes are init kwargs. Attributes: Name Type Description choices Union [ Dict [ Any , Any ], Sequence [ Any ]] Selections available for the user if the question requires them. Can be templated. default Any Default value presented to the user to make it easier to respond. Can be templated. help str Additional text printed to the user, explaining the purpose of this question. Can be templated. multiline Union [ str , bool ] Indicates if the question should allow multiline input. Defaults to True for JSON and YAML questions, and to False otherwise. Only meaningful for str-based questions. Can be templated. placeholder str Text that appears if there's nothing written in the input field, but disappears as soon as the user writes anything. Can be templated. secret bool Indicates if the question should be removed from the answers file. If the question type is str, it will hide user input on the screen by displaying asterisks: **** . type_name bool The type of question. Affects the rendering, validation and filtering. Can be templated. var_name str Question name in the answers dict. validator str Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render nothing if the value is valid, and an error message to show to the user otherwise. when Union [ str , bool ] Condition that, if False , skips the question. Can be templated. If it is a boolean, it is used directly. If it is a str, it is converted to boolean using a parser similar to YAML, but only for boolean values. Source code in copier/user_data.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 @dataclass ( config = AllowArbitraryTypes ) class Question : \"\"\"One question asked to the user. All attributes are init kwargs. Attributes: choices: Selections available for the user if the question requires them. Can be templated. default: Default value presented to the user to make it easier to respond. Can be templated. help: Additional text printed to the user, explaining the purpose of this question. Can be templated. multiline: Indicates if the question should allow multiline input. Defaults to `True` for JSON and YAML questions, and to `False` otherwise. Only meaningful for str-based questions. Can be templated. placeholder: Text that appears if there's nothing written in the input field, but disappears as soon as the user writes anything. Can be templated. secret: Indicates if the question should be removed from the answers file. If the question type is str, it will hide user input on the screen by displaying asterisks: `****`. type_name: The type of question. Affects the rendering, validation and filtering. Can be templated. var_name: Question name in the answers dict. validator: Jinja template with which to validate the user input. This template will be rendered with the combined answers as variables; it should render *nothing* if the value is valid, and an error message to show to the user otherwise. when: Condition that, if `False`, skips the question. Can be templated. If it is a boolean, it is used directly. If it is a str, it is converted to boolean using a parser similar to YAML, but only for boolean values. \"\"\" var_name : str answers : AnswersMap jinja_env : SandboxedEnvironment choices : Union [ Dict [ Any , Any ], Sequence [ Any ]] = field ( default_factory = list ) default : Any = None help : str = \"\" ask_user : bool = False multiline : Union [ str , bool ] = False placeholder : str = \"\" secret : bool = False type : str = \"\" validator : str = \"\" when : Union [ str , bool ] = True @pydantic_validator ( \"var_name\" ) def _check_var_name ( cls , v ): if v in DEFAULT_DATA : raise ValueError ( \"Invalid question name\" ) return v @pydantic_validator ( \"type\" , always = True ) def _check_type ( cls , v , values ): if v == \"\" : default_type_name = type ( values . get ( \"default\" )) . __name__ v = default_type_name if default_type_name in CAST_STR_TO_NATIVE else \"yaml\" return v def get_default ( self ) -> Any : \"\"\"Get the default value for this question, casted to its expected type.\"\"\" cast_fn = self . get_cast_fn () try : result = self . answers . init [ self . var_name ] except KeyError : try : result = self . answers . last [ self . var_name ] except KeyError : try : result = self . answers . user_defaults [ self . var_name ] except KeyError : result = self . render_value ( self . default ) result = cast_answer_type ( result , cast_fn ) return result def get_default_rendered ( self ) -> Union [ bool , str , Choice , None ]: \"\"\"Get default answer rendered for the questionary lib. The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa. This helper allows such usages. \"\"\" default = self . get_default () # If there are choices, return the one that matches the expressed default if self . choices : for choice in self . _formatted_choices : if choice . value == default : return choice return None # Yes/No questions expect and return bools if isinstance ( default , bool ) and self . get_type_name () == \"bool\" : return default # Emptiness is expressed as an empty str if default is None : return \"\" # JSON and YAML dumped depending on multiline setting if self . get_type_name () == \"json\" : return json . dumps ( default , indent = 2 if self . get_multiline () else None ) if self . get_type_name () == \"yaml\" : return yaml . safe_dump ( default , default_flow_style = not self . get_multiline (), width = 2147483647 ) . strip () # All other data has to be str return str ( default ) @cached_property def _formatted_choices ( self ) -> Sequence [ Choice ]: \"\"\"Obtain choices rendered and properly formatted.\"\"\" result = [] choices = self . choices if isinstance ( self . choices , dict ): choices = list ( self . choices . items ()) for choice in choices : # If a choice is a value pair if isinstance ( choice , ( tuple , list )): name , value = choice # If a choice is a single value else : name = value = choice # The name must always be a str name = str ( self . render_value ( name )) # The value can be templated value = self . render_value ( value ) result . append ( Choice ( name , value )) return result def filter_answer ( self , answer ) -> Any : \"\"\"Cast the answer to the desired type.\"\"\" if answer == self . get_default_rendered (): return self . get_default () return cast_answer_type ( answer , self . get_cast_fn ()) def get_message ( self ) -> str : \"\"\"Get the message that will be printed to the user.\"\"\" if self . help : rendered_help = self . render_value ( self . help ) if rendered_help : return force_str_end ( rendered_help ) + \" \" # Otherwise, there's no help message defined. message = self . var_name answer_type = self . get_type_name () if answer_type != \"str\" : message += f \" ( { answer_type } )\" return message + \" \\n \" def get_placeholder ( self ) -> str : \"\"\"Render and obtain the placeholder.\"\"\" return self . render_value ( self . placeholder ) def get_questionary_structure ( self ) -> AnyByStrDict : \"\"\"Get the question in a format that the questionary lib understands.\"\"\" lexer = None result : AnyByStrDict = { \"default\" : self . get_default_rendered (), \"filter\" : self . filter_answer , \"message\" : self . get_message (), \"mouse_support\" : True , \"name\" : self . var_name , \"qmark\" : \"\ud83d\udd75\ufe0f\" if self . secret else \"\ud83c\udfa4\" , \"when\" : self . get_when , } questionary_type = \"input\" type_name = self . get_type_name () if type_name == \"bool\" : questionary_type = \"confirm\" if self . choices : questionary_type = \"select\" result [ \"choices\" ] = self . _formatted_choices if questionary_type == \"input\" : if self . secret : questionary_type = \"password\" elif type_name == \"yaml\" : lexer = PygmentsLexer ( YamlLexer ) elif type_name == \"json\" : lexer = PygmentsLexer ( JsonLexer ) if lexer : result [ \"lexer\" ] = lexer result [ \"multiline\" ] = self . get_multiline () placeholder = self . get_placeholder () if placeholder : result [ \"placeholder\" ] = placeholder result [ \"validate\" ] = self . validate_answer result . update ({ \"type\" : questionary_type }) return result def get_cast_fn ( self ) -> Callable : \"\"\"Obtain function to cast user answer to desired type.\"\"\" type_name = self . get_type_name () if type_name not in CAST_STR_TO_NATIVE : raise InvalidTypeError ( \"Invalid question type\" ) return CAST_STR_TO_NATIVE . get ( type_name , parse_yaml_string ) def get_type_name ( self ) -> str : \"\"\"Render the type name and return it.\"\"\" return self . render_value ( self . type ) def get_multiline ( self ) -> bool : \"\"\"Get the value for multiline.\"\"\" multiline = self . render_value ( self . multiline ) multiline = cast_answer_type ( multiline , cast_str_to_bool ) return bool ( multiline ) def validate_answer ( self , answer ) -> bool : \"\"\"Validate user answer.\"\"\" cast_fn = self . get_cast_fn () try : ans = cast_fn ( answer ) except Exception : return False try : err_msg = self . render_value ( self . validator , { self . var_name : ans }) . strip () except Exception as error : raise ValidationError ( message = str ( error )) from error if err_msg : raise ValidationError ( message = err_msg ) return True def get_when ( self , answers ) -> bool : \"\"\"Get skip condition for question.\"\"\" if ( # Skip on --defaults not self . ask_user # Skip on --data=this_question=some_answer or self . var_name in self . answers . init ): return False when = self . when when = self . render_value ( when ) when = cast_answer_type ( when , cast_str_to_bool ) return bool ( when ) def render_value ( self , value : Any , extra_answers : Optional [ AnyByStrDict ] = None ) -> str : \"\"\"Render a single templated value using Jinja. If the value cannot be used as a template, it will be returned as is. `extra_answers` are combined self `self.answers.combined` when rendering the template. \"\"\" try : template = self . jinja_env . from_string ( value ) except TypeError : # value was not a string return value try : return template . render ({ ** self . answers . combined , ** ( extra_answers or {})}) except UndefinedError as error : raise UserMessageError ( str ( error )) from error","title":"Question"},{"location":"reference/user_data/#copier.user_data.Question.filter_answer","text":"Cast the answer to the desired type. Source code in copier/user_data.py 290 291 292 293 294 def filter_answer ( self , answer ) -> Any : \"\"\"Cast the answer to the desired type.\"\"\" if answer == self . get_default_rendered (): return self . get_default () return cast_answer_type ( answer , self . get_cast_fn ())","title":"filter_answer()"},{"location":"reference/user_data/#copier.user_data.Question.get_cast_fn","text":"Obtain function to cast user answer to desired type. Source code in copier/user_data.py 349 350 351 352 353 354 def get_cast_fn ( self ) -> Callable : \"\"\"Obtain function to cast user answer to desired type.\"\"\" type_name = self . get_type_name () if type_name not in CAST_STR_TO_NATIVE : raise InvalidTypeError ( \"Invalid question type\" ) return CAST_STR_TO_NATIVE . get ( type_name , parse_yaml_string )","title":"get_cast_fn()"},{"location":"reference/user_data/#copier.user_data.Question.get_default","text":"Get the default value for this question, casted to its expected type. Source code in copier/user_data.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def get_default ( self ) -> Any : \"\"\"Get the default value for this question, casted to its expected type.\"\"\" cast_fn = self . get_cast_fn () try : result = self . answers . init [ self . var_name ] except KeyError : try : result = self . answers . last [ self . var_name ] except KeyError : try : result = self . answers . user_defaults [ self . var_name ] except KeyError : result = self . render_value ( self . default ) result = cast_answer_type ( result , cast_fn ) return result","title":"get_default()"},{"location":"reference/user_data/#copier.user_data.Question.get_default_rendered","text":"Get default answer rendered for the questionary lib. The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa. This helper allows such usages. Source code in copier/user_data.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def get_default_rendered ( self ) -> Union [ bool , str , Choice , None ]: \"\"\"Get default answer rendered for the questionary lib. The questionary lib expects some specific data types, and returns it when the user answers. Sometimes you need to compare the response to the rendered one, or viceversa. This helper allows such usages. \"\"\" default = self . get_default () # If there are choices, return the one that matches the expressed default if self . choices : for choice in self . _formatted_choices : if choice . value == default : return choice return None # Yes/No questions expect and return bools if isinstance ( default , bool ) and self . get_type_name () == \"bool\" : return default # Emptiness is expressed as an empty str if default is None : return \"\" # JSON and YAML dumped depending on multiline setting if self . get_type_name () == \"json\" : return json . dumps ( default , indent = 2 if self . get_multiline () else None ) if self . get_type_name () == \"yaml\" : return yaml . safe_dump ( default , default_flow_style = not self . get_multiline (), width = 2147483647 ) . strip () # All other data has to be str return str ( default )","title":"get_default_rendered()"},{"location":"reference/user_data/#copier.user_data.Question.get_message","text":"Get the message that will be printed to the user. Source code in copier/user_data.py 296 297 298 299 300 301 302 303 304 305 306 307 def get_message ( self ) -> str : \"\"\"Get the message that will be printed to the user.\"\"\" if self . help : rendered_help = self . render_value ( self . help ) if rendered_help : return force_str_end ( rendered_help ) + \" \" # Otherwise, there's no help message defined. message = self . var_name answer_type = self . get_type_name () if answer_type != \"str\" : message += f \" ( { answer_type } )\" return message + \" \\n \"","title":"get_message()"},{"location":"reference/user_data/#copier.user_data.Question.get_multiline","text":"Get the value for multiline. Source code in copier/user_data.py 360 361 362 363 364 def get_multiline ( self ) -> bool : \"\"\"Get the value for multiline.\"\"\" multiline = self . render_value ( self . multiline ) multiline = cast_answer_type ( multiline , cast_str_to_bool ) return bool ( multiline )","title":"get_multiline()"},{"location":"reference/user_data/#copier.user_data.Question.get_placeholder","text":"Render and obtain the placeholder. Source code in copier/user_data.py 309 310 311 def get_placeholder ( self ) -> str : \"\"\"Render and obtain the placeholder.\"\"\" return self . render_value ( self . placeholder )","title":"get_placeholder()"},{"location":"reference/user_data/#copier.user_data.Question.get_questionary_structure","text":"Get the question in a format that the questionary lib understands. Source code in copier/user_data.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def get_questionary_structure ( self ) -> AnyByStrDict : \"\"\"Get the question in a format that the questionary lib understands.\"\"\" lexer = None result : AnyByStrDict = { \"default\" : self . get_default_rendered (), \"filter\" : self . filter_answer , \"message\" : self . get_message (), \"mouse_support\" : True , \"name\" : self . var_name , \"qmark\" : \"\ud83d\udd75\ufe0f\" if self . secret else \"\ud83c\udfa4\" , \"when\" : self . get_when , } questionary_type = \"input\" type_name = self . get_type_name () if type_name == \"bool\" : questionary_type = \"confirm\" if self . choices : questionary_type = \"select\" result [ \"choices\" ] = self . _formatted_choices if questionary_type == \"input\" : if self . secret : questionary_type = \"password\" elif type_name == \"yaml\" : lexer = PygmentsLexer ( YamlLexer ) elif type_name == \"json\" : lexer = PygmentsLexer ( JsonLexer ) if lexer : result [ \"lexer\" ] = lexer result [ \"multiline\" ] = self . get_multiline () placeholder = self . get_placeholder () if placeholder : result [ \"placeholder\" ] = placeholder result [ \"validate\" ] = self . validate_answer result . update ({ \"type\" : questionary_type }) return result","title":"get_questionary_structure()"},{"location":"reference/user_data/#copier.user_data.Question.get_type_name","text":"Render the type name and return it. Source code in copier/user_data.py 356 357 358 def get_type_name ( self ) -> str : \"\"\"Render the type name and return it.\"\"\" return self . render_value ( self . type )","title":"get_type_name()"},{"location":"reference/user_data/#copier.user_data.Question.get_when","text":"Get skip condition for question. Source code in copier/user_data.py 382 383 384 385 386 387 388 389 390 391 392 393 394 def get_when ( self , answers ) -> bool : \"\"\"Get skip condition for question.\"\"\" if ( # Skip on --defaults not self . ask_user # Skip on --data=this_question=some_answer or self . var_name in self . answers . init ): return False when = self . when when = self . render_value ( when ) when = cast_answer_type ( when , cast_str_to_bool ) return bool ( when )","title":"get_when()"},{"location":"reference/user_data/#copier.user_data.Question.render_value","text":"Render a single templated value using Jinja. If the value cannot be used as a template, it will be returned as is. extra_answers are combined self self.answers.combined when rendering the template. Source code in copier/user_data.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def render_value ( self , value : Any , extra_answers : Optional [ AnyByStrDict ] = None ) -> str : \"\"\"Render a single templated value using Jinja. If the value cannot be used as a template, it will be returned as is. `extra_answers` are combined self `self.answers.combined` when rendering the template. \"\"\" try : template = self . jinja_env . from_string ( value ) except TypeError : # value was not a string return value try : return template . render ({ ** self . answers . combined , ** ( extra_answers or {})}) except UndefinedError as error : raise UserMessageError ( str ( error )) from error","title":"render_value()"},{"location":"reference/user_data/#copier.user_data.Question.validate_answer","text":"Validate user answer. Source code in copier/user_data.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def validate_answer ( self , answer ) -> bool : \"\"\"Validate user answer.\"\"\" cast_fn = self . get_cast_fn () try : ans = cast_fn ( answer ) except Exception : return False try : err_msg = self . render_value ( self . validator , { self . var_name : ans }) . strip () except Exception as error : raise ValidationError ( message = str ( error )) from error if err_msg : raise ValidationError ( message = err_msg ) return True","title":"validate_answer()"},{"location":"reference/user_data/#copier.user_data.cast_answer_type","text":"Cast answer to expected type. Source code in copier/user_data.py 440 441 442 443 444 445 446 447 448 449 def cast_answer_type ( answer : Any , type_fn : Callable ) -> Any : \"\"\"Cast answer to expected type.\"\"\" # Skip casting None into \"None\" if type_fn is str and answer is None : return answer try : return type_fn ( answer ) except ( TypeError , AttributeError ): # JSON or YAML failed because it wasn't a string; no need to convert return answer","title":"cast_answer_type()"},{"location":"reference/user_data/#copier.user_data.load_answersfile_data","text":"Load answers data from a $dst_path/$answers_file file if it exists. Source code in copier/user_data.py 428 429 430 431 432 433 434 435 436 437 def load_answersfile_data ( dst_path : StrOrPath , answers_file : OptStrOrPath = None , ) -> AnyByStrDict : \"\"\"Load answers data from a `$dst_path/$answers_file` file if it exists.\"\"\" try : with open ( Path ( dst_path ) / ( answers_file or \".copier-answers.yml\" )) as fd : return yaml . safe_load ( fd ) except FileNotFoundError : return {}","title":"load_answersfile_data()"},{"location":"reference/user_data/#copier.user_data.parse_yaml_string","text":"Parse a YAML string and raise a ValueError if parsing failed. This method is needed because :meth: prompt requires a ValueError to repeat failed questions. Source code in copier/user_data.py 416 417 418 419 420 421 422 423 424 425 def parse_yaml_string ( string : str ) -> Any : \"\"\"Parse a YAML string and raise a ValueError if parsing failed. This method is needed because :meth:`prompt` requires a ``ValueError`` to repeat failed questions. \"\"\" try : return yaml . safe_load ( string ) except yaml . error . YAMLError as error : raise ValueError ( str ( error ))","title":"parse_yaml_string()"},{"location":"reference/vcs/","text":"Utilities related to VCS. checkout_latest_tag ( local_repo , use_prereleases = False ) \u00b6 Checkout latest git tag and check it out, sorted by PEP 440. Parameters: Name Type Description Default local_repo StrOrPath A git repository in the local filesystem. required use_prereleases OptBool If False , skip prerelease git tags. False Source code in copier/vcs.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def checkout_latest_tag ( local_repo : StrOrPath , use_prereleases : OptBool = False ) -> str : \"\"\"Checkout latest git tag and check it out, sorted by PEP 440. Parameters: local_repo: A git repository in the local filesystem. use_prereleases: If `False`, skip prerelease git tags. \"\"\" with local . cwd ( local_repo ): all_tags = git ( \"tag\" ) . split () if not use_prereleases : all_tags = filter ( lambda tag : not version . parse ( tag ) . is_prerelease , all_tags ) sorted_tags = sorted ( all_tags , key = version . parse , reverse = True ) try : latest_tag = str ( sorted_tags [ 0 ]) except IndexError : print ( colors . warn | \"No git tags found in template; using HEAD as ref\" , file = sys . stderr , ) latest_tag = \"HEAD\" git ( \"checkout\" , \"--force\" , latest_tag ) git ( \"submodule\" , \"update\" , \"--checkout\" , \"--init\" , \"--recursive\" , \"--force\" ) return latest_tag clone ( url , ref = None ) \u00b6 Clone repo into some temporary destination. Includes dirty changes for local templates by copying into a temp directory and applying a wip commit there. Parameters: Name Type Description Default url str Git-parseable URL of the repo. As returned by get_repo . required ref OptStr Reference to checkout. For Git repos, defaults to HEAD . None Source code in copier/vcs.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def clone ( url : str , ref : OptStr = None ) -> str : \"\"\"Clone repo into some temporary destination. Includes dirty changes for local templates by copying into a temp directory and applying a wip commit there. Args: url: Git-parseable URL of the repo. As returned by [get_repo][copier.vcs.get_repo]. ref: Reference to checkout. For Git repos, defaults to `HEAD`. \"\"\" location = mkdtemp ( prefix = f \" { __name__ } .clone.\" ) _clone = git [ \"clone\" , \"--no-checkout\" , url , location ] # Faster clones if possible if GIT_VERSION >= Version ( \"2.27\" ): _clone = _clone [ \"--filter=blob:none\" ] _clone () if not ref and os . path . exists ( url ) and Path ( url ) . is_dir (): is_dirty = False with local . cwd ( url ): is_dirty = bool ( git ( \"status\" , \"--porcelain\" ) . strip ()) if is_dirty : url_abspath = Path ( url ) . absolute () with local . cwd ( location ): git ( \"--git-dir=.git\" , f \"--work-tree= { url_abspath } \" , \"add\" , \"-A\" ) git ( \"--git-dir=.git\" , f \"--work-tree= { url_abspath } \" , \"commit\" , \"-m\" , \"Copier automated commit for draft changes\" , \"--no-verify\" , ) warn ( \"Dirty template changes included automatically.\" , DirtyLocalWarning , ) with local . cwd ( location ): git ( \"checkout\" , ref or \"HEAD\" ) git ( \"submodule\" , \"update\" , \"--checkout\" , \"--init\" , \"--recursive\" , \"--force\" ) return location get_repo ( url ) \u00b6 Transforms url into a git-parseable origin URL. Parameters: Name Type Description Default url str Valid examples: gh:copier-org/copier gl:copier-org/copier git@github.com :copier-org/copier.git git+ https://mywebsiteisagitrepo.example.com/ /local/path/to/git/repo /local/path/to/git/bundle/file.bundle ~/path/to/git/repo ~/path/to/git/repo.bundle required Source code in copier/vcs.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get_repo ( url : str ) -> OptStr : \"\"\"Transforms `url` into a git-parseable origin URL. Args: url: Valid examples: - gh:copier-org/copier - gl:copier-org/copier - git@github.com:copier-org/copier.git - git+https://mywebsiteisagitrepo.example.com/ - /local/path/to/git/repo - /local/path/to/git/bundle/file.bundle - ~/path/to/git/repo - ~/path/to/git/repo.bundle \"\"\" for pattern , replacement in REPLACEMENTS : url = re . sub ( pattern , replacement , url ) if url . endswith ( GIT_POSTFIX ) or url . startswith ( GIT_PREFIX ): if url . startswith ( \"git+\" ): url = url [ 4 :] elif url . startswith ( \"https://\" ) and not url . endswith ( GIT_POSTFIX ): url = \"\" . join (( url , GIT_POSTFIX )) return url url_path = Path ( url ) if url . startswith ( \"~\" ): url_path = url_path . expanduser () if is_git_repo_root ( url_path ) or is_git_bundle ( url_path ): return url_path . as_posix () return None is_git_bundle ( path ) \u00b6 Indicate if a path is a valid git bundle. Source code in copier/vcs.py 48 49 50 51 52 53 54 55 def is_git_bundle ( path : Path ) -> bool : \"\"\"Indicate if a path is a valid git bundle.\"\"\" with suppress ( OSError ): path = path . resolve () with TemporaryDirectory ( prefix = f \" { __name__ } .is_git_bundle.\" ) as dirname : with local . cwd ( dirname ): git ( \"init\" ) return bool ( git [ \"bundle\" , \"verify\" , path ] & TF ) is_git_repo_root ( path ) \u00b6 Indicate if a given path is a git repo root directory. Source code in copier/vcs.py 30 31 32 33 34 35 36 def is_git_repo_root ( path : StrOrPath ) -> bool : \"\"\"Indicate if a given path is a git repo root directory.\"\"\" try : with local . cwd ( Path ( path , \".git\" )): return git ( \"rev-parse\" , \"--is-inside-git-dir\" ) . strip () == \"true\" except OSError : return False is_in_git_repo ( path ) \u00b6 Indicate if a given path is in a git repo directory. Source code in copier/vcs.py 39 40 41 42 43 44 45 def is_in_git_repo ( path : StrOrPath ) -> bool : \"\"\"Indicate if a given path is in a git repo directory.\"\"\" try : git ( \"-C\" , path , \"rev-parse\" , \"--show-toplevel\" ) return True except ( OSError , ProcessExecutionError ): return False","title":"vcs.py"},{"location":"reference/vcs/#copier.vcs.checkout_latest_tag","text":"Checkout latest git tag and check it out, sorted by PEP 440. Parameters: Name Type Description Default local_repo StrOrPath A git repository in the local filesystem. required use_prereleases OptBool If False , skip prerelease git tags. False Source code in copier/vcs.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def checkout_latest_tag ( local_repo : StrOrPath , use_prereleases : OptBool = False ) -> str : \"\"\"Checkout latest git tag and check it out, sorted by PEP 440. Parameters: local_repo: A git repository in the local filesystem. use_prereleases: If `False`, skip prerelease git tags. \"\"\" with local . cwd ( local_repo ): all_tags = git ( \"tag\" ) . split () if not use_prereleases : all_tags = filter ( lambda tag : not version . parse ( tag ) . is_prerelease , all_tags ) sorted_tags = sorted ( all_tags , key = version . parse , reverse = True ) try : latest_tag = str ( sorted_tags [ 0 ]) except IndexError : print ( colors . warn | \"No git tags found in template; using HEAD as ref\" , file = sys . stderr , ) latest_tag = \"HEAD\" git ( \"checkout\" , \"--force\" , latest_tag ) git ( \"submodule\" , \"update\" , \"--checkout\" , \"--init\" , \"--recursive\" , \"--force\" ) return latest_tag","title":"checkout_latest_tag()"},{"location":"reference/vcs/#copier.vcs.clone","text":"Clone repo into some temporary destination. Includes dirty changes for local templates by copying into a temp directory and applying a wip commit there. Parameters: Name Type Description Default url str Git-parseable URL of the repo. As returned by get_repo . required ref OptStr Reference to checkout. For Git repos, defaults to HEAD . None Source code in copier/vcs.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def clone ( url : str , ref : OptStr = None ) -> str : \"\"\"Clone repo into some temporary destination. Includes dirty changes for local templates by copying into a temp directory and applying a wip commit there. Args: url: Git-parseable URL of the repo. As returned by [get_repo][copier.vcs.get_repo]. ref: Reference to checkout. For Git repos, defaults to `HEAD`. \"\"\" location = mkdtemp ( prefix = f \" { __name__ } .clone.\" ) _clone = git [ \"clone\" , \"--no-checkout\" , url , location ] # Faster clones if possible if GIT_VERSION >= Version ( \"2.27\" ): _clone = _clone [ \"--filter=blob:none\" ] _clone () if not ref and os . path . exists ( url ) and Path ( url ) . is_dir (): is_dirty = False with local . cwd ( url ): is_dirty = bool ( git ( \"status\" , \"--porcelain\" ) . strip ()) if is_dirty : url_abspath = Path ( url ) . absolute () with local . cwd ( location ): git ( \"--git-dir=.git\" , f \"--work-tree= { url_abspath } \" , \"add\" , \"-A\" ) git ( \"--git-dir=.git\" , f \"--work-tree= { url_abspath } \" , \"commit\" , \"-m\" , \"Copier automated commit for draft changes\" , \"--no-verify\" , ) warn ( \"Dirty template changes included automatically.\" , DirtyLocalWarning , ) with local . cwd ( location ): git ( \"checkout\" , ref or \"HEAD\" ) git ( \"submodule\" , \"update\" , \"--checkout\" , \"--init\" , \"--recursive\" , \"--force\" ) return location","title":"clone()"},{"location":"reference/vcs/#copier.vcs.get_repo","text":"Transforms url into a git-parseable origin URL. Parameters: Name Type Description Default url str Valid examples: gh:copier-org/copier gl:copier-org/copier git@github.com :copier-org/copier.git git+ https://mywebsiteisagitrepo.example.com/ /local/path/to/git/repo /local/path/to/git/bundle/file.bundle ~/path/to/git/repo ~/path/to/git/repo.bundle required Source code in copier/vcs.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get_repo ( url : str ) -> OptStr : \"\"\"Transforms `url` into a git-parseable origin URL. Args: url: Valid examples: - gh:copier-org/copier - gl:copier-org/copier - git@github.com:copier-org/copier.git - git+https://mywebsiteisagitrepo.example.com/ - /local/path/to/git/repo - /local/path/to/git/bundle/file.bundle - ~/path/to/git/repo - ~/path/to/git/repo.bundle \"\"\" for pattern , replacement in REPLACEMENTS : url = re . sub ( pattern , replacement , url ) if url . endswith ( GIT_POSTFIX ) or url . startswith ( GIT_PREFIX ): if url . startswith ( \"git+\" ): url = url [ 4 :] elif url . startswith ( \"https://\" ) and not url . endswith ( GIT_POSTFIX ): url = \"\" . join (( url , GIT_POSTFIX )) return url url_path = Path ( url ) if url . startswith ( \"~\" ): url_path = url_path . expanduser () if is_git_repo_root ( url_path ) or is_git_bundle ( url_path ): return url_path . as_posix () return None","title":"get_repo()"},{"location":"reference/vcs/#copier.vcs.is_git_bundle","text":"Indicate if a path is a valid git bundle. Source code in copier/vcs.py 48 49 50 51 52 53 54 55 def is_git_bundle ( path : Path ) -> bool : \"\"\"Indicate if a path is a valid git bundle.\"\"\" with suppress ( OSError ): path = path . resolve () with TemporaryDirectory ( prefix = f \" { __name__ } .is_git_bundle.\" ) as dirname : with local . cwd ( dirname ): git ( \"init\" ) return bool ( git [ \"bundle\" , \"verify\" , path ] & TF )","title":"is_git_bundle()"},{"location":"reference/vcs/#copier.vcs.is_git_repo_root","text":"Indicate if a given path is a git repo root directory. Source code in copier/vcs.py 30 31 32 33 34 35 36 def is_git_repo_root ( path : StrOrPath ) -> bool : \"\"\"Indicate if a given path is a git repo root directory.\"\"\" try : with local . cwd ( Path ( path , \".git\" )): return git ( \"rev-parse\" , \"--is-inside-git-dir\" ) . strip () == \"true\" except OSError : return False","title":"is_git_repo_root()"},{"location":"reference/vcs/#copier.vcs.is_in_git_repo","text":"Indicate if a given path is in a git repo directory. Source code in copier/vcs.py 39 40 41 42 43 44 45 def is_in_git_repo ( path : StrOrPath ) -> bool : \"\"\"Indicate if a given path is in a git repo directory.\"\"\" try : git ( \"-C\" , path , \"rev-parse\" , \"--show-toplevel\" ) return True except ( OSError , ProcessExecutionError ): return False","title":"is_in_git_repo()"}]}